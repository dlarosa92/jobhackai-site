<!-- DO NOT EDIT HEADER OR FOOTER PER-PAGE. Use canonical snippet from docs/snippets.md. -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>html.auth-pending,html.plan-pending{visibility:hidden}</style>
  <script src="js/static-auth-guard.js?v=20260125-1"></script>
  <script>
    // --- IMMEDIATE PAGE ACCESS CONTROL ---
    // Run immediately to prevent content flash for unauthorized users
    (function enforceAccessImmediate() {
      // SECURITY: Check auth state using localStorage flags and Firebase SDK keys
      const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
      const hasFirebaseKeys = Object.keys(localStorage).some(k => 
        k.startsWith('firebase:authUser:') && 
        localStorage.getItem(k) && 
        localStorage.getItem(k) !== 'null' &&
        localStorage.getItem(k).length > 10
      );
      const isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
      const allowedPlans = ['trial', 'essential', 'pro', 'premium'];
      window.__JOBHACKAI_RF_ALLOWED_PLANS__ = allowedPlans;
      const cachedPlan = localStorage.getItem('user-plan');

      // Wait for firebase-auth-ready or hydration before irreversible action
      let done = false;
      const timeoutHandle = setTimeout(() => {
        if (!done) handleAuthReadyOrTimeout();
      }, 3000);

      async function handleAuthReadyOrTimeout() {
        if (done) return;
        done = true;
        try { clearTimeout(timeoutHandle); } catch (_) {}

        // TRI-STATE FIX: Wait for Firebase auth to be ready before redirecting
        // This prevents race conditions where Firebase is still initializing
        let user = null;
        if (window.FirebaseAuthManager && typeof window.FirebaseAuthManager.waitForAuthReady === 'function') {
          try {
            user = await window.FirebaseAuthManager.waitForAuthReady(5000);
          } catch (error) {
            console.warn('[RESUME-FEEDBACK] waitForAuthReady error in immediate check:', error);
          }
        }

        const navAuth = window.JobHackAINavigation && window.JobHackAINavigation.getAuthState && window.JobHackAINavigation.getAuthState();
        const effectivePlan = window.JobHackAINavigation && window.JobHackAINavigation.getEffectivePlan && window.JobHackAINavigation.getEffectivePlan();
        const hydratedPlan = effectivePlan || cachedPlan;

        // Check authentication: prefer Firebase user, then navigation, then localStorage
        const isAuthenticated = user || (navAuth && navAuth.isAuthenticated);
        
        if (!isAuthenticated) {
          window.location.href = 'login.html';
          return;
        }
        if (hydratedPlan && !allowedPlans.includes(hydratedPlan)) {
          window.location.href = 'pricing-a.html?plan=essential';
          return;
        }
        document.documentElement.classList.remove('auth-pending');
        document.documentElement.classList.remove('plan-pending');
      }

      if (!isAuthenticated) {
        document.documentElement.classList.add('auth-pending');
        document.addEventListener('firebase-auth-ready', handleAuthReadyOrTimeout, { once: true });
      } else {
        // If cachedPlan missing, mark plan-pending until server check completes
        if (!cachedPlan) {
          window.__JOBHACKAI_PLAN_PENDING__ = true;
          document.documentElement.classList.add('plan-pending');
          document.addEventListener('firebase-auth-ready', handleAuthReadyOrTimeout, { once: true });
        } else if (cachedPlan && !allowedPlans.includes(cachedPlan)) {
          document.documentElement.classList.add('plan-pending');
          document.addEventListener('firebase-auth-ready', handleAuthReadyOrTimeout, { once: true });
        } else {
          document.documentElement.classList.remove('auth-pending');
          document.documentElement.classList.remove('plan-pending');
          done = true;
          try { clearTimeout(timeoutHandle); } catch (_) {}
        }
      }
    })();
  </script>
  <title>JobHackAI</title>
  <link rel="icon" type="image/png" href="assets/jobhackai_icon_only_128.png">
  <link rel="apple-touch-icon" href="assets/jobhackai_icon_only_128.png">
  <script src="js/dynamic-favicon.js?v=20250111-1"></script>

  <!-- Design tokens & global styles -->
  <link rel="stylesheet" href="css/tokens.css">
  <link rel="stylesheet" href="css/main.css">

  <!-- Load usage indicator component early (before inline scripts that use it) -->
  <script src="js/components/usage-indicator.js"></script>
  <script src="js/run-authority.js?v=20260112-1"></script>

  <!-- Component overrides -->
  <link rel="stylesheet" href="css/header.css">
  <link rel="stylesheet" href="css/footer.css">
  <link rel="stylesheet" href="css/history-tile.css">
  <style>
    html, body {
      height: 100%;
    }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    main {
      flex: 1 0 auto;
    }
    .site-footer {
      flex-shrink: 0;
      position: relative;
      bottom: 0;
      width: 100%;
      background: var(--color-card-bg);
    }
    /* Two-pane layout for main content + sticky history sidebar */
    .rf-layout-container {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: var(--space-lg);
      align-items: start;
      max-width: 1200px;
      margin: 0 auto;
    }
    @media (max-width: 1024px) {
      .rf-layout-container {
        grid-template-columns: 1fr;
      }
    }
    .rf-main-column {
      min-width: 0;
    }
    .rf-sidebar-column {
      position: sticky;
      top: 100px;
    }
    @media (max-width: 1024px) {
      .rf-sidebar-column {
        position: static;
      }
    }
    /* Historical view banner */
    .rf-historical-banner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.875rem 1.25rem;
      background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%);
      border: 1px solid #F59E0B;
      border-radius: var(--radius-lg);
      margin-bottom: var(--space-lg);
      flex-wrap: wrap;
    }
    .rf-historical-banner-text {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #92400E;
      font-size: 0.95rem;
      font-weight: 500;
    }
    .rf-historical-banner-text svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }
    .rf-historical-banner .btn-primary {
      white-space: nowrap;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
    }
    .rf-card { background: var(--color-card-bg); border-radius: var(--radius-xl); box-shadow: var(--shadow-card); padding: var(--space-lg); margin-bottom: var(--space-lg); }
    .rf-title { font-size: var(--font-size-2xl); font-weight: var(--font-weight-extrabold); margin-bottom: var(--space-xs); color: var(--color-text-main); }
    .rf-section-title { font-size: var(--font-size-xl); font-weight: var(--font-weight-bold); margin-bottom: var(--space-xs); color: var(--color-text-main); }
    .rf-progress-ring { width: 80px; min-height: 80px; display: inline-flex; flex-direction: column; align-items: center; vertical-align: middle; margin-right: 1.5rem; }
    .rf-progress-ring svg { flex-shrink: 0; width: 80px; height: 80px; }
    .rf-score-badge { display: inline-block; background: #00E676; color: #fff; font-weight: 700; border-radius: 999px; padding: 0.3em 1em; font-size: 1.2rem; margin-left: 0.7rem; }
    /* Status pill component - matches existing .rf-score-badge pattern */
    .rf-status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.55rem;
      border-radius: var(--radius-full);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
      font-family: var(--font-family-base);
      border: 1px solid transparent;
      line-height: 1.2;
      margin-top: 0.5rem;
    }
    .rf-status-icon {
      display: inline-flex;
      align-items: center;
      flex-shrink: 0;
    }
    .rf-status-icon svg {
      width: 14px;
      height: 14px;
      stroke-width: 2;
    }
    .rf-status-pill--success {
      background-color: rgba(5, 150, 105, 0.06);
      border-color: rgba(5, 150, 105, 0.25);
      color: var(--color-success);
    }
    .rf-status-pill--warning {
      background-color: rgba(217, 119, 6, 0.08);
      border-color: rgba(217, 119, 6, 0.3);
      color: var(--color-warning);
    }
    .rf-status-pill--error {
      background-color: rgba(220, 38, 38, 0.06);
      border-color: rgba(220, 38, 38, 0.25);
      color: var(--color-error);
    }
    .rf-rubric-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1.2rem; margin-top: 1.5rem; }
    .rf-rubric-item { background: #F8FAFC; border-radius: var(--radius-lg); padding: 1rem 1.2rem; }
    .rf-rubric-label { font-weight: 600; color: var(--color-text-main); margin-bottom: 0.2rem; }
    .rf-rubric-score { font-size: 1.1rem; font-weight: 700; color: #1976D2; }
    .rf-feedback-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1.2rem; margin-top: 1.5rem; }
    .rf-feedback-card { background: #fff; border-radius: var(--radius-lg); box-shadow: 0 1px 3px rgba(0,0,0,0.07); padding: 1.2rem 1.2rem 1rem 1.2rem; }
    .rf-feedback-label { font-weight: 700; color: var(--color-text-main); margin-bottom: 0.2rem; }
    .rf-feedback-score { display: inline-block; background: #00E676; color: #fff; font-weight: 700; border-radius: 999px; padding: 0.2em 0.8em; font-size: 1rem; margin-left: 0.5rem; }
    .rf-feedback-tip { color: var(--color-text-secondary); font-size: 1.01rem; margin-top: 0.3rem; }
    .rf-snippet-box { width: 100%; min-height: 120px; border: 2px solid var(--color-divider); border-radius: var(--radius-lg); padding: 1rem; font-family: var(--font-family-base); font-size: var(--font-size-base); font-weight: var(--font-weight-regular); margin-bottom: 1.2rem; background: #F9FAFB; color: var(--color-text-main); resize: vertical; }
    /* Ensure rewrite buttons are same size */
    #rf-rewrite-content .btn-primary,
    #rf-rewrite-content .btn-secondary {
      padding: 0.7rem 2rem;
      font-size: 1rem;
    }
    @media (max-width: 700px) { .rf-rubric-grid, .rf-feedback-grid { grid-template-columns: 1fr; } }
    .rf-plan-badge {
      display: inline-block;
      background: var(--color-accent-blue);
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 0.2em 0.8em;
      font-size: 0.9rem;
      margin-left: 0.7rem;
    }
    .rf-plan-badge.rf-plan-badge--pending {
      display: none;
    }
    .rf-plan-limit {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--color-text-secondary);
      font-size: 0.95rem;
      margin-top: 0.5rem;
    }
    .rf-upgrade-prompt {
      background: #F0F7FF;
      border-radius: var(--radius-lg);
      padding: 1rem;
      margin-top: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .rf-upgrade-prompt svg {
      width: 24px;
      height: 24px;
      color: var(--color-accent-blue);
      flex-shrink: 0;
    }
    .rf-upgrade-text {
      flex: 1;
      color: var(--color-text-main);
      font-size: 0.95rem;
    }
    .rf-upgrade-text strong {
      color: var(--color-accent-blue);
    }
    /* Standardized upgrade button styling - filled blue for all CTA buttons */
    .rf-upgrade-prompt .btn.btn-secondary,
    .rf-upgrade-prompt a.btn {
      background: #1976D2 !important;
      color: #fff !important;
      font-weight: 600;
      border: none !important;
      border-radius: var(--radius-md);
      padding: 0.6rem 1.3rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.18s;
      text-decoration: none;
      display: inline-block;
      white-space: nowrap;
    }
    .rf-upgrade-prompt .btn.btn-secondary:hover,
    .rf-upgrade-prompt a.btn:hover {
      background: #125bb5 !important;
    }
    /* ===== SKELETON LOADING STATES (Performance-Optimized) ===== */
    @keyframes rf-shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    .rf-skeleton {
      background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
      background-size: 200% 100%;
      animation: rf-shimmer 1.5s infinite;
      border-radius: var(--radius-lg);
      opacity: 1;
      transition: opacity 0.3s ease;
      /* Force browser to keep animation running even when tab is inactive */
      will-change: background-position;
      /* Fallback: ensure visibility even if animation stops */
      background-color: #f0f0f0;
    }
    .rf-skeleton.hidden {
      opacity: 0;
      pointer-events: none;
      animation: none; /* Stop animation when hiding */
    }
    /* Ensure skeleton container stays visible */
    #rf-skeleton-container {
      /* Prevent hiding when tab becomes inactive */
      visibility: visible !important;
    }
    .rf-skeleton-header {
      height: 60px;
      margin-bottom: 1.5rem;
    }
    .rf-skeleton-rubric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.2rem;
      margin-top: 1.5rem;
    }
    .rf-skeleton-rubric-card {
      height: 150px;
    }
    .rf-skeleton-feedback-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1.2rem;
      margin-top: 1.5rem;
    }
    .rf-skeleton-feedback-card {
      height: 200px;
    }
    /* Skeleton state for rewrite textareas (inside the boxes, not overlaying the card) */
    .rf-snippet-box.rf-snippet-skeleton {
      color: transparent !important;
      caret-color: transparent;
      border-color: #E5E7EB;
      background-clip: padding-box;
      pointer-events: none;
    }
    .rf-btn-secondary {
      background: transparent;
      color: var(--color-accent-blue);
      font-weight: 600;
      border: 1px solid var(--color-accent-blue);
      border-radius: var(--radius-md);
      padding: 0.5rem 1rem;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.18s;
    }
    .rf-btn-secondary:hover {
      background: rgba(25, 118, 210, 0.05);
    }
    .rf-btn-ghost {
      background: transparent;
      color: #4B5563;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      padding: 0.65rem 1.1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.18s ease;
    }
    .rf-btn-ghost:hover {
      background: #F9FAFB;
      color: #374151;
      border-color: #D1D5DB;
    }
    /* ============================================================
       HistoryPanel v1 (Resume Feedback)
       Standardized Saved History UI/UX
       ============================================================ */
    .history-card {
      border: 1px solid var(--color-divider);
      padding: 24px;
      margin-bottom: 0;
    }

    .rf-history-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .rf-history-title-wrap {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }

    .rf-history-title-text {
      font-weight: 800;
      color: var(--color-text-main);
      font-size: 1.05rem;
      line-height: 1.2;
    }

    .rf-history-header-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .rf-history-icon-btn {
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--color-divider);
      border-radius: var(--radius-md);
      background: transparent;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease;
    }
    .rf-history-icon-btn:hover {
      background: #F9FAFB;
      border-color: #D1D5DB;
    }

    .rf-history-manage-btn,
    .rf-history-link-btn {
      background: transparent;
      border: none;
      padding: 0.25rem 0;
      cursor: pointer;
      font-weight: 600;
      color: var(--color-text-secondary);
      text-decoration: underline;
      font-size: 0.95rem;
    }
    .rf-history-manage-btn {
      text-decoration: none;
      color: var(--color-text-secondary);
      font-weight: 700;
      border: 1px solid var(--color-divider);
      border-radius: var(--radius-md);
      padding: 0.5rem 1rem;
      background: transparent;
      transition: background 0.18s ease, border-color 0.18s ease;
    }
    .rf-history-manage-btn:hover { 
      color: var(--color-text-main);
      background: #F9FAFB;
      border-color: #D1D5DB;
    }

    .rf-history-subtitle {
      margin-top: 10px;
      font-size: 0.875rem; /* ~14px */
      color: var(--color-text-muted);
    }

    .rf-history-body {
      margin-top: 16px;
    }

    .rf-history-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .rf-history-item {
      position: relative;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0.875rem 1rem;
      background: #fff;
      border-radius: var(--radius-md);
      border: 1px solid var(--color-divider);
      transition: background 0.18s ease, border-color 0.18s ease, outline 0.18s ease;
      cursor: pointer;
      min-height: 56px;
    }
    .rf-history-item:hover {
      background: #F9FAFB;
      border-color: #D1D5DB;
    }
    .rf-history-item.is-selected {
      outline: 2px solid var(--color-accent-blue);
      outline-offset: 0;
      border-color: var(--color-divider);
      background: #fff;
    }

    .rf-history-checkbox-wrap {
      display: none;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .rf-history-checkbox {
      width: 18px;
      height: 18px;
      accent-color: var(--color-accent-blue);
      cursor: pointer;
    }
    .rf-history-panel--manage .rf-history-checkbox-wrap {
      display: inline-flex;
    }

    .rf-history-icon {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, #E0E7FF 0%, #C7D2FE 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .rf-history-icon svg {
      width: 20px;
      height: 20px;
      color: #4F46E5;
    }

    .rf-history-text {
      flex: 1;
      min-width: 0;
    }
    .rf-history-line1 {
      font-weight: 700;
      color: var(--color-text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.95rem;
      line-height: 1.25;
    }
    .rf-history-line2 {
      margin-top: 2px;
      font-size: 0.85rem;
      color: var(--color-text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .rf-history-score {
      font-weight: 800;
      color: var(--color-text-main);
      font-size: 1.05rem;
      min-width: 32px;
      text-align: right;
      flex-shrink: 0;
    }

    .rf-history-row-actions {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-left: 2px;
    }

    .rf-history-kebab {
      width: 40px;
      height: 40px;
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      background: transparent;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.18s ease, border-color 0.18s ease, opacity 0.18s ease;
      opacity: 0;
    }
    .rf-history-item:hover .rf-history-kebab,
    .rf-history-item:focus-within .rf-history-kebab {
      opacity: 1;
    }
    .rf-history-kebab:hover {
      background: #F3F4F6;
      border-color: #E5E7EB;
    }

    /* Mobile (no hover): kebab always visible */
    @media (hover: none), (pointer: coarse) {
      .rf-history-kebab { opacity: 1; }
    }

    .rf-history-menu {
      position: absolute;
      right: 0;
      top: calc(100% + 6px);
      min-width: 170px;
      background: #fff;
      border: 1px solid var(--color-divider);
      border-radius: 12px;
      box-shadow: var(--shadow-dropdown);
      padding: 6px;
      z-index: var(--z-popover);
    }
    .rf-history-menu[hidden] { display: none; }
    .rf-history-menu-item {
      width: 100%;
      text-align: left;
      background: transparent;
      border: none;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      color: var(--color-text-main);
    }
    .rf-history-menu-item:hover {
      background: #F9FAFB;
    }
    .rf-history-menu-item--danger {
      color: var(--color-error);
    }
    .rf-history-menu-item--danger:hover {
      background: rgba(220, 38, 38, 0.06);
    }

    .rf-history-panel--manage .rf-history-header-actions { display: none; }
    .rf-history-manage-actions {
      display: none;
      width: 100%;
      margin-top: 12px;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
    }
    .rf-history-manage-actions__actions {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .rf-history-panel--manage .rf-history-manage-actions { 
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }
    .rf-history-panel--manage .rf-history-row-actions { display: none; }

    .rf-history-danger-btn {
      background: rgba(220, 38, 38, 0.10);
      border: 1px solid rgba(220, 38, 38, 0.25);
      color: var(--color-error);
      font-weight: 800;
      border-radius: var(--radius-md);
      padding: 0.7rem 1rem;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease, opacity 0.18s ease;
    }
    .rf-history-danger-btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    .rf-history-danger-btn:hover:not(:disabled) {
      background: rgba(220, 38, 38, 0.14);
      border-color: rgba(220, 38, 38, 0.35);
    }

    .rf-history-neutral-btn {
      background: #fff;
      border: 1px solid var(--color-divider);
      color: var(--color-text-main);
      font-weight: 700;
      border-radius: var(--radius-md);
      padding: 0.7rem 1rem;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease;
    }
    .rf-history-neutral-btn:hover {
      background: #F9FAFB;
      border-color: #D1D5DB;
    }

    /* Manage actions stacking on small screens */
    @media (max-width: 520px) {
      .rf-history-panel--manage .rf-history-manage-actions {
        flex-direction: column;
        align-items: stretch;
      }
      #rf-history-delete-selected,
      #rf-history-cancel-manage {
        width: 100%;
      }
    }

    .rf-history-loading {
      display: none;
    }
    .rf-history-loading.is-visible {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .rf-history-skeleton-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0.875rem 1rem;
      border-radius: var(--radius-md);
      border: 1px solid var(--color-divider);
      background: #fff;
      min-height: 56px;
    }
    .rf-history-skeleton-pill {
      height: 12px;
      width: 160px;
      border-radius: 999px;
    }
    .rf-history-skeleton-pill.sm { width: 120px; }
    .rf-history-skeleton-score { height: 16px; width: 32px; border-radius: 6px; }

    .rf-history-error {
      padding: 10px 12px;
      border: 1px solid rgba(220, 38, 38, 0.22);
      background: rgba(220, 38, 38, 0.06);
      border-radius: 12px;
      color: var(--color-text-main);
      font-size: 0.95rem;
      margin-bottom: 12px;
    }
    .rf-history-error[hidden] { display: none; }

    .rf-history-empty {
      text-align: center;
      padding: 20px 12px;
      color: var(--color-text-muted);
      border: 1px dashed var(--color-divider);
      border-radius: 12px;
    }
    .rf-history-empty[hidden] { display: none; }

    .rf-history-footer {
      margin-top: 16px;
      font-size: 0.875rem; /* 13â€“14px */
      color: var(--color-text-muted);
      line-height: 1.45;
    }
    .rf-history-footer a,
    .rf-history-footer button {
      font-size: inherit;
    }
    .rf-history-footer-links {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      margin-left: 4px;
    }
    .rf-history-footer-link {
      color: var(--color-accent-blue);
      text-decoration: underline;
    }
    .rf-history-footer-separator {
      color: var(--color-text-muted);
      font-weight: 600;
    }
    .rf-history-footer-link--danger {
      color: var(--color-error);
      background: transparent;
      border: none;
      padding: 0;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
    }
    .rf-history-footer-link--danger:hover {
      text-decoration: underline;
    }

    /* Delete confirmation modal */
    .rf-history-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(17, 24, 39, 0.55);
      z-index: var(--z-modal-backdrop);
    }
    .rf-history-modal-backdrop[hidden] { display: none; }
    .rf-history-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(520px, calc(100vw - 32px));
      background: #fff;
      border: 1px solid var(--color-divider);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-xl);
      padding: 20px;
      z-index: var(--z-modal);
    }
    .rf-history-modal[hidden] { display: none; }
    .rf-history-modal h3 {
      margin: 0 0 8px 0;
      font-size: 1.15rem;
      font-weight: 800;
      color: var(--color-text-main);
    }
    .rf-history-modal p {
      margin: 6px 0;
      color: var(--color-text-secondary);
      line-height: 1.5;
    }
    .rf-history-modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    .rf-history-modal-actions button {
      min-height: 44px;
    }
    @media (max-width: 520px) {
      .rf-history-modal-actions {
        flex-direction: column;
        align-items: stretch;
      }
    }
    .priority-review-cta {
      background: #F0F7FF;
      border-radius: var(--radius-lg);
      padding: 1rem 1.2rem;
      margin: 1.2rem 0 0.5rem 0;
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 1.05rem;
      color: var(--color-text-main);
    }
    /* Premium CTA with white background to match card tiles */
    .priority-review-cta.premium-cta {
      background: var(--color-card-bg);
      box-shadow: var(--shadow-card);
    }
    /* Standardized upgrade button - matches all other upgrade CTAs */
    .priority-review-cta .priority-btn {
      background: #1976D2;
      color: #fff;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.7rem 2rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.18s;
      margin-left: 1.2rem;
      white-space: nowrap;
    }
    .priority-review-cta .priority-btn:hover {
      background: #125bb5;
    }
    .priority-review-tooltip {
      position: relative;
      display: inline-block;
      cursor: pointer;
    }
    .priority-review-tooltip .tooltip-text {
      visibility: hidden;
      width: 260px;
      background: #222;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 0.7rem 1rem;
      position: absolute;
      z-index: 10;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 0.98rem;
      pointer-events: none;
    }
    .priority-review-tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
      pointer-events: auto;
    }
    /* Tooltip style matching Resume Rewriting */
    .rf-tooltip-trigger {
      cursor: pointer;
      margin-left: 0.4em;
      vertical-align: middle;
      position: relative;
      display: inline-block;
    }
    .rf-tooltip-trigger svg {
      width: 16px;
      height: 16px;
      color: #9CA3AF;
      vertical-align: middle;
    }
    .rf-tooltip-text {
      display: none;
      position: absolute;
      z-index: 1070;
      padding: 0.5rem 0.8rem;
      background-color: #333;
      color: #fff;
      border-radius: 4px;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      min-width: 180px;
      max-width: 260px;
      white-space: normal;
      word-break: break-word;
      font-size: 0.9rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      pointer-events: none;
      text-align: left;
      margin-bottom: 0.5rem;
    }
    .rf-tooltip-trigger:hover .rf-tooltip-text,
    .rf-tooltip-trigger:focus .rf-tooltip-text {
      display: block;
      pointer-events: auto;
    }
    /* Fade Transitions */
    .fade-enter {
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.35s ease, transform 0.35s ease;
    }
    .fade-enter-active {
      opacity: 1;
      transform: translateY(0);
    }
    /* Subtle fade-in utility for restored content */
    .rf-fade-in {
      opacity: 0;
      animation: rfFadeIn 220ms ease-out forwards;
    }
    @keyframes rfFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .fade-exit {
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    .fade-exit-active {
      opacity: 0;
      transform: translateY(8px);
    }
    /* Empty State Placeholders */
    .ats-placeholder-note {
      text-align: center;
      color: var(--color-text-muted);
      font-style: italic;
      margin-top: var(--space-sm);
      font-size: var(--font-size-base);
    }
    /* Standardized Role Input Styling (matching Interview Questions) */
    .rf-role-input {
      width: 100%;
      padding: 0.85rem 1.1rem;
      border: 2px solid #E5E7EB;
      border-radius: 10px;
      font-size: 1.08rem;
      margin-bottom: 0;
      transition: border 0.18s;
      background: #fff;
      color: #232B36;
      box-sizing: border-box;
    }
    .rf-role-input:focus {
      border-color: #1976D2;
      outline: none;
    }
    .rf-role-dropdown {
      position: absolute;
      left: 0;
      right: 0;
      background: #fff;
      border: 1.5px solid #E5E7EB;
      border-top: none;
      border-radius: 0 0 10px 10px;
      box-shadow: 0 2px 8px rgba(31,41,55,0.07);
      z-index: 10;
      max-height: 220px;
      overflow-y: auto;
      margin-top: -2px;
    }
    .rf-role-item {
      padding: 0.85rem 1.1rem;
      cursor: pointer;
      font-size: 1.08rem;
      color: #232B36;
      transition: background 0.15s;
    }
    .rf-role-item:hover,
    .rf-role-item.active {
      background: #F3F4F6;
    }
    /* Fit Level Chips for Role-Specific Tailoring Tips */
    .rf-fit-chip-big-impact {
      background: #FEF3C7;
      color: #92400E;
      border: 1px solid #F59E0B;
    }
    .rf-fit-chip-tunable {
      background: #DBEAFE;
      color: #1E40AF;
      border: 1px solid #3B82F6;
    }
    .rf-fit-chip-strong {
      background: #D1FAE5;
      color: #065F46;
      border: 1px solid #10B981;
    }
    /* Change Summary Styles for Rewrite UI */
    .rf-change-summary {
      margin-top: 1.5rem;
      padding: 1.2rem;
      background: #F9FAFB;
      border-radius: var(--radius-lg);
      border: 1px solid var(--color-divider);
    }
    .rf-change-summary h4 {
      font-size: 1rem;
      font-weight: 700;
      color: var(--color-text-main);
      margin: 0 0 0.75rem 0;
    }
    .rf-change-summary ul {
      margin: 0;
      padding-left: 1.25rem;
      color: var(--color-text-secondary);
    }
    .rf-change-summary li {
      margin-bottom: 0.5rem;
      line-height: 1.5;
    }
    .rf-change-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
    }
    .rf-rewrite-desc-inline {
      color: var(--color-text-secondary);
      margin: 0 0 1rem 0;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="site-header">
    <div class="container">
      <a href="index.html" class="nav-logo" aria-label="Go to homepage">
        <svg width="24" height="24" fill="none" stroke="#1F2937" stroke-width="2" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="7" width="18" height="13" rx="2"/>
          <path d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2"/>
        </svg>
        <span>JOBHACKAI</span>
      </a>
      <div class="nav-group">
        <nav class="nav-links" role="navigation">
          <!-- Navigation will be dynamically populated by navigation.js -->
        </nav>
      </div>
      <button class="mobile-toggle" aria-label="Open navigation menu" aria-expanded="false" aria-controls="mobileNav">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
    </div>
  </header>
  
  <nav class="mobile-nav" id="mobileNav">
    <!-- Mobile navigation will be dynamically populated by navigation.js -->
  </nav>
  <div class="mobile-nav-backdrop" id="mobileNavBackdrop"></div>
  
  <!-- Centralized mobile menu handler -->
  <script src="js/mobile-menu.js?v=20250115-1"></script>
  
  <!-- Load Firebase auth as ES module (same pattern as dashboard.html) -->
  <script type="module" src="js/firebase-auth.js?v=20260124-1"></script>
  
  <!-- DEV-ONLY PLAN TOGGLE will be added by navigation.js -->
  <script src="js/navigation.js?v=20251007-2"></script>
  <script src="js/universal-logout.js?v=20251007-2"></script>
  <!-- Inactivity tracker - auto-logout after 30 minutes of inactivity -->
  <script src="js/inactivity-tracker.js?v=20250115-1"></script>
  
  <!-- UX Enhancement Components -->
  <script src="js/modals.js?v=20250115-1" type="module"></script>
  <script src="js/loading-overlay.js?v=20250115-1" type="module"></script>
  <script src="js/toast.js?v=20250115-1"></script>
  <script src="js/file-validation.js?v=20250115-1"></script>
  <script src="js/role-selector.js?v=20250115-1" type="module"></script>
  <script src="js/api-retry.js?v=20250115-1"></script>
  <script src="js/state-persistence.js?v=20250115-1"></script>
  <script src="js/free-account-manager.js?v=20250115-1"></script>
  <script src="js/stripe-integration.js"></script>
  <script>
    if (window.JobHackAINavigation && typeof window.JobHackAINavigation.initializeNavigation === 'function') {
      window.JobHackAINavigation.initializeNavigation();
    } else {
      window.addEventListener('DOMContentLoaded', function() {
        if (window.JobHackAINavigation && typeof window.JobHackAINavigation.initializeNavigation === 'function') {
          window.JobHackAINavigation.initializeNavigation();
        }
      });
    }
  </script>
  <script>
    // --- PAGE ACCESS CONTROL (Second check after navigation system) ---
    // Also run after navigation system initializes to double-check
    async function enforceAccess() {
      // TRI-STATE FIX: Wait for Firebase auth to be ready before redirecting
      let isAuthenticated, plan;
      
      // Wait for Firebase auth to be ready if FirebaseAuthManager exists
      if (window.FirebaseAuthManager && typeof window.FirebaseAuthManager.waitForAuthReady === 'function') {
        try {
          console.log('[RESUME-FEEDBACK] Waiting for Firebase auth to be ready before enforceAccess check...');
          const user = await window.FirebaseAuthManager.waitForAuthReady(8000);
          
          // Prefer Firebase user result over navigation state (navigation may not have synced yet)
          if (window.JobHackAINavigation) {
            const authState = window.JobHackAINavigation.getAuthState();
            isAuthenticated = user || (authState && authState.isAuthenticated);
            plan = window.JobHackAINavigation.getEffectivePlan();
          } else {
            isAuthenticated = !!user;
            plan = localStorage.getItem('user-plan') || 'free';
          }
        } catch (error) {
          console.warn('[RESUME-FEEDBACK] waitForAuthReady error in enforceAccess, using fallback:', error);
          // Fallback to navigation/localStorage check
          if (window.JobHackAINavigation) {
            const authState = window.JobHackAINavigation.getAuthState();
            isAuthenticated = authState && authState.isAuthenticated;
            plan = window.JobHackAINavigation.getEffectivePlan();
          } else {
            // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
            function hasFirebaseAuthKeys() {
              try {
                return Object.keys(localStorage).some(k => 
                  k.startsWith('firebase:authUser:') && 
                  localStorage.getItem(k) && 
                  localStorage.getItem(k) !== 'null' &&
                  localStorage.getItem(k).length > 10
                );
              } catch (e) {
                return false;
              }
            }
            const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
            const hasFirebaseKeys = hasFirebaseAuthKeys();
            isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
            plan = localStorage.getItem('user-plan') || 'free';
          }
        }
      } else {
        // No FirebaseAuthManager - use navigation/localStorage fallback
        if (window.JobHackAINavigation) {
          const authState = window.JobHackAINavigation.getAuthState();
          isAuthenticated = authState.isAuthenticated;
          plan = window.JobHackAINavigation.getEffectivePlan();
        } else {
          // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
          function hasFirebaseAuthKeys() {
            try {
              return Object.keys(localStorage).some(k => 
                k.startsWith('firebase:authUser:') && 
                localStorage.getItem(k) && 
                localStorage.getItem(k) !== 'null' &&
                localStorage.getItem(k).length > 10
              );
            } catch (e) {
              return false;
            }
          }
          const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
          const hasFirebaseKeys = hasFirebaseAuthKeys();
          isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
          plan = localStorage.getItem('user-plan') || 'free';
        }
      }
      
      // FIX: Enhanced logging for plan detection debugging
      console.log('[RESUME-FEEDBACK] Plan detection debug:', {
        isAuthenticated,
        plan,
        navigationPlan: window.JobHackAINavigation?.getEffectivePlan?.(),
        localStoragePlan: localStorage.getItem('user-plan'),
        devPlan: localStorage.getItem('dev-plan'),
        authState: window.JobHackAINavigation?.getAuthState?.()
      });
      
      const allowedPlans = ['trial', 'essential', 'pro', 'premium'];
      
      if (!isAuthenticated || !allowedPlans.includes(plan)) {
        if (!isAuthenticated) {
          window.location.href = 'login.html';
        } else {
          window.location.href = 'pricing-a.html?plan=essential';
        }
      }
    }
    
    // Wait for DOM to be ready before enforcing access again
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', async () => {
        await enforceAccess();
      });
    } else {
      setTimeout(async () => {
        await enforceAccess();
      }, 100); // Small delay to allow navigation system to initialize
    }
  </script>
  <script>
    // --- AUTHENTICATION CHECK ---
    function checkAuthentication() {
      // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
      // FirebaseAuthManager.getCurrentUser() returns null until onAuthStateChanged fires
      function hasFirebaseAuthKeys() {
        try {
          return Object.keys(localStorage).some(k => 
            k.startsWith('firebase:authUser:') && 
            localStorage.getItem(k) && 
            localStorage.getItem(k) !== 'null' &&
            localStorage.getItem(k).length > 10
          );
        } catch (e) {
          return false;
        }
      }
      const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
      const hasFirebaseKeys = hasFirebaseAuthKeys();
      const isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
      const mainContent = document.querySelector('main');
      
      if (!isAuthenticated) {
        mainContent.innerHTML = `
          <div style="max-width: 600px; margin: 4rem auto; text-align: center; padding: 2rem;">
            <div style="font-size: 4rem; margin-bottom: 1rem;">ðŸ”’</div>
            <h1 style="font-size: 2rem; font-weight: 700; color: var(--color-text-main); margin-bottom: 1rem;">
              Login Required
            </h1>
            <p style="font-size: 1.1rem; color: var(--color-text-secondary); margin-bottom: 2rem; line-height: 1.6;">
              Resume Feedback Pro requires you to be logged in to access this tool. 
              Please sign in to get started.
            </p>
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
              <a href="login.html" class="btn-primary" style="text-decoration: none;">
                Sign In
              </a>
              <a href="pricing-a.html" class="btn-outline" style="text-decoration: none;">
                View Pricing
              </a>
            </div>
          </div>
        `;
        return false;
      }
      return true;
    }

    function resetRewriteUIToDefaults() {
      // Ensure any inline rewrite loader is cleared when resetting UI
      hideRewriteSkeleton();
      const rewriteContent = document.getElementById('rf-rewrite-content');
      const rewriteTextareas = rewriteContent ? rewriteContent.querySelectorAll('.rf-snippet-box') : [];
      const rewriteDescInline = document.getElementById('rf-rewrite-desc-inline');
      if (rewriteTextareas && rewriteTextareas.length >= 2) {
        rewriteTextareas[0].value = 'Original resume excerpt will appear here after upload.';
        rewriteTextareas[1].value = 'AI-optimized resume excerpt.';
      }
      const changeSummary = document.getElementById('rf-change-summary');
      if (changeSummary) {
        changeSummary.innerHTML = '';
        changeSummary.style.display = 'none';
      }
      if (rewriteDescInline) {
        rewriteDescInline.style.display = 'none';
      }
      setCopyRewriteVisibility(false);
    }

    function resetAtsAndRoleUIToDefaults() {
      const rubricGrid = document.getElementById('rf-rubric-grid');
      if (rubricGrid) {
        rubricGrid.innerHTML = '';
        rubricGrid.style.display = 'none';
      }
      const feedbackGrid = document.getElementById('rf-feedback-grid');
      if (feedbackGrid) {
        feedbackGrid.innerHTML = '';
        feedbackGrid.style.display = 'none';
      }
    }

    function resetRewriteCooldownState() {
      // Clear countdown interval
      if (window._rewriteCountdownInterval) {
        clearInterval(window._rewriteCountdownInterval);
        window._rewriteCountdownInterval = null;
      }
      // Clear usage-interval
      if (window._rewriteCooldownInterval) {
        clearInterval(window._rewriteCooldownInterval);
        window._rewriteCooldownInterval = null;
      }
      // Reset button label/state
      const regenBtn = document.querySelector('#rf-rewrite-content #rf-generate');
      if (regenBtn) {
        regenBtn.disabled = false;
        const defaultLabel = 'Generate Rewrite';
        const originalLabel = regenBtn.dataset.originalLabel || defaultLabel;
        regenBtn.textContent = originalLabel;
        regenBtn.dataset.originalLabel = defaultLabel;
      }
    }

    // --- PLAN-BASED ACCESS CONTROL ---
    function checkPlanAccess() {
      const currentPlan = window.JobHackAINavigation ? window.JobHackAINavigation.getEffectivePlan() : 'free';
      const lockedDiv = document.getElementById('rfp-locked');
      const formDiv = document.getElementById('rfp-form');
      const resultsDiv = document.getElementById('rfp-results');
      
      if (!lockedDiv || !formDiv || !resultsDiv) return;
      
      // Resume Feedback Pro is available for Trial, Essential, Pro, and Premium
      const locked = (currentPlan === 'free');
      lockedDiv.style.display = locked ? 'flex' : 'none';
      formDiv.style.display = locked ? 'none' : '';
      resultsDiv.style.display = 'none';
      
      // Phase 4.3: Show locked feature data notice when feature is locked
      const lockedDataNotice = document.getElementById('rf-locked-data-notice');
      if (lockedDataNotice) {
        lockedDataNotice.style.display = locked ? 'block' : 'none';
      }
    }

    // --- Initialize on load ---
    document.addEventListener('DOMContentLoaded', function() {
      // Check authentication first
      if (!checkAuthentication()) {
        return; // Stop here if not authenticated
      }
      
      // Create demo user if needed for development
      // SECURITY: Do NOT write email to localStorage - get it from Firebase SDK keys instead
      const createDemoUserIfNeeded = () => {
        // Try to get email from Firebase SDK keys (works before firebase-auth.js loads)
        function getEmailFromFirebaseKeys() {
          try {
            const firebaseKeys = Object.keys(localStorage).filter(k => k.startsWith('firebase:authUser:'));
            if (firebaseKeys.length > 0) {
              const keyData = JSON.parse(localStorage.getItem(firebaseKeys[0]) || '{}');
              return keyData.email || null;
            }
          } catch (e) {
            console.warn('Failed to get email from Firebase keys:', e);
          }
          return null;
        }
        
        // Try FirebaseAuthManager first (if loaded)
        const user = window.FirebaseAuthManager?.getCurrentUser?.();
        let userEmail = user?.email || null;
        
        // Fallback to Firebase SDK keys if FirebaseAuthManager not available
        if (!userEmail) {
          userEmail = getEmailFromFirebaseKeys();
        }
        
        // SECURITY: If no email found, skip demo user creation - do NOT write email to localStorage
        // This prevents reintroducing the security vulnerability
        if (!userEmail && localStorage.getItem('user-authenticated') === 'true') {
          console.warn('[RESUME-FEEDBACK] User authenticated but no email found. Skipping demo user creation to maintain security.');
          return;
        }
        
        // Only create demo user if we have a valid email from Firebase
        if (userEmail) {
          const db = JSON.parse(localStorage.getItem('user-db') || '{}');
          if (!db[userEmail]) {
            db[userEmail] = {
              plan: 'free',
              firstName: 'Demo',
              lastName: 'User',
              cards: [],
              created: new Date().toISOString()
            };
            localStorage.setItem('user-db', JSON.stringify(db));
          }
        }
      };
      
      createDemoUserIfNeeded();

      // Wait for navigation system to initialize and sync plan
      // Navigation system handles all plan syncing - we just listen to events
      waitForNavigationAndEnforceAccess();
    });

    // --- ACCESS CONTROL (Uses Navigation System) ---
    function waitForNavigationAndEnforceAccess() {
      const allowedPlans = window.__JOBHACKAI_RF_ALLOWED_PLANS__ || ['trial', 'essential', 'pro', 'premium'];
      
      // Wait for navigation system to be ready
      if (window.JobHackAINavigation && typeof window.JobHackAINavigation.getEffectivePlan === 'function') {
        // Navigation is ready - check access immediately
        (async () => {
          await enforceAccessControl(allowedPlans);
        })();
      } else {
        // Navigation not ready yet - wait for navigationReady event
        // Use execution flag to prevent duplicate calls from event listener and timeout
        let hasExecuted = false;
        let fallbackTimeout = setTimeout(async () => {
          // Always enforce access control after timeout, even if navigation fails to load
          // enforceAccessControl has localStorage fallback logic that handles navigation unavailability
          if (!hasExecuted) {
            hasExecuted = true;
            await enforceAccessControl(allowedPlans);
          }
        }, 1000);
        
        window.addEventListener('navigationReady', async function onNavigationReady() {
          window.removeEventListener('navigationReady', onNavigationReady);
          // Clear fallback timeout to prevent duplicate execution
          if (fallbackTimeout) {
            clearTimeout(fallbackTimeout);
            fallbackTimeout = null;
          }
          // Only execute if not already executed by timeout
          if (!hasExecuted) {
            hasExecuted = true;
            await enforceAccessControl(allowedPlans);
          }
        }, { once: true });
      }
    }
    
    async function enforceAccessControl(allowedPlans) {
      // TRI-STATE FIX: Wait for Firebase auth to be ready before redirecting
      // This prevents race conditions where Firebase is still initializing
      let isAuthenticated, plan;
      
      // Wait for Firebase auth to be ready if FirebaseAuthManager exists
      if (window.FirebaseAuthManager && typeof window.FirebaseAuthManager.waitForAuthReady === 'function') {
        try {
          console.log('[RESUME-FEEDBACK] Waiting for Firebase auth to be ready before access control check...');
          const user = await window.FirebaseAuthManager.waitForAuthReady(8000);
          
          // Prefer Firebase user result over navigation state (navigation may not have synced yet)
          if (window.JobHackAINavigation) {
            const authState = window.JobHackAINavigation.getAuthState();
            isAuthenticated = user || (authState && authState.isAuthenticated);
            plan = window.JobHackAINavigation.getEffectivePlan();
          } else {
            isAuthenticated = !!user;
            plan = localStorage.getItem('user-plan') || 'free';
          }
        } catch (error) {
          console.warn('[RESUME-FEEDBACK] waitForAuthReady error, using fallback check:', error);
          // Fallback to navigation/localStorage check
          if (window.JobHackAINavigation) {
            const authState = window.JobHackAINavigation.getAuthState();
            isAuthenticated = authState && authState.isAuthenticated;
            plan = window.JobHackAINavigation.getEffectivePlan();
          } else {
            // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
            function hasFirebaseAuthKeys() {
              try {
                return Object.keys(localStorage).some(k => 
                  k.startsWith('firebase:authUser:') && 
                  localStorage.getItem(k) && 
                  localStorage.getItem(k) !== 'null' &&
                  localStorage.getItem(k).length > 10
                );
              } catch (e) {
                return false;
              }
            }
            const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
            const hasFirebaseKeys = hasFirebaseAuthKeys();
            isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
            plan = localStorage.getItem('user-plan') || 'free';
          }
        }
      } else {
        // No FirebaseAuthManager - use navigation/localStorage fallback
        if (window.JobHackAINavigation) {
          const authState = window.JobHackAINavigation.getAuthState();
          isAuthenticated = authState.isAuthenticated;
          plan = window.JobHackAINavigation.getEffectivePlan();
        } else {
          // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
          function hasFirebaseAuthKeys() {
            try {
              return Object.keys(localStorage).some(k => 
                k.startsWith('firebase:authUser:') && 
                localStorage.getItem(k) && 
                localStorage.getItem(k) !== 'null' &&
                localStorage.getItem(k).length > 10
              );
            } catch (e) {
              return false;
            }
          }
          const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
          const hasFirebaseKeys = hasFirebaseAuthKeys();
          isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
          plan = localStorage.getItem('user-plan') || 'free';
        }
      }
      
      console.log('[RESUME-FEEDBACK] Access control check:', {
        isAuthenticated,
        plan,
        navigationPlan: window.JobHackAINavigation?.getEffectivePlan?.(),
        localStoragePlan: localStorage.getItem('user-plan')
      });
      
      if (!isAuthenticated || !allowedPlans.includes(plan)) {
        if (!isAuthenticated) {
          window.location.href = 'login.html';
        } else {
          window.location.href = 'pricing-a.html?plan=essential';
        }
      } else {
        // Access granted - clear plan pending flag and class
        // This allows tests to detect when plan hydration is complete
        window.__JOBHACKAI_PLAN_PENDING__ = false;
        document.documentElement.classList.remove('plan-pending');
        // Ensure UI is updated
        updateRfTileForPlan();
      }
    }

    // --- UPDATED USER PLAN LOGIC ---
    function getCurrentUserPlan() {
      // Use navigation system's plan detection for consistency
      let plan = 'free';
      if (window.JobHackAINavigation && typeof window.JobHackAINavigation.getEffectivePlan === 'function') {
        plan = window.JobHackAINavigation.getEffectivePlan();
        // If navigation returns undefined or invalid, fall back to localStorage
        if (!plan || plan === 'undefined') {
          plan = localStorage.getItem('user-plan') || 'free';
        }
      } else {
        plan = localStorage.getItem('user-plan') || 'free';
      }
      
      // FIX: Validate plan value to prevent corrupted data (e.g., "central")
      const validPlans = ['visitor', 'free', 'trial', 'essential', 'pro', 'premium'];
      if (!validPlans.includes(plan)) {
        const oldPlan = plan; // Capture original invalid plan before reassignment
        console.warn('[RESUME-FEEDBACK] Invalid plan detected:', plan, '- resetting to free');
        plan = 'free';
        // Clean up corrupted plan values
        localStorage.setItem('user-plan', 'free');
        const devPlan = localStorage.getItem('dev-plan');
        if (devPlan && !validPlans.includes(devPlan)) {
          localStorage.setItem('dev-plan', 'free');
        }
        // Log for debugging
        console.log('[RESUME-FEEDBACK] Plan cleanup completed:', {
          oldPlan: oldPlan,
          newPlan: 'free',
          localStoragePlan: localStorage.getItem('user-plan'),
          devPlan: localStorage.getItem('dev-plan')
        });
      }
      
      return plan;
    }

    // --- UPDATED USER OBJECT ---
    let user = {
      get plan() {
        return getCurrentUserPlan();
      },
      atsChecksUsed: 0,
      lastAtsCheckTime: null
    };

    // --- GLOBAL STATE ---
    let currentResumeId = null;
    let currentJobTitle = null;
    const runAuthority = window.JobHackAIRunAuthority;
    const runAuthorityDebug = Boolean(window.JobHackAIDebug?.runAuthority || window.__JOBHACKAI_RUN_AUTHORITY_DEBUG__);
    const tryApplyScore = runAuthority?.tryApplyScore?.bind(runAuthority);
    const clearRunAuthority = runAuthority?.clearAuthority?.bind(runAuthority);
    let lastNormalizedRoleValue = '';

    // --- API CLIENT FUNCTIONS ---
    async function getAuthToken() {
      // Wait for Firebase auth to be ready
      if (window.FirebaseAuthManager && window.FirebaseAuthManager.waitForAuthReady) {
        await window.FirebaseAuthManager.waitForAuthReady(3000);
      }
      
      // Get Firebase ID token using FirebaseAuthManager
      if (window.FirebaseAuthManager && window.FirebaseAuthManager.getCurrentUser) {
        const user = window.FirebaseAuthManager.getCurrentUser();
        if (user) {
          return await user.getIdToken();
        }
      }
      
      // Fallback: try to get from localStorage
      const firebaseKeys = Object.keys(localStorage).filter(k => k.startsWith('firebase:authUser:'));
      if (firebaseKeys.length > 0) {
        const authData = JSON.parse(localStorage.getItem(firebaseKeys[0]) || '{}');
        if (authData.stsTokenManager?.accessToken) {
          return authData.stsTokenManager.accessToken;
        }
      }
      
      throw new Error('Not authenticated. Please log in.');
    }

    // --- SHARED STATE MANAGEMENT HELPERS ---
    function clearAtsState() {
      // Clear old localStorage keys (to avoid stale state)
      localStorage.removeItem('lastATSScore');
      localStorage.removeItem('lastATSSummary');
      localStorage.removeItem('lastUploadedResume');
      localStorage.removeItem('lastUploadedResumeName');
      
      // Clear shared cross-page state
      sessionStorage.removeItem('currentResumeId');
      sessionStorage.removeItem('currentResumeText');
      sessionStorage.removeItem('currentAtsScore');
      sessionStorage.removeItem('currentAtsBreakdown');
    }

    // Status icon definitions - defined once, reused
    // Canonical ATS rubric max values - single source of truth for denominators
    const ATS_RUBRIC_MAX = {
      KEYWORD_RELEVANCE: 40,
      FORMATTING_COMPLIANCE: 20,
      STRUCTURE_COMPLETENESS: 15,
      TONE_CLARITY: 15,
      GRAMMAR_SPELLING: 10
    };

    const RF_STATUS_ICONS = {
      success: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"/>
      <polyline points="9 12 12 15 22 5"/>
    </svg>`,
      warning: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
      <line x1="12" y1="9" x2="12" y2="13"/>
      <line x1="12" y1="17" x2="12.01" y2="17"/>
    </svg>`,
      error: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"/>
      <line x1="12" y1="8" x2="12" y2="12"/>
      <line x1="12" y1="16" x2="12.01" y2="16"/>
    </svg>`
    };

    function getStatusIcon(type) {
      return RF_STATUS_ICONS[type] || '';
    }

    // Helper function to show file status pill
    function showFileStatus(variant, message) {
      const statusPill = document.getElementById('rf-file-status');
      const statusIcon = statusPill?.querySelector('.rf-status-icon');
      const statusText = statusPill?.querySelector('.rf-status-text');
      
      if (!statusPill || !statusIcon || !statusText) return;
      
      statusPill.className = `rf-status-pill rf-status-pill--${variant}`;
      statusIcon.innerHTML = getStatusIcon(variant);
      statusText.textContent = message;
      statusPill.style.display = 'inline-flex';
    }

    function hideFileStatus() {
      const statusPill = document.getElementById('rf-file-status');
      if (statusPill) {
        statusPill.style.display = 'none';
      }
    }

    async function uploadResume(file) {
      // Validate file before upload
      const validation = await window.JobHackAIFileValidation.validateFile(file);
      if (!validation.valid) {
        throw new Error(validation.error);
      }
      
      // Handle warnings (e.g., scanned PDF detection)
      // NOTE: Removed popup modal - users see inline helper text instead
      // Validation still runs, but no blocking modal is shown
      if (validation.warning) {
        console.log('[RESUME-FEEDBACK] File validation warning:', validation.warningMessage);
        // Inline helper text will inform users about PDF processing time
      }

      // Show progress indicator for text extraction (Step 1: Reading resume)
      const hideLoading = window.showLoadingOverlay 
        ? window.showLoadingOverlay(window.LoadingMessages?.READING_RESUME || 'Reading your resume...')
        : null;

      try {
        const token = await getAuthToken();
        const formData = new FormData();
        formData.append('file', file);

        // Use retry logic for upload
        const response = await window.JobHackAIRetry.fetchWithRetry('/api/resume-upload', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          },
          body: formData
        }, {
          maxRetries: 3,
          initialDelay: 1000
        });

        // Handle HTTP errors
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Upload failed');
        }

        const data = await response.json();
      
        // Handle extraction failures (success: false but HTTP 200)
        if (!data.success) {
          clearAtsState();
          
          // Map structured error codes to user-friendly messages
          const errorCode = data.errorCode || data.error;
          let errorMessage = data.message || 'Resume text could not be extracted.';
          
          // Handle specific error codes with tailored messages
          if (errorCode === 'ocr_required' || errorCode === 'OCR_REQUIRED') {
            // Scanned PDF detected - show helpful, actionable message
            errorMessage = 'This PDF appears to be image-based (scanned). Please upload a text-based PDF or Word document for best results. We\'re working on scan support for a future update.';
          } else if (errorCode === 'unreadable_scan' || errorCode === 'UNREADABLE_SCAN') {
            errorMessage = 'This scanned PDF is not readable. Please upload a higher-quality file or use our DOCX template.';
          } else if (errorCode === 'empty_text' || errorCode === 'EMPTY_TEXT') {
            errorMessage = 'Could not extract readable text from file. Please upload a text-based rÃ©sumÃ© or use our DOCX template.';
          } else if (errorCode === 'unsupported_file_type' || errorCode === 'UNSUPPORTED_TYPE') {
            errorMessage = `Unsupported file type. Please upload PDF, DOCX, or TXT.`;
          } else if (errorCode === 'file_too_large' || errorCode === 'FILE_TOO_LARGE') {
            errorMessage = 'File exceeds 2MB limit. Please compress or use a smaller file.';
          } else if (errorCode === 'text_too_long' || errorCode === 'TEXT_TOO_LONG') {
            errorMessage = 'Extracted text exceeds limit. Please use a shorter rÃ©sumÃ©.';
          } else if (errorCode === 'extraction_failed' || errorCode === 'invalid-text') {
            errorMessage = 'We couldn\'t read your resume. Please upload a text-based PDF, DOCX, or TXT file.';
          }
          
          // Preserve error code in Error object so catch block can check error.code
          const error = new Error(errorMessage);
          error.code = errorCode;
          throw error;
        }

        currentResumeId = data.resumeId;
        
        // Store in sessionStorage and localStorage for cross-page sync
        sessionStorage.setItem('currentResumeId', data.resumeId);
        if (data.resumeText) {
          sessionStorage.setItem('currentResumeText', data.resumeText);
        }
        
        // Persist resume data
        if (window.JobHackAIStatePersistence) {
          window.JobHackAIStatePersistence.saveResumeData({
            resumeId: data.resumeId,
            resumeText: data.resumeText,
            isMultiColumn: data.isMultiColumn
          });
        }
        
        // Hide loading overlay on success (only after confirming data.success)
        if (hideLoading) {
          hideLoading();
        }
        
        return data;
      } catch (error) {
        // Hide loading overlay on error
        if (hideLoading) {
          hideLoading();
        }
        
        // Show error status pill based on error code/message
        const message = (error && error.message) || '';
        const code = error && error.code;
        
        if (code === 'ocr_required' || code === 'OCR_REQUIRED' || /scanned/i.test(message)) {
          showFileStatus('error', 'Scanned PDF cannot be processed');
        } else if (code === 'parse_error' || code === 'PARSE_ERROR' || /could not be processed|corrupted|password|encrypted/i.test(message)) {
          showFileStatus('error', 'PDF could not be processed');
        } else if (code === 'unsupported_file_type' || code === 'UNSUPPORTED_TYPE' || /unsupported|file type/i.test(message)) {
          showFileStatus('error', 'File type not supported');
        } else if (code === 'file_too_large' || code === 'FILE_TOO_LARGE' || /too large|2MB/i.test(message)) {
          showFileStatus('error', 'File too large (max 2MB)');
        } else if (code === 'empty_text' || code === 'EMPTY_TEXT' || /empty/i.test(message)) {
          showFileStatus('error', 'File appears to be empty');
        } else if (code === 'text_too_long' || code === 'TEXT_TOO_LONG' || /text.*too long|exceeds.*limit/i.test(message)) {
          showFileStatus('error', 'Text too long');
        } else {
          showFileStatus('error', 'File upload failed');
        }
        
        // Re-throw to be handled by caller
        throw error;
      }
    }

    async function getAtsScore(resumeId, jobTitle) {
      const token = await getAuthToken();
      
      // Try to get resumeText from sessionStorage (fallback when KV unavailable)
      // Use nullish coalescing to only convert null to undefined, preserving empty strings
      const resumeText = sessionStorage.getItem('currentResumeText') ?? undefined;
      
      // Use retry logic for API call
      const response = await window.JobHackAIRetry.fetchWithRetry('/api/ats-score', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          resumeId, 
          jobTitle,
          resumeText // Pass text directly to bypass KV requirement
        })
      }, {
        maxRetries: 3,
        initialDelay: 1000
      });

      if (!response.ok) {
        const error = await response.json();
        // Map error codes to user-friendly messages
        let errorMessage = error.error || 'Failed to get ATS score';
        if (error.error === 'invalid-text') {
          errorMessage = 'We couldn\'t read your resume. Please upload a text-based PDF, DOCX, or TXT file.';
        } else if (error.error === 'Usage limit reached') {
          errorMessage = error.message || 'You have used your free ATS score. Upgrade to unlock more features.';
        } else if (error.error === 'Rate limit exceeded') {
          errorMessage = error.message || 'Please wait before running another ATS score.';
        }
        throw new Error(errorMessage);
      }

      const result = await response.json();
      
      // Persist score to localStorage
      if (result.success && window.JobHackAIStatePersistence) {
        window.JobHackAIStatePersistence.saveATSScore({
          score: result.score,
          breakdown: result.breakdown,
          resumeId,
          jobTitle,
          extractionQuality: result.extractionQuality
        });
      }
      
      return result;
    }

    async function getResumeFeedback(resumeId, jobTitle) {
      // Validate resumeId before making API call
      if (!resumeId || resumeId === null || resumeId === undefined) {
        throw new Error('Resume ID is required. Please upload a resume first.');
      }
      
      const token = await getAuthToken();
      
      // PHASE 1: Remove resumeText from request body (backend loads from KV/D1)
      // Keep backward compatibility: if resumeText is needed for dev/fallback, backend will request it
      const requestBody = { resumeId, jobTitle };
      // PHASE 1: Do not send resumeText by default (reduces payload size)
      // Backend will load from KV/D1 server-side
      
      // Use retry logic for API call
      const response = await window.JobHackAIRetry.fetchWithRetry('/api/resume-feedback', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      }, {
        maxRetries: 3,
        initialDelay: 1000,
        shouldRetry: (error) => {
          if (error?.status === 429) {
            return false;
          }
          if (error instanceof TypeError && error.message.includes('fetch')) {
            return true;
          }
          if (typeof error?.status === 'number') {
            if (error.status >= 500) {
              return true;
            }
            if (error.status === 408) {
              return true;
            }
          }
          return false;
        }
      });

      if (!response.ok) {
        const error = await response.json();
        // Map error codes to user-friendly messages
        let errorMessage = error.error || 'Failed to get feedback';
        if (error.error === 'Feature locked') {
          errorMessage = 'This feature is available on the Pro plan. Upgrade to unlock full feedback.';
        } else if (error.error === 'Unauthorized') {
          errorMessage = 'Please log in to continue.';
        } else if (response.status === 403) {
          errorMessage = error.message || 'Access denied. Please check your plan or try logging in again.';
        }
        console.error('[RESUME-FEEDBACK] API error:', {
          status: response.status,
          error: error.error,
          message: error.message,
          upgradeRequired: error.upgradeRequired
        });
        const errorObj = new Error(errorMessage);
        // Preserve status + API error fields for upstream arbitration (e.g., wait-for-ATS retries)
        errorObj.status = response.status;
        errorObj.apiError = error.error;
        errorObj.apiMessage = error.message;
        // Preserve upgradeRequired flag for error handler
        if (error.upgradeRequired) {
          errorObj.upgradeRequired = true;
        }
        throw errorObj;
      }

      return await response.json();
    }

    // Feedback depends on ATS being persisted; when backend reports "wait for ATS",
    // retry after ATS settles to avoid forcing the user to manually retry.
    function _rfSleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    function _rfIsWaitForAtsError(err) {
      const msg = (err && err.message) ? String(err.message) : '';
      const apiErr = (err && err.apiError) ? String(err.apiError) : '';
      return err?.status === 409 ||
        apiErr.toLowerCase().includes('wait') ||
        /wait\s+for\s+your\s+ats\s+score/i.test(msg);
    }

    async function getResumeFeedbackWithAtsWait(resumeId, jobTitle, atsPromise) {
      // If ATS promise is provided, await it BEFORE the first feedback call to prevent 409 race
      if (atsPromise && typeof atsPromise.then === 'function') {
        try {
          await atsPromise;
        } catch (_) {
          // ATS failure handled elsewhere - still attempt feedback (may have cached ATS)
        }
      }
      
      try {
        return await getResumeFeedback(resumeId, jobTitle);
      } catch (err) {
        if (!_rfIsWaitForAtsError(err)) throw err;
        // Residual 409 after ATS wait (D1 lag) - retry once with brief backoff
          await _rfSleep(900);
        return await getResumeFeedback(resumeId, jobTitle);
      }
    }

    // Global storage for latest feedback results to use in rewrite
    window.latestAtsIssues = null;
    window.latestRoleSpecific = null;
    // Token associated with the latestRoleSpecific value. Scoped to a feedback run token when applicable.
    window.latestRoleSpecificToken = null;

    // ROLE TIPS SKELETON FIX: Explicit in-flight tracking for role-tips requests
    // Tracks actual HTTP request state independent of cached status or history
    window.roleTipsInFlight = false;
    window.roleTipsInFlightToken = null;

    // PHASE 2: Role tips state management (idle | generating | ready | failed)
    const ROLE_TIPS_STATUS_KEY = 'rf_role_tips_status';
    const ROLE_TIPS_TIMEOUT_MS = 50000; // 50 seconds (exceeds backend worst-case ~42s: 2Ã—20s attempts + 2s backoff, with 8s safety buffer)

    function setRoleTipsStatus(token, status) {
      if (!token) return;
      try {
        const statusData = {
          token,
          status,
          timestamp: Date.now()
        };
        sessionStorage.setItem(ROLE_TIPS_STATUS_KEY, JSON.stringify(statusData));
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to persist role tips status', e);
      }
    }

    function getRoleTipsStatus() {
      try {
        const stored = sessionStorage.getItem(ROLE_TIPS_STATUS_KEY);
        if (!stored) return null;
        const statusData = JSON.parse(stored);
        // Check if status is stale (older than 60 seconds)
        if (Date.now() - statusData.timestamp > 60000) {
          sessionStorage.removeItem(ROLE_TIPS_STATUS_KEY);
          return null;
        }
        return statusData;
      } catch (e) {
        return null;
      }
    }

    function clearRoleTipsStatus() {
      try {
        sessionStorage.removeItem(ROLE_TIPS_STATUS_KEY);
      } catch (e) {
        // ignore
      }
    }

    function isRoleTipsGenerating() {
      const statusData = getRoleTipsStatus();
      if (!statusData) return false;
      // FIX: Prevent stale status from previous runs
      if (statusData.token && !isActiveFeedbackToken(statusData.token)) {
        return false;
      }
      return statusData.status === 'generating';
    }

    // PHASE 2: Fetch role tips from separate endpoint
    // D2: Accept sessionId parameter and pass to backend
    async function getRoleTips(resumeId, jobTitle, token, sessionId = null) {
      if (!resumeId || !jobTitle || !jobTitle.trim()) {
        // ROLE TIPS SKELETON FIX: Clear flags if early return (caller may have set them)
        if (window.roleTipsInFlightToken === token) {
          window.roleTipsInFlight = false;
          window.roleTipsInFlightToken = null;
        }
        return null;
      }

      // FIX: Status already set at run start - don't set again here
      // Only ensure status is 'generating' if somehow missing (defensive)
      const currentStatus = getRoleTipsStatus();
      if (!currentStatus || currentStatus.status !== 'generating' || currentStatus.token !== token) {
        setRoleTipsStatus(token, 'generating');
      }

      const controller = new AbortController();
      let timeoutId = null;

      try {
        const authToken = await getAuthToken();
        
        // Start timeout AFTER auth retrieval, immediately before fetch
        timeoutId = setTimeout(() => controller.abort(), ROLE_TIPS_TIMEOUT_MS);
        
        // D2: Include sessionId in request body for D1 persistence
        // PHASE 2: Optional resumeText for backward compatibility (backend will use KV/D1 if available)
        const resumeText = sessionStorage.getItem('currentResumeText') ?? undefined;
        const requestBody = { resumeId, jobTitle };
        if (sessionId) {
          requestBody.sessionId = sessionId; // D2: Pass sessionId for D1 persistence
        }
        if (resumeText) {
          requestBody.resumeText = resumeText; // Optional, for backward compatibility
        }

        const response = await fetch('/api/role-tips', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestBody),
          signal: controller.signal
        });

        if (timeoutId) clearTimeout(timeoutId);

        if (!response.ok) {
          const error = await response.json();
          const errorMessage = error.error || 'Failed to get role tips';
          
          // PHASE 2: Token-gate: only update status if token is still active
          if (isActiveFeedbackToken(token)) {
            setRoleTipsStatus(token, 'failed');
            const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
            if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Done (HTTP error)', { token: token.substring(0, 8) + '...', status: 'failed', httpStatus: response.status, error: errorMessage });
            // Show error UI
            const isTimeout = response.status === 504 || error.error === 'timeout';
            setRoleStatus(isTimeout 
              ? 'Role tips generation timed out. Try regenerating feedback.' 
              : 'Role tips generation failed. Try regenerating feedback.');
          }
          throw new Error(errorMessage);
        }

        const result = await response.json();
        
        // PHASE 2: Token-gate: only update if token is still active
        if (!isActiveFeedbackToken(token)) {
          console.warn('[RESUME-FEEDBACK] Stale role tips response ignored (token mismatch)');
          // Do NOT update status for stale tokens - would overwrite newer active run's status
          return null;
        }

        // Defensive: Check for error field even in 200 responses
        if (result.error) {
          setRoleTipsStatus(token, 'failed');
          const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
          if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Done (result error)', { token: token.substring(0, 8) + '...', status: 'failed', error: result.error });
          const isTimeout = result.error === 'timeout';
          setRoleStatus(isTimeout 
            ? 'Role tips generation timed out. Try regenerating feedback.' 
            : 'Role tips generation failed. Try regenerating feedback.');
          return null;
        }

        // Handle both response structures: result.roleSpecificFeedback OR result directly
        const roleSpecificFeedback = result.roleSpecificFeedback || result;
        
        // FIX: Preserve backward compatibility - validate based on format
        // Legacy array format: valid when Array.isArray(...) && length > 0
        // New object format: valid when Array.isArray(sections) && sections.length > 0
        // Empty object { sections: [] } is invalid
        const isLegacyArray = Array.isArray(roleSpecificFeedback);
        const hasNonEmptyContent = isLegacyArray
          ? roleSpecificFeedback.length > 0
          : (Array.isArray(roleSpecificFeedback?.sections) && roleSpecificFeedback.sections.length > 0);
        
        // Validate: must pass isValidRoleTips() check AND have non-empty content
        const isValid = isValidRoleTips(roleSpecificFeedback) && hasNonEmptyContent;
        const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
        
        if (isValid) {
          setRoleTipsStatus(token, 'ready');
          if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Done (ready)', { token: token.substring(0, 8) + '...', status: 'ready' });
          return roleSpecificFeedback;
        } else {
          setRoleTipsStatus(token, 'failed');
          if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Done (failed)', { token: token.substring(0, 8) + '...', status: 'failed', hasSections: !!roleSpecificFeedback?.sections, sectionCount: roleSpecificFeedback?.sections?.length || 0 });
          setRoleStatus('Role tips unavailable. Try regenerating feedback.');
          return null;
        }
      } catch (error) {
        if (timeoutId) clearTimeout(timeoutId);
        const isTimeout = error.name === 'AbortError' || error.message?.includes('timeout');
        console.error('[RESUME-FEEDBACK] Role tips fetch failed', {
          error: error.message,
          isTimeout,
          token
        });

        // PHASE 2: Token-gate: only update status if token is still active
        if (isActiveFeedbackToken(token)) {
          setRoleTipsStatus(token, 'failed');
          const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
          if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Done (error)', { token: token.substring(0, 8) + '...', status: 'failed', error: error.message, isTimeout });
          // Show error UI for fetch failures
          // Preserve backend-derived error message if it exists (from !response.ok block),
          // otherwise use generic network/request error message
          if (error.message && error.name !== 'AbortError') {
            setRoleStatus(error.message);
          } else {
            setRoleStatus(isTimeout 
              ? 'Role tips request timed out. Try regenerating feedback.' 
              : 'Role tips request failed. Try regenerating feedback.');
          }
        }
        return null;
      } finally {
        // ROLE TIPS SKELETON FIX: Clear in-flight flag when request resolves (success or error)
        if (window.roleTipsInFlightToken === token) {
          window.roleTipsInFlight = false;
          window.roleTipsInFlightToken = null;
        }
      }
    }

    async function rewriteResume(resumeId, section, jobTitle, atsIssues, roleSpecificFeedback) {
      const token = await getAuthToken();
      
      // Build request body with optional ATS context
      const requestBody = { resumeId, section, jobTitle };
      if (atsIssues && Array.isArray(atsIssues) && atsIssues.length > 0) {
        requestBody.atsIssues = atsIssues;
      }
      if (roleSpecificFeedback) {
        requestBody.roleSpecificFeedback = roleSpecificFeedback;
      }
      
      // Use retry logic for API call
      const response = await window.JobHackAIRetry.fetchWithRetry('/api/resume-rewrite', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      }, {
        maxRetries: 3,
        initialDelay: 1000
      });

      if (!response.ok) {
        const error = await response.json();
        // Map error codes to user-friendly messages
        let errorMessage = error.error || 'Failed to rewrite resume';
        if (error.error === 'Feature locked') {
          errorMessage = 'This feature is available on the Pro plan. Upgrade to unlock full feedback.';
        } else if (error.error === 'Unauthorized') {
          errorMessage = 'Please log in to continue.';
        } else if (response.status === 403) {
          errorMessage = error.message || 'Access denied. Please check your plan or try logging in again.';
        } else if (error.needsFeedback) {
          errorMessage = 'Run feedback first to generate ATS fixes and role tips, then try Rewrite.';
        }
        console.error('[RESUME-REWRITE] API error:', {
          status: response.status,
          error: error.error,
          message: error.message,
          upgradeRequired: error.upgradeRequired,
          needsFeedback: error.needsFeedback
        });
        throw new Error(errorMessage);
      }

      const result = await response.json();
      
      // Note: atsIssues and roleSpecificFeedback are only returned from /api/resume-feedback,
      // not from /api/resume-rewrite. They are already stored when feedback is received.
      
      return result;
    }

  // Generic helper to start plan changes for a given plan.
  // Uses /api/upgrade-plan for paid upgrades and falls back to /api/stripe-checkout for trials.
  const startCheckout = async (plan) => {
    try {
      if (typeof window.upgradePlan === 'function' && plan !== 'trial') {
        await window.upgradePlan(plan, {
          source: 'resume-feedback',
          returnUrl: window.location.href
        });
        return;
      }
      const confirmed = typeof window.requestUpgradeConfirmation === 'function'
        ? await window.requestUpgradeConfirmation(plan, { mode: 'checkout', currentPlan: localStorage.getItem('user-plan') || 'free' })
        : true;
      if (!confirmed) return;

      if (window.showLoadingOverlay) {
        window._currentLoadingOverlay = window.showLoadingOverlay('Redirecting to checkout...');
      }

      const user = window.FirebaseAuthManager?.getCurrentUser?.();
      if (!user) {
        // Keep behavior consistent with other upgrade flows: require login first.
        window.location.href = 'login.html';
        return;
      }
      const idToken = await user.getIdToken();
      const res = await fetch('/api/stripe-checkout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...(idToken ? { Authorization: `Bearer ${idToken}` } : {}) },
        body: JSON.stringify({ plan })
      });
      const data = await res.json();
      if (data && data.ok && data.url) {
        window.location.href = data.url;
        return;
      }
      throw new Error(data?.error || 'Checkout failed');
    } catch (e) {
      console.error('Start checkout error:', e);
      if (window._currentLoadingOverlay) {
        window._currentLoadingOverlay();
        window._currentLoadingOverlay = null;
      }
      // Fallback to pricing page with plan hint
      window.location.href = `pricing-a.html?plan=${encodeURIComponent(plan)}`;
    }
  };
  // Expose globally for inline onclick handlers
  window.startCheckout = startCheckout;

  function handleApiError(error, options = {}) {
      // Downgrade to debug level - user-facing errors shown via modals
      if (window.console && window.console.debug) {
        window.console.debug('[API Error]', error);
      }
      
      // Allow custom title and message to be passed in options
      const customTitle = options.title;
      const customMessage = options.message;
      
      // Use error.message first to preserve specific error handling
      // customMessage will be used as fallback only if error.message doesn't match specific patterns
      const originalMessage = error.message || 'An error occurred';
      let message = originalMessage;
      let modalType = 'error';
      let action = null;
      let actionLabel = 'OK';
      let messageWasModified = false;
      
      // Check if error has upgradeRequired flag (from API response)
      // Check both top-level and context.upgradeRequired (for dev environment responses)
      const upgradeRequired = error.upgradeRequired || 
        error.context?.upgradeRequired ||
        (error.message && error.message.includes('Upgrade to Pro'));
      
      // Handle upgrade-required errors with direct Stripe checkout
      if (upgradeRequired) {
        const upgradeToPro = async () => {
          try {
            if (typeof window.upgradePlan === 'function') {
              await window.upgradePlan('pro', {
                source: 'resume-feedback',
                returnUrl: window.location.href
              });
              return;
            }

            const user = window.FirebaseAuthManager?.getCurrentUser?.();
            const idToken = user ? await user.getIdToken() : null;
            const confirmed = typeof window.requestUpgradeConfirmation === 'function'
              ? await window.requestUpgradeConfirmation('pro', { mode: 'checkout', currentPlan: localStorage.getItem('user-plan') || 'free' })
              : true;
            if (!confirmed) {
              return;
            }
            // Show loading state only after confirmation
            if (window.showLoadingOverlay) {
              window._currentLoadingOverlay = window.showLoadingOverlay('Redirecting to checkout...');
            }
            const res = await fetch('/api/stripe-checkout', {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json', 
                ...(idToken ? { Authorization: `Bearer ${idToken}` } : {}) 
              },
              body: JSON.stringify({ plan: 'pro' })
            });
            const data = await res.json();
            if (data && data.ok && data.url) {
              window.location.href = data.url;
              return;
            }
            throw new Error(data?.error || 'Checkout failed');
          } catch (e) {
            console.error('Upgrade checkout error:', e);
            // Hide loading overlay
            if (window._currentLoadingOverlay) {
              window._currentLoadingOverlay();
              window._currentLoadingOverlay = null;
            }
            // Fallback to pricing page if checkout fails
            window.location.href = 'pricing-a.html';
          }
        };

        if (window.showErrorModal) {
          window.showErrorModal(
            'Trial Complete',
            'You\'ve used all 3 feedback attempts. Upgrade to Pro for unlimited feedback and unlock all features.',
            {
              showUpgrade: true,
              upgradeCallback: upgradeToPro,
              upgradeButtonText: 'Upgrade to Pro',
              buttonText: 'Maybe Later'
            }
          );
          return;
        }
      }
      
      
      
      // Map error messages to user-friendly modals
      if (message.includes('Unauthorized') || message.includes('Not authenticated')) {
        message = 'Please log in to continue.';
        messageWasModified = true;
        action = () => window.location.href = 'login.html';
        actionLabel = 'Go to Login';
      } else if (message.includes('Usage limit') || message.includes('limit reached')) {
        message = message + ' Upgrade to unlock more features.';
        messageWasModified = true;
        action = () => window.location.href = 'pricing-a.html';
        actionLabel = 'View Pricing';
      } else if (message.includes('Rate limit')) {
        message = message + ' Please try again in a moment.';
        messageWasModified = true;
      } else if (message.includes('Feature locked') || message.includes('upgrade')) {
        message = message;
        messageWasModified = true;
        action = () => window.location.href = 'pricing-a.html';
        actionLabel = 'Upgrade Now';
      } else if (message.includes('timeout') || message.includes('took too long')) {
        message = 'Our AI took too long to respond. Please try again or simplify your file.';
        messageWasModified = true;
        action = () => window.location.reload();
        actionLabel = 'Reload Page';
      } else if (message.includes('couldn\'t read') || message.includes('text-based')) {
        // File reading error - already user-friendly
        messageWasModified = true;
      } else if (message.includes('scanned PDF') || message.includes('image-based')) {
        // Enhanced scanned PDF message with actionable guidance
        message = 'This PDF appears to be image-based (scanned). Please upload a text-based PDF or Word document for best results. We\'re working on scan support for a future update.';
        messageWasModified = true;
      }
      
      // If no specific error pattern matched and customMessage is provided, use it as fallback
      // This preserves helpful context for generic feedback errors while allowing specific errors to be handled
      if (customMessage && !messageWasModified) {
        message = customMessage;
      }

      // Show modal instead of inline error
      if (window.showErrorModal) {
        window.showErrorModal(customTitle || 'Error', message, {
          buttonText: actionLabel || 'Got it',
          onClose: action || null,
          showRetry: !!action,
          retryCallback: action || null
        });
      } else {
        // Fallback to inline error if modals not loaded
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = 'background:#FEE2E2;border-left:4px solid #EF4444;color:#991B1B;padding:1rem;border-radius:8px;margin:1rem 0;';
        errorDiv.textContent = message;
        const main = document.querySelector('main');
        if (main) {
          main.insertBefore(errorDiv, main.firstChild);
          setTimeout(() => errorDiv.remove(), 5000);
        }
      }

      return message;
    }

    // Loading overlay management
    let currentLoadingOverlay = null;
    
    function showLoadingState(message = 'Loading...') {
      // For rewrite operations - use skeleton only, no overlay
      // Skeleton provides better contextual feedback without blocking the view
      if (message.includes('Rewriting')) {
        // Don't show overlay - skeleton will be handled by showRewriteSkeleton()
        // Just return early to prevent overlay from showing
        return;
      }
      
      // For regenerate/update/optimize operations - use lightweight overlay
      // since content is already visible and we're just updating it
      if (message.includes('Regenerating') || 
          message.includes('Updating') || message.includes('Optimizing')) {
        if (window.JobHackAILoading) {
          currentLoadingOverlay = window.JobHackAILoading.show(message, 'main-loading-overlay');
        }
        return;
      }
      
      // For initial loads ("Analyzing") - use skeleton loading instead of overlay
      // This provides better UX with contextual placeholders that match the final content layout
      const userPlan = getCurrentUserPlan();
      const willGetFeedback = ['trial', 'essential', 'pro', 'premium'].includes(userPlan);
      
      // Show skeletons for initial analysis
      const jobTitleInput = document.getElementById('rf-job-title');
      const hasRole = jobTitleInput?.value?.trim() || currentJobTitle;
      showSkeletons(willGetFeedback, hasRole);
      hideHeaderSkeleton();
      
      // For Pro/Premium users, show skeleton on "Your Original Snippet" text box during analysis
      if (userPlan === 'pro' || userPlan === 'premium') {
        const rewriteContent = document.getElementById('rf-rewrite-content');
        if (rewriteContent) {
          // Ensure rewrite content is visible (it should already be for Pro/Premium)
          rewriteContent.style.display = 'block';
          // Show skeleton on the original snippet box (first textarea, index 0)
          const originalSnippetBox = rewriteContent.querySelectorAll('.rf-snippet-box')[0];
          if (originalSnippetBox) {
            originalSnippetBox.classList.add('rf-skeleton', 'rf-snippet-skeleton');
          }
        }
      }
      
      // Store cleanup function (skeleton hide function)
      currentLoadingOverlay = () => {
        hideSkeletons();
        hideATSSkeleton();
        // Also hide skeleton on original snippet box for Pro/Premium
        if (userPlan === 'pro' || userPlan === 'premium') {
          const rewriteContent = document.getElementById('rf-rewrite-content');
          if (rewriteContent) {
            const originalSnippetBox = rewriteContent.querySelectorAll('.rf-snippet-box')[0];
            if (originalSnippetBox) {
              originalSnippetBox.classList.remove('rf-skeleton', 'rf-snippet-skeleton');
            }
          }
        }
      };
    }

    function hideLoadingState() {
      if (currentLoadingOverlay) {
        if (typeof currentLoadingOverlay === 'function') {
          // It's a skeleton cleanup function
          currentLoadingOverlay();
        } else if (window.JobHackAILoading) {
          // It's an overlay element, hide it
          window.JobHackAILoading.hide('main-loading-overlay');
        }
        currentLoadingOverlay = null;
      }
    }

    function forceHideOverlays() {
      try {
        hideLoadingState();
        const legacy = document.getElementById('loading-overlay');
        if (legacy) legacy.style.display = 'none';
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to force hide overlays', e);
      }
    }

    // --- GLOBAL BUTTON LISTENER FUNCTIONS ---
    // Copy resume handler function
    const copyResumeHandler = function() {
      const rewritten = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[1];
      if (rewritten) {
        navigator.clipboard.writeText(rewritten.value || rewritten.textContent);
        this.textContent = 'Copied!';
        setTimeout(() => { this.textContent = 'Copy Rewritten Resume'; }, 1200);
        
        // Show success toast
        if (window.JobHackAIToast) {
          window.JobHackAIToast.success('Copied to clipboard!');
        }
      }
    };

    // Controls when the post-rewrite action buttons are shown (only after we have rewrite content)
    const setCopyRewriteVisibility = (isVisible) => {
      const copyBtn = document.querySelector('#rf-rewrite-content .btn.btn-primary');
      const downloadBtn = document.getElementById('rf-download');
      if (copyBtn) {
        copyBtn.style.display = isVisible ? 'inline-block' : 'none';
        copyBtn.disabled = !isVisible;
        if (!isVisible) copyBtn.textContent = 'Copy Rewritten Resume';
      }
      if (downloadBtn) {
        downloadBtn.style.display = isVisible ? 'inline-block' : 'none';
        downloadBtn.disabled = !isVisible;
        downloadBtn.setAttribute('aria-disabled', (!isVisible).toString());
        // Match Cover Letter: text-only btn-outline label
        downloadBtn.textContent = 'Download PDF';
      }
    };

    // Download PDF handler (reuses window.print flow used across LinkedIn/Cover Letter)
    const rfDownloadHandler = function() {
      const rewrittenBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[1];
      if (!rewrittenBox) return;

      // Entitlement check - Pro/Premium only
      const allowedPlans = ['pro', 'premium'];
      let currentPlan = null;
      try {
        if (window.JobHackAINavigation && typeof window.JobHackAINavigation.getEffectivePlan === 'function') {
          currentPlan = window.JobHackAINavigation.getEffectivePlan();
        } else if (typeof getCurrentPlanStandalone === 'function') {
          currentPlan = getCurrentPlanStandalone();
        }
      } catch (err) {
        currentPlan = null;
      }
      if (!currentPlan || !allowedPlans.includes(String(currentPlan).toLowerCase())) {
        // Show upgrade flow (reuse existing modal if available)
        if (typeof openUpgradeModal === 'function') {
          openUpgradeModal();
        } else {
          // Fallback to pricing page
          window.location.href = 'pricing-a.html';
        }
        return;
      }

      // Build print HTML content (header with ATS score, role tips, and rewritten resume)
      function buildRfPrintHtml() {
        const atsTile = document.getElementById('rf-ats-score-tile');
        const atsScoreHtml = atsTile ? atsTile.innerHTML : '';
        const roleTips = (window.latestRoleSpecific && Array.isArray(window.latestRoleSpecific.sections)) ? window.latestRoleSpecific.sections : [];
        let roleTipsHtml = '';
        if (Array.isArray(roleTips) && roleTips.length) {
          const sectionsHtml = roleTips.map(s => {
            const heading = escapeHtml(s.section || s.heading || '');
            const tipsArray = (s.tips && Array.isArray(s.tips) && s.tips.length) ? s.tips
              : (s.items && Array.isArray(s.items) && s.items.length) ? s.items
              : [];
            const tipsHtml = tipsArray.length ? `<ul>${tipsArray.map(t => `<li>${escapeHtml(t)}</li>`).join('')}</ul>` : '<div style="color:#6b7280;font-style:italic;">No tips available</div>';
            return `<div class="rf-print-role-section" style="margin-bottom:8px;"><strong>${heading}</strong>${tipsHtml}</div>`;
          }).join('');
          roleTipsHtml = `<section class="rf-print-section"><h3>Role-specific tips</h3>${sectionsHtml}</section>`;
        }
        const rewrittenText = rewrittenBox.value || rewrittenBox.textContent || '';
        const safeRewritten = escapeHtml(rewrittenText).replace(/\n/g, '<br/>');

        // Basic template - keep inline styles minimal and rely on print CSS
        return `
          <div class="rf-print-header" style="margin-bottom:16px;">
            <h2 style="margin:0 0 8px 0;">Resume Rewrite</h2>
            <div>${atsScoreHtml}</div>
          </div>
          ${roleTipsHtml}
          <section class="rf-print-section">
            <h3>Rewritten Resume</h3>
            <div style="white-space:pre-wrap;font-family:inherit;">${safeRewritten}</div>
          </section>
          <footer style="margin-top:20px;font-size:11px;color:#6b7280;">Generated by JobHackAI â€¢ ${new Date().toLocaleString()}</footer>
        `;
      }

      // Helper to escape HTML (simple)
      function escapeHtml(str) {
        if (!str) return '';
        return String(str)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      }

      // Populate print container and trigger print
      // Ensure the print container is appended to document.body before printing.
      // If an existing #rf-print is present but not a child of <body> (e.g., inside .rf-main-column),
      // create a temporary container in <body> instead to ensure it is visible during print.
      const existingPrint = document.getElementById('rf-print');
      let printContainer = null;
      let createdTempPrintContainer = false;
      if (existingPrint && existingPrint.parentElement === document.body) {
        printContainer = existingPrint;
      } else {
        // Create a temporary container attached to body so it will be visible during print.
        printContainer = document.createElement('div');
        printContainer.id = 'rf-print';
        printContainer.style.display = 'none';
        document.body.appendChild(printContainer);
        createdTempPrintContainer = true;
      }
      // Populate content into the container attached to <body>.
      printContainer.innerHTML = buildRfPrintHtml();

      const prevTitle = document.title;
      const date = new Date().toISOString().slice(0,10);
      document.title = `jobhackai-resume-rewrite-${date}`;
      window.print();
      setTimeout(() => {
        document.title = prevTitle;
        // Clean up print container: remove temporary node or clear persistent container
        if (createdTempPrintContainer && printContainer && printContainer.parentNode) {
          printContainer.parentNode.removeChild(printContainer);
        } else if (printContainer) {
          printContainer.innerHTML = '';
        }
      }, 500);
    };
    
    // Regenerate rewrite handler function
    const regenerateRewriteHandler = async function() {
      if (!currentResumeId) {
        handleApiError(new Error('Please upload a resume first'));
        return;
      }

      const jobTitle = document.getElementById('rf-job-title')?.value?.trim() || currentJobTitle;
      if (!jobTitle) {
        handleApiError(new Error('Please enter a target job title'));
        return;
      }
      // Guard: require feedback context before rewriting (ATS + role tips)
      const hasAtsIssues = !!(window.latestAtsIssues && Array.isArray(window.latestAtsIssues) && window.latestAtsIssues.length);
      const hasRoleTips = !!(
        window.latestRoleSpecific &&
        window.latestRoleSpecific.targetRoleUsed !== undefined &&
        Array.isArray(window.latestRoleSpecific.sections) &&
        window.latestRoleSpecific.sections.length
      );
      if (!hasAtsIssues && !hasRoleTips) {
        handleApiError(new Error('Run feedback first to generate ATS fixes and role tips, then try Rewrite.'));
        return;
      }
      const section = null; // Can be enhanced to allow section-specific rewrites

      try {
        showLoadingState('Rewriting resume...');
        showRewriteSkeleton();
        clearInlineRewriteCountdown();
        setCopyRewriteVisibility(false);
        this.disabled = true;
        this.textContent = 'Regenerating...';

        // Use stored feedback context if available
        const atsIssues = window.latestAtsIssues || null;
        const roleSpecificFeedback = hasRoleTips ? window.latestRoleSpecific : null;
        
        const result = await rewriteResume(currentResumeId, section, jobTitle, atsIssues, roleSpecificFeedback);
        
        console.log('ðŸ“ [RESUME-REWRITE] API result:', {
          hasRewritten: !!result.rewritten,
          hasRewrittenResume: !!result.rewrittenResume,
          hasChangeSummary: !!result.changeSummary,
          changeSummary: result.changeSummary
        });
        
        const rewrittenBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[1];
        const rewriteDescInline = document.getElementById('rf-rewrite-desc-inline');
        const resolvedRewrite = result.rewritten || result.rewrittenResume || '';
        const hasRewriteContent = typeof resolvedRewrite === 'string' && resolvedRewrite.trim().length > 0;
        if (rewrittenBox) {
          rewrittenBox.value = resolvedRewrite;
        }
        if (rewriteDescInline) {
          rewriteDescInline.style.display = hasRewriteContent ? 'block' : 'none';
        }
        setCopyRewriteVisibility(hasRewriteContent);
        
        // Also populate the original snippet box
        const originalBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[0];
        if (originalBox && result.original) {
          originalBox.value = result.original;
        }
        
        // Display change summary if available
        if (result.changeSummary) {
          console.log('âœ… [RESUME-REWRITE] Displaying change summary:', result.changeSummary);
          displayChangeSummary(result.changeSummary);
        } else {
          console.warn('âš ï¸ [RESUME-REWRITE] No change summary in API response');
        }

        // Show success toast
        if (window.JobHackAIToast) {
          window.JobHackAIToast.success('Resume rewritten successfully!');
        }
        
        // Save job title to state persistence
        if (window.JobHackAIStatePersistence && jobTitle) {
          // Pass current job title to validate cache match
          const cachedScore = window.JobHackAIStatePersistence.loadATSScore(jobTitle);
          if (cachedScore) {
            window.JobHackAIStatePersistence.saveATSScore({
              ...cachedScore,
              jobTitle: jobTitle,
              extractionQuality: cachedScore.extractionQuality
            });
          }
        }

        this.textContent = 'Generate Rewrite';
        // Let cooldown renderer own button state; await to avoid race
        await renderRewriteCooldownIndicator();
        hideRewriteSkeleton();
        hideLoadingState();
      } catch (error) {
        if (error && error.status === 429) {
          const retryAfter = Number(error.retryAfter) || 45;
          await renderRewriteCooldownIndicator();
          startInlineRewriteCountdown(retryAfter);
        } else {
          handleApiError(error);
          this.textContent = 'Generate Rewrite';
          await renderRewriteCooldownIndicator();
        }
        setCopyRewriteVisibility(false);
        hideRewriteSkeleton();
        hideLoadingState();
      }
    };
    
    // Inline rewrite cooldown countdown (driven directly from /api/resume-rewrite 429 responses)
    function clearInlineRewriteCountdown() {
      if (window._rewriteCountdownInterval) {
        clearInterval(window._rewriteCountdownInterval);
        window._rewriteCountdownInterval = null;
      }
    }

    function clearAllRewriteCooldownTimers() {
      // Clear inline countdown
      clearInlineRewriteCountdown();
      // Clear usage-indicator-based interval
      if (window._rewriteCooldownInterval) {
        clearInterval(window._rewriteCooldownInterval);
        window._rewriteCooldownInterval = null;
      }
    }

    // Lightweight rewrite skeletons (reuse ATS skeleton styling)
    function showRewriteSkeleton() {
      const rewriteContent = document.getElementById('rf-rewrite-content');
      if (!rewriteContent) return;

      // Ensure the overlay isn't applied to the whole card
      rewriteContent.classList.remove('rf-skeleton');

      // Only show skeleton on the "Rewritten Snippet" (second textarea, index 1)
      // The "Original Snippet" (index 0) already has content, so no skeleton needed
      const snippetBoxes = rewriteContent.querySelectorAll('.rf-snippet-box');
      if (snippetBoxes.length > 1) {
        // Only apply skeleton to the rewritten snippet box (second one)
        snippetBoxes[1].classList.add('rf-skeleton', 'rf-snippet-skeleton');
      }
    }

    function hideRewriteSkeleton() {
      const rewriteContent = document.getElementById('rf-rewrite-content');
      if (!rewriteContent) return;

      // Clean up any legacy overlay class on the container
      rewriteContent.classList.remove('rf-skeleton');

      const snippetBoxes = rewriteContent.querySelectorAll('.rf-snippet-box');
      snippetBoxes.forEach((box) => {
        box.classList.remove('rf-skeleton', 'rf-snippet-skeleton');
      });
    }

    function startInlineRewriteCountdown(retryAfterSeconds) {
      const regenBtn = document.querySelector('#rf-rewrite-content #rf-generate');
      const container = document.getElementById('rf-rewrite-cooldown');

      clearAllRewriteCooldownTimers();

      const helperId = 'rf-rewrite-inline-helper';
      const ensureHelper = () => {
        if (!container) return null;
        let helper = document.getElementById(helperId);
        if (!helper) {
          helper = document.createElement('div');
          helper.id = helperId;
          helper.style.cssText = 'margin-top:0.25rem;color:var(--color-text-secondary);font-size:0.9rem;';
          container.appendChild(helper);
        }
        return helper;
      };

      let remaining = Math.max(0, Math.round(retryAfterSeconds || 45));
      const defaultLabel = 'Generate Rewrite';
      const originalLabel = regenBtn
        ? (regenBtn.dataset.originalLabel || defaultLabel)
        : defaultLabel;
      if (regenBtn) {
        regenBtn.dataset.originalLabel = originalLabel;
        regenBtn.disabled = true;
        regenBtn.textContent = `Retry in ${remaining}s`;
      }

      const helper = ensureHelper();
      if (helper) {
        helper.textContent = 'Weâ€™re preparing your next rewrite. You can run a new one when this ends.';
      }

      window._rewriteCountdownInterval = setInterval(() => {
        remaining -= 1;
        if (remaining > 0) {
          if (regenBtn) regenBtn.textContent = `Retry in ${remaining}s`;
        } else {
          clearInlineRewriteCountdown();
          if (regenBtn) {
            regenBtn.disabled = false;
            regenBtn.textContent = originalLabel || 'Generate Rewrite';
          }
          if (helper) helper.textContent = '';
        }
      }, 1000);
    }

    // Render rewrite cooldown indicator using shared usage indicator component
    async function renderRewriteCooldownIndicator() {
      const container = document.getElementById('rf-rewrite-cooldown');
      const setRegenEnabled = () => {
        const regenBtn = document.querySelector('#rf-rewrite-content #rf-generate');
        if (regenBtn) regenBtn.disabled = false;
      };
      if (!container || typeof window.renderUsageIndicator !== 'function') {
        setRegenEnabled();
        return;
      }

      // Track latest invocation to avoid overlapping intervals
      const callId = (window._rewriteCooldownCallId || 0) + 1;
      window._rewriteCooldownCallId = callId;

      const clearExistingInterval = () => {
        if (window._rewriteCooldownInterval) {
          clearInterval(window._rewriteCooldownInterval);
          window._rewriteCooldownInterval = null;
        }
      };

      const token = localStorage.getItem('firebase-id-token');
      if (!token) {
        if (callId !== window._rewriteCooldownCallId) return;
        clearExistingInterval();
        container.innerHTML = '';
        setRegenEnabled();
        return;
      }

      try {
        const resp = await fetch('/api/usage', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          }
        });

        if (callId !== window._rewriteCooldownCallId) return;

        if (!resp.ok) {
          clearExistingInterval();
          container.innerHTML = '';
          setRegenEnabled();
          return;
        }

        const data = await resp.json();
        const usage = data?.usage?.resumeRewrite;
        const plan = data?.plan;

        if (!usage || usage.cooldown === undefined) {
          clearExistingInterval();
          container.innerHTML = '';
          setRegenEnabled();
          return;
        }

        // Clear any existing interval before rendering new state
        clearExistingInterval();

        const renderChip = (cooldownValue) => {
          if (callId !== window._rewriteCooldownCallId) return;
          container.innerHTML = '';
          const holder = document.createElement('div');
          container.appendChild(holder);

          window.renderUsageIndicator({
            feature: 'resumeRewrite',
            usage: { ...usage, cooldown: cooldownValue },
            plan,
            container: holder
          });

          if (cooldownValue > 0) {
            const helper = document.createElement('div');
            helper.style.cssText = 'margin-top:0.25rem;color:var(--color-text-secondary);font-size:0.9rem;';
            helper.textContent = 'Weâ€™re preparing your next rewrite. You can run a new one when this ends.';
            container.appendChild(helper);
          }

          const regenBtn = document.querySelector('#rf-rewrite-content #rf-generate');
          if (regenBtn) regenBtn.disabled = cooldownValue > 0;
          if (cooldownValue === 0) setRegenEnabled();
        };

        renderChip(usage.cooldown);

        if (usage.cooldown > 0) {
          // Avoid overlapping with the inline countdown; let the inline timer own the UI if active
          if (window._rewriteCountdownInterval) {
            return;
          }
          let remaining = usage.cooldown;
          window._rewriteCooldownInterval = setInterval(() => {
            if (callId !== window._rewriteCooldownCallId) {
              clearExistingInterval();
              return;
            }
            remaining -= 1;
            if (remaining <= 0) {
              clearInterval(window._rewriteCooldownInterval);
              window._rewriteCooldownInterval = null;
              renderRewriteCooldownIndicator();
              return;
            }
            renderChip(remaining);
          }, 1000);
        }
      } catch (err) {
        console.warn('[RESUME-REWRITE] Failed to render cooldown indicator', err);
        clearExistingInterval();
        setRegenEnabled();
      }
    }
    
    // Resume Rewriting Buttons - Fixed selectors to match actual HTML
    const attachRewriteButtonListeners = () => {
      const copyBtn = document.querySelector('#rf-rewrite-content .btn.btn-primary');
      const regenRewriteBtn = document.querySelector('#rf-rewrite-content #rf-generate');
      const downloadBtn = document.getElementById('rf-download');
      
      if (copyBtn) {
        // Remove any existing listeners
        copyBtn.removeEventListener('click', copyResumeHandler);
        copyBtn.addEventListener('click', copyResumeHandler);
      }
      
      if (regenRewriteBtn) {
        // Remove any existing listeners
        regenRewriteBtn.removeEventListener('click', regenerateRewriteHandler);
        regenRewriteBtn.addEventListener('click', regenerateRewriteHandler);
      }
      
      if (downloadBtn) {
        downloadBtn.removeEventListener('click', rfDownloadHandler);
        downloadBtn.addEventListener('click', rfDownloadHandler);
      }

      // Initial render of cooldown state on mount
      renderRewriteCooldownIndicator();
    };

    // --- DEV-ONLY PLAN TOGGLE LOGIC ---
    document.addEventListener('DOMContentLoaded', function() {
      // Wait for navigation system to be ready before initializing
      function waitForNavigationAndInit() {
        if (window.JobHackAINavigation && typeof window.JobHackAINavigation.getEffectivePlan === 'function') {
          console.log('Navigation system ready, initializing resume feedback page');
          // Use navigation system's plan instead of hardcoded value
          user.plan = getCurrentUserPlan();
          
          // Debounce plan updates to prevent flickering
          let updateRfTileTimeout = null;
          let lastUpdateTime = 0;
          let lastUpdatedPlan = null;
          const UPDATE_COOLDOWN_MS = 300; // Minimum 300ms between updates
          
          function debouncedUpdateRfTileForPlan() {
            const currentPlan = getCurrentUserPlan();
            const now = Date.now();
            const timeSinceLastUpdate = now - lastUpdateTime;
            
            // Skip if plan hasn't actually changed
            if (currentPlan === lastUpdatedPlan) {
              return;
            }
            
            // If enough time has passed, update immediately
            if (timeSinceLastUpdate >= UPDATE_COOLDOWN_MS) {
              clearTimeout(updateRfTileTimeout);
              updateRfTileTimeout = null;
              lastUpdateTime = now;
              lastUpdatedPlan = currentPlan;
              updateRfTileForPlan();
            } else {
              // Otherwise, debounce the update
              clearTimeout(updateRfTileTimeout);
              updateRfTileTimeout = setTimeout(() => {
                const latestPlan = getCurrentUserPlan();
                lastUpdateTime = Date.now();
                lastUpdatedPlan = latestPlan;
                updateRfTileForPlan();
              }, UPDATE_COOLDOWN_MS - timeSinceLastUpdate);
            }
          }
          
          // Track the last known plan to prevent redundant updates
          let lastKnownPlan = getCurrentUserPlan();
          
          // Unified plan change handler
          function handlePlanChange(newPlan, source) {
            if (newPlan && newPlan !== lastKnownPlan && newPlan !== 'undefined') {
              console.log(`[RESUME-FEEDBACK] Plan change detected (${source}):`, lastKnownPlan, '->', newPlan);
              lastKnownPlan = newPlan;
              debouncedUpdateRfTileForPlan();
            }
          }
          
          // Listen for plan changes from navigation system (storage events)
          // Note: storage events only fire for changes from OTHER tabs/windows
          window.addEventListener('storage', function(e) {
            if (e.key === 'dev-plan' || e.key === 'user-plan' || e.key === 'user-authenticated') {
              // Use a small delay to let navigation system finish updating
              setTimeout(() => {
                const newPlan = getCurrentUserPlan();
                handlePlanChange(newPlan, 'storage');
              }, 50);
            }
          });
          
          // Listen for custom plan change events (from navigation system)
          window.addEventListener('planChanged', function(e) {
            const newPlan = e.detail?.newPlan || getCurrentUserPlan();
            handlePlanChange(newPlan, 'planChanged');
            // Re-attach button listeners after plan change
            setTimeout(attachRewriteButtonListeners, 100);
          });
          
          // Listen for navigation ready event
          window.addEventListener('navigationReady', function() {
            console.log('[RESUME-FEEDBACK] Navigation ready event received');
            // Use a delay to ensure navigation has finished initializing
            setTimeout(() => {
              const newPlan = getCurrentUserPlan();
              handlePlanChange(newPlan, 'navigationReady');
            }, 100);
          });
          
          // Initial update (immediate, no debounce)
          updateRfTileForPlan();
          lastUpdatedPlan = getCurrentUserPlan();
          
          // Set up periodic plan checking to catch any missed updates (reduced frequency)
          setInterval(function() {
            const currentPlan = getCurrentUserPlan();
            if (currentPlan !== lastKnownPlan && currentPlan !== 'undefined') {
              handlePlanChange(currentPlan, 'periodic');
            }
          }, 5000); // Check every 5 seconds instead of 1 second
        } else {
          console.log('Navigation system not ready, retrying in 100ms');
          setTimeout(waitForNavigationAndInit, 100);
        }
      }
      
      // Start waiting for navigation system
      waitForNavigationAndInit();
      
      // Initialize role selector - ensure it's initialized after DOM and RoleSelector are ready
      let roleSelectorInitAttempts = 0;
      const MAX_ROLE_SELECTOR_ATTEMPTS = 50; // Try for up to 10 seconds (50 * 200ms)
      
      function initializeRoleSelector() {
        const jobTitleInput = document.getElementById('rf-job-title');
        if (!jobTitleInput) {
          // Element not ready yet, retry
          if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
            roleSelectorInitAttempts++;
            setTimeout(initializeRoleSelector, 100);
          } else {
            console.warn('[RESUME-FEEDBACK] Job title input not found after max attempts');
          }
          return;
        }
        
        // Wait for RoleSelector class to be available (from role-selector.js module)
        if (window.RoleSelector) {
          // Check if already initialized to avoid duplicate initialization
          if (!jobTitleInput.dataset.roleSelectorInitialized) {
            try {
              const roleSelector = new window.RoleSelector(jobTitleInput, {
                placeholder: 'Start typing your target role (e.g., Software Engineer, Product Manager)',
                minChars: 2,
                maxResults: 8,
                showCustomOption: true,
                onSelect: function(roleName, isCustom) {
                  // Update currentJobTitle when role is selected
                  currentJobTitle = roleName;
                  markRoleValueChange(roleName, 'role-select');
                  console.log('[RESUME-FEEDBACK] Role selected:', roleName, isCustom ? '(custom)' : '');
                  
                  // Update the input's aria-expanded attribute
                  jobTitleInput.setAttribute('aria-expanded', 'false');
                  
                  // Enable generate button if file is selected
                  const fileInput = document.getElementById('rf-upload');
                  const generateBtn = document.getElementById('rf-generate-btn');
                  if (fileInput && generateBtn && fileInput.files && fileInput.files.length > 0) {
                    generateBtn.disabled = false;
                  }
                }
              });
              jobTitleInput.dataset.roleSelectorInitialized = 'true';
              console.log('[RESUME-FEEDBACK] RoleSelector initialized successfully');
              
              // Also listen for input changes to update currentJobTitle when user types
              jobTitleInput.addEventListener('input', function() {
                const value = this.value.trim();
                if (value) {
                  currentJobTitle = value;
                  console.log('[RESUME-FEEDBACK] Job title updated:', value);
                } else {
                  // Clear currentJobTitle if input is cleared
                  currentJobTitle = null;
                }
                markRoleValueChange(value, 'role-input');
              });
              
              // Prevent default value from being set
              jobTitleInput.addEventListener('focus', function() {
                // Ensure no default value is set when focusing
                if (this.value === 'Software Engineer' && !currentJobTitle) {
                  this.value = '';
                }
              });
              
              // Listen for blur to capture final value even if user doesn't select from dropdown
              jobTitleInput.addEventListener('blur', function() {
                const value = this.value.trim();
                if (value) {
                  currentJobTitle = value;
                } else {
                  currentJobTitle = null;
                }
                markRoleValueChange(value, 'role-blur');
              });
            } catch (error) {
              console.error('[RESUME-FEEDBACK] Failed to initialize RoleSelector:', error);
              // Retry once more after a delay
              if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
                roleSelectorInitAttempts++;
                setTimeout(initializeRoleSelector, 500);
              } else {
                console.warn('[RESUME-FEEDBACK] RoleSelector initialization failed after max attempts - dropdown may not work');
              }
            }
          }
        } else {
          // RoleSelector not loaded yet, wait and retry
          if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
            roleSelectorInitAttempts++;
            setTimeout(initializeRoleSelector, 200);
          } else {
            console.warn('[RESUME-FEEDBACK] RoleSelector not available after max attempts - dropdown may not work');
          }
        }
      }
      
      // Initialize role selector after DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeRoleSelector);
      } else {
        // DOM already ready, but wait a bit for scripts to load
        setTimeout(initializeRoleSelector, 100);
      }

      // Load cached ATS score on page load (with KV fallback)
      async function loadCachedATSScore() {
        let cachedScore = null;
        
        // ATS score for resume feedback tile and history is always fetched from D1 feedback API.
        updateProgressRing(0);
        
        try {
          const token = await getAuthToken();
          if (token) {
            const historyResponse = await fetch('/api/resume-feedback/history?limit=1', {
              headers: {
                'Authorization': `Bearer ${token}`
              }
            });
            
            if (historyResponse.ok) {
              const historyData = await historyResponse.json();
              const latestHistoryItem = historyData.items?.[0]; // Newest first (ORDER BY created_at DESC)
              
              if (latestHistoryItem && latestHistoryItem.atsScore != null && typeof latestHistoryItem.atsScore === 'number') {
                // Use score from history (resume feedback run only)
                cachedScore = {
                  score: latestHistoryItem.atsScore,
                  breakdown: {}, // History doesn't include breakdown - will try to restore from localStorage if available
                  jobTitle: latestHistoryItem.role || latestHistoryItem.title || null,
                  resumeId: latestHistoryItem.resumeId || null,
                  timestamp: latestHistoryItem.createdAt ? new Date(latestHistoryItem.createdAt).getTime() : Date.now()
                };
                
                console.log('[RESUME-FEEDBACK] Loaded score from history (resume feedback run only):', cachedScore.score);
                
                // Fetch full detail payload from D1 to get atsRubric and roleSpecificFeedback
                // Guard: Only fetch detail on page load/refresh (rubric grid empty), not after live runs in same session
                // Prevents 404s due to ID timing/contract issues when sessionId from history list doesn't match D1 state
                const rubricGrid = document.getElementById('rf-rubric-grid');
                const isPageLoad = !rubricGrid || rubricGrid.innerHTML.trim() === '';
                
                if (latestHistoryItem.sessionId && isPageLoad) {
                  try {
                    const encodedSessionId = encodeURIComponent(String(latestHistoryItem.sessionId));
                    const detailResponse = await fetch(`/api/resume-feedback/history/${encodedSessionId}`, {
                      headers: {
                        'Authorization': `Bearer ${token}`
                      }
                    });
                    
                    if (detailResponse.ok) {
                      const detailData = await detailResponse.json();
                      // Only set atsRubric if D1 provides a non-empty array (BugBot B fix)
                      if (detailData.atsRubric && Array.isArray(detailData.atsRubric) && detailData.atsRubric.length > 0) {
                        cachedScore.atsRubric = detailData.atsRubric;
                        console.log('[RESUME-FEEDBACK] Hydrated atsRubric from D1 detail endpoint (sessionId:', latestHistoryItem.sessionId, ')');
                      }
                      if (detailData.roleSpecificFeedback) {
                        cachedScore.roleSpecificFeedback = detailData.roleSpecificFeedback;
                        console.log('[RESUME-FEEDBACK] Hydrated roleSpecificFeedback from D1 detail endpoint (sessionId:', latestHistoryItem.sessionId, ')');
                      }
                    } else if (detailResponse.status === 404) {
                      // 404 indicates timing/D1 propagation issue - log but continue with localStorage fallback
                      console.warn('[RESUME-FEEDBACK] Detail endpoint returned 404 for sessionId:', latestHistoryItem.sessionId, '- likely D1 propagation lag, using localStorage fallback');
                    }
                  } catch (detailError) {
                    console.warn('[RESUME-FEEDBACK] Detail endpoint fetch failed, falling back to localStorage:', detailError);
                  }
                }
                
                // Consolidate localStorage restoration (single read, multiple field extraction)
                // Priority: D1 detail > localStorage > undefined
                if (window.JobHackAIStatePersistence && cachedScore.resumeId) {
                  const localStorageScore = window.JobHackAIStatePersistence.loadATSScore(null);
                  if (localStorageScore && localStorageScore.resumeId === cachedScore.resumeId) {
                    // BugBot A fix: extractionQuality loaded independently of atsRubric
                    if (localStorageScore.extractionQuality !== undefined) {
                      cachedScore.extractionQuality = localStorageScore.extractionQuality;
                    }
                    
                    // Breakdown fallback only if D1 didn't provide valid atsRubric (BugBot B fix: empty array blocks fallback)
                    if (!cachedScore.atsRubric && localStorageScore.breakdown) {
                      cachedScore.breakdown = localStorageScore.breakdown;
                    }
                    
                    // Role-specific feedback fallback only if D1 didn't provide it
                    if (!cachedScore.roleSpecificFeedback && localStorageScore.roleSpecificFeedback) {
                      cachedScore.roleSpecificFeedback = localStorageScore.roleSpecificFeedback;
                    }
                  }
                }
              }
            }
          }
        } catch (historyError) {
          console.warn('[RESUME-FEEDBACK] History fetch failed:', historyError);
          // Continue without history - will show 0% (correct for new users)
        }
        
        // If no history score, show 0% (don't load from persistence or localStorage)
        // This ensures free account scores don't appear on resume feedback page
        // FIX: Use == null to correctly handle legitimate 0% scores (0 is falsy but valid)
        if (!cachedScore || cachedScore.score == null) {
          console.log('[RESUME-FEEDBACK] No history found - showing 0% (free account scores excluded)');
          return; // Exit early - UI already shows 0% from updateProgressRing(0) above
        }
        
        // Display the score from history
        // FIX: Use != null to correctly handle legitimate 0% scores
        if (cachedScore && cachedScore.score != null) {
          const candidate = {
            runKey: `cache-${cachedScore.resumeId || 'history'}-${cachedScore.timestamp || Date.now()}`,
            resumeId: cachedScore.resumeId,
            role: cachedScore.jobTitle || currentJobTitle || '',
            score: cachedScore.score,
            breakdown: cachedScore.breakdown,
            source: 'cache',
            timestamp: cachedScore.timestamp || Date.now()
          };
          const applied = attemptApplyScoreCandidate(candidate, () => {
            console.log('[RESUME-FEEDBACK] Loading score from resume feedback history:', cachedScore.score);
            updateProgressRing(cachedScore.score);
            // Hide placeholder
            hidePlaceholder();
            // Show rubric grid
            const rubricGrid = document.getElementById('rf-rubric-grid');
            if (rubricGrid) {
              rubricGrid.style.display = 'grid';
            }

            // Prefer atsRubric from D1 detail endpoint if available (includes full feedback with bullets)
            if (cachedScore.atsRubric && Array.isArray(cachedScore.atsRubric) && cachedScore.atsRubric.length > 0) {
              populateAtsRubric(cachedScore.atsRubric);
              hideATSSkeleton();
            } else if (cachedScore.breakdown && Object.keys(cachedScore.breakdown).length > 0) {
              const getScore = (value) => {
                if (typeof value === 'number') return value;
                if (value && typeof value === 'object' && typeof value.score === 'number') return value.score;
                return 0;
              };

              const getFeedback = (value) => {
                if (value && typeof value === 'object') {
                  if (typeof value.feedback === 'string') {
                    return limitFeedbackToSentences(value.feedback);
                  }
                  if (typeof value.tip === 'string') {
                    return limitFeedbackToSentences(value.tip);
                  }
                }
                return '';
              };

              const rubric = [
                {
                  label: 'Keyword Relevance',
                  score: getScore(cachedScore.breakdown.keywordScore),
                  max: ATS_RUBRIC_MAX.KEYWORD_RELEVANCE,
                  tip: getFeedback(cachedScore.breakdown.keywordScore)
                },
                {
                  label: 'Formatting Compliance',
                  score: getScore(cachedScore.breakdown.formattingScore),
                  max: ATS_RUBRIC_MAX.FORMATTING_COMPLIANCE,
                  tip: getFeedback(cachedScore.breakdown.formattingScore)
                },
                {
                  label: 'Structure & Section Completeness',
                  score: getScore(cachedScore.breakdown.structureScore),
                  max: ATS_RUBRIC_MAX.STRUCTURE_COMPLETENESS,
                  tip: getFeedback(cachedScore.breakdown.structureScore)
                },
                {
                  label: 'Tone & Clarity',
                  score: getScore(cachedScore.breakdown.toneScore),
                  max: ATS_RUBRIC_MAX.TONE_CLARITY,
                  tip: getFeedback(cachedScore.breakdown.toneScore)
                },
                {
                  label: 'Grammar & Spelling',
                  score: getScore(cachedScore.breakdown.grammarScore),
                  max: ATS_RUBRIC_MAX.GRAMMAR_SPELLING,
                  tip: getFeedback(cachedScore.breakdown.grammarScore),
                  flaggedTerms: cachedScore.breakdown.grammarScore?.flaggedTerms
                }
              ];
              updateRubricGrid(rubric);
              hideATSSkeleton();
            }

            if (cachedScore.roleSpecificFeedback && !window.__rfActiveFeedbackToken) {
              updateFeedbackGrid(cachedScore.roleSpecificFeedback, { allowLegacy: true });
              // ROLE TIPS LOCK: Don't restore if role tips are in-flight
              if (!isRoleTipsLocked()) {
                updateRoleTipsState({
                  hasAtsScore: true,
                  roleSpecificFeedback: cachedScore.roleSpecificFeedback || null
                });
              }
            } else {
              // ROLE TIPS LOCK: Don't restore if role tips are in-flight
              if (!isRoleTipsLocked()) {
                updateRoleTipsState({
                  hasAtsScore: !!cachedScore?.score,
                  roleSpecificFeedback: null
                });
              }
            }

            const fileNameSpan = document.getElementById('rf-file-name');
            const lastResumeName = localStorage.getItem('lastUploadedResumeName');
            if (lastResumeName && fileNameSpan) {
              fileNameSpan.textContent = lastResumeName + ' (please re-select file)';
              fileNameSpan.style.color = 'var(--color-text-muted)';
              fileNameSpan.style.fontWeight = 'normal';
              if (generateBtn) {
                generateBtn.disabled = false;
              }
            }
          }, {
            resumeId: cachedScore.resumeId,
            role: candidate.role
          });

          if (!applied) {
            console.log('[RESUME-FEEDBACK] Cached score ignored by authority', candidate);
          }
        }
      }
      
    function clearTargetRoleState() {
      const jobTitleInput = document.getElementById('rf-job-title');
      if (jobTitleInput) {
        jobTitleInput.value = '';
      }
      currentJobTitle = '';
      clearScoreAuthority('target-role-clear');
      try {
        sessionStorage.removeItem('currentJobTitle');
        localStorage.removeItem('jh_last_job_title');
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to clear job title state', e);
      }
    }

    // Expose for history interactions
    window.clearTargetRoleState = clearTargetRoleState;

    // Start Fresh on navigation (back/forward), page restore, and reloads
    function _cancelPendingSkeletonOperations() {
      try {
        // Invalidate any in-flight skeleton-related operations so callbacks don't run
        if (typeof skeletonOperationGeneration !== 'undefined') {
          skeletonOperationGeneration++;
        }

        // Clear any scheduled hide timeout and resolve pending hide resolvers as cancelled
        if (typeof skeletonHideTimeout !== 'undefined' && skeletonHideTimeout !== null) {
          clearTimeout(skeletonHideTimeout);
          skeletonHideTimeout = null;
        }
        if (Array.isArray(skeletonHideResolvers) && skeletonHideResolvers.length > 0) {
          skeletonHideResolvers.forEach(({ resolve, generation }) => {
            try { resolve({ generation, cancelled: true }); } catch (_) {}
          });
          skeletonHideResolvers = [];
        }

        // Immediately hide skeleton UI elements (no fade) to reflect the reset state
        const skeletonContainer = document.getElementById('rf-skeleton-container');
        if (skeletonContainer) {
          // Ensure child skeletons are not left in hidden state for future runs
          const skeletons = skeletonContainer.querySelectorAll('.rf-skeleton');
          skeletons.forEach(s => s.classList.remove('hidden'));
          skeletonContainer.style.display = 'none';
        }
        const skeletonHeader = document.getElementById('rf-skeleton-header');
        if (skeletonHeader) skeletonHeader.style.display = 'none';
        const skeletonRubric = document.getElementById('rf-skeleton-rubric');
        if (skeletonRubric) skeletonRubric.style.display = 'none';
        const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
        if (skeletonFeedback) skeletonFeedback.style.display = 'none';
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to cancel skeleton operations', e);
      }
    }

    // Toast / banner helpers for resume-feedback area
    window._rfToast = window._rfToast || {
      currentId: null,
      currentToast: null,
      activeRunId: null,   // sessionId for the user-started analysis currently considered "active"
      suppress: false      // set true when user loads history / clicks Start Fresh to prevent toasts
    };
    function showRfToast(type, title, opts = {}) {
      // type: 'info' | 'success' | 'error'
      const toastId = opts.id || `${type}:${title}`;
      if (window._rfToast.currentId === toastId) return; // dedupe identical toast
      // replace previous toast
      if (window._rfToast.currentToast && typeof window._rfToast.currentToast.dismiss === 'function') {
        try { window._rfToast.currentToast.dismiss(); } catch (e) { /* ignore */ }
      }
      if (!window.JobHackAIToast) return;
      
      // Determine numeric duration to pass to JobHackAIToast API
      const duration = (typeof opts.autoDismissMs === 'number') ? opts.autoDismissMs : 3000;
      
      const fn = type === 'success' ? window.JobHackAIToast.success : (
                   type === 'error' ? window.JobHackAIToast.error : window.JobHackAIToast.info);
      const toast = fn(title, duration);
      
      // Tag toast for debugging/lookup and wire our tracking/dedupe hooks
      if (toast && typeof toast === 'object') {
        try { toast.dataset = toast.dataset || {}; toast.dataset.rfId = toastId; } catch (e) { /* ignore */ }
      }
      
      // Store the activeRunId that was active when this toast was created
      // This prevents race conditions where an old toast's dismiss clears a new activeRunId
      const capturedActiveRunId = window._rfToast ? window._rfToast.activeRunId : null;
      
      window._rfToast.currentId = toastId;
      window._rfToast.currentToast = toast;
      
      // Clear tracking on dismiss - only if this toast is still the current toast
      // This prevents race conditions where a dismissed toast's callback fires after
      // a new toast has been shown, which would incorrectly clear the new toast's state
      if (toast && typeof toast.onDismiss === 'function') {
        // Capture toastId and toast reference in closure to check on callback
        const capturedToastId = toastId;
        const capturedToast = toast;
        toast.onDismiss(() => {
          // Only clear if this toast is still the current toast
          if (window._rfToast && window._rfToast.currentId === capturedToastId && window._rfToast.currentToast === capturedToast) {
            window._rfToast.currentId = null;
            window._rfToast.currentToast = null;
            // Clear activeRunId only if it still matches the run that created this toast
            // This prevents an old toast from clearing a new activeRunId when analyses complete in rapid succession
            if (capturedToastId === 'rf:analysis-finished' && window._rfToast.activeRunId === capturedActiveRunId) {
              window._rfToast.activeRunId = null;
            }
          }
        });
      } else {
        setTimeout(() => {
          // Only clear if this toast is still the current toast
          if (window._rfToast && window._rfToast.currentId === toastId && window._rfToast.currentToast === toast) {
            window._rfToast.currentId = null;
            window._rfToast.currentToast = null;
            // Clear activeRunId only if it still matches the run that created this toast
            // This prevents an old toast from clearing a new activeRunId when analyses complete in rapid succession
            if (toastId === 'rf:analysis-finished' && window._rfToast.activeRunId === capturedActiveRunId) {
              window._rfToast.activeRunId = null;
            }
          }
        }, (opts.autoDismissMs || 8000));
      }
    }

    // Insert a persistent session-restart banner when resetSession() intentionally runs
    function showSessionRestartBanner() {
      const existing = document.getElementById('rf-session-restart-banner');
      if (existing) {
        existing.style.display = 'flex';
        return;
      }
      const banner = document.createElement('div');
      banner.id = 'rf-session-restart-banner';
      banner.className = 'rf-banner rf-banner--warning';
      banner.innerHTML = `
        <div class="rf-banner__inner">
          <div class="rf-banner__icon">âš ï¸</div>
          <div class="rf-banner__content">
            <div class="rf-banner__title">Session restarted</div>
            <div class="rf-banner__desc">Your previous in-progress analysis was cleared. Upload your resume again or open Recent to view past results.</div>
          </div>
          <div class="rf-banner__actions">
            <button id="rf-session-restart-open-recent" class="rf-btn rf-btn--link">Open Recent</button>
            <button id="rf-session-restart-dismiss" class="rf-btn rf-btn--plain">Dismiss</button>
          </div>
        </div>
      `;
      const tile = document.getElementById('rf-ats-score-tile');
      const container = tile ? tile.parentNode : document.body;
      container.insertBefore(banner, tile || container.firstChild);
      const openBtn = document.getElementById('rf-session-restart-open-recent');
      if (openBtn) {
        openBtn.addEventListener('click', () => {
          if (window.JobHackAIHistory && typeof window.JobHackAIHistory.openSidebar === 'function') {
            window.JobHackAIHistory.openSidebar();
          }
        });
      }
      const dismissBtn = document.getElementById('rf-session-restart-dismiss');
      if (dismissBtn) {
        dismissBtn.addEventListener('click', () => { banner.style.display = 'none'; });
      }
    }

    window.addEventListener('pageshow', (event) => {
      // Cancel any pending skeleton operations always.
      // Only reset session on BFCache restores (event.persisted).
      _cancelPendingSkeletonOperations();
      if (event.persisted) {
        // Mark this as an automatic restore so a persistent banner is shown.
        resetSession(true);
      }
    });

    window.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        forceHideOverlays();
        // DO NOT call hideSkeletons() here - let them stay visible while tab is hidden
      } else {
        // PHASE 2: When tab becomes visible, preserve skeleton ONLY if role tips are actually in-flight
        // CRITICAL: Do NOT use persisted status - check in-flight flags and active token
        const activeToken = window.__rfActiveFeedbackToken;
        const isActuallyInFlight = window.roleTipsInFlight === true && 
                                    window.roleTipsInFlightToken === activeToken &&
                                    Boolean(activeToken);
        if (!isActuallyInFlight) {
          _cancelPendingSkeletonOperations();
        } else {
          // Role tips are actually in-flight - delegate to authoritative controller
          if (activeToken) updateRoleTipsState({ token: activeToken });
        }
        
        // Show a lightweight toast instead of resetting session. If analysis is running show running toast,
        // otherwise if finished while away show success toast. This preserves user progress and avoids surprising resets.
        try {
          // Determine running state by checking the page's feedback-loading guard.
          // We store a cleanup function in window._currentFeedbackLoading while an analysis is in progress.
          const isRunning = typeof window._currentFeedbackLoading === 'function';
          const finished = !!document.querySelector('#rf-feedback-content') && document.querySelector('#rf-feedback-content').style.display !== 'none';
          if (isRunning) {
            showRfToast('info', 'Analysis still running', {
              id: 'rf:analysis-running',
              actionText: 'View',
              onAction: () => { const tile = document.getElementById('rf-ats-score-tile'); if (tile) tile.scrollIntoView({ behavior: 'smooth', block: 'start' }); },
              autoDismissMs: 8000
            });
          } else if (finished && window._rfToast && window._rfToast.activeRunId && !window._rfToast.suppress) {
            // Show finished toast only if it matches an active run (and not suppressed)
            showRfToast('success', 'Analysis complete â€” View results', {
              id: 'rf:analysis-finished',
              actionText: 'View',
              onAction: () => { const tile = document.getElementById('rf-ats-score-tile'); if (tile) tile.scrollIntoView({ behavior: 'smooth', block: 'start' }); },
              autoDismissMs: 8000
            });
          }
        } catch (e) {
          console.warn('[RESUME-FEEDBACK] visibilitychange toast failed', e);
        }
      }
    });

    window.addEventListener('pagehide', () => {
      forceHideOverlays();
      clearTargetRoleState();
    });

    window.addEventListener('beforeunload', () => {
      clearTargetRoleState();
    });

      // Load cached score on page load
      loadCachedATSScore().then(() => {
        // PHASE 2: Restore role tips skeleton ONLY if actually in-flight
        // CRITICAL: Do NOT use persisted status alone - check in-flight flags and active token
        const activeToken = window.__rfActiveFeedbackToken;
        const isActuallyInFlight = window.roleTipsInFlight === true && 
                                    window.roleTipsInFlightToken === activeToken &&
                                    Boolean(activeToken);
        if (isActuallyInFlight) {
          // Delegate to authoritative controller instead of direct DOM manipulation
          if (activeToken) updateRoleTipsState({ token: activeToken });
        }

        // Check if we have resume data after loading
        const rubricScores = document.querySelectorAll('#rf-rubric-grid .rf-rubric-item .rf-rubric-score');
        const hasResumeData = rubricScores.length > 0 && Array.from(rubricScores).some(el => el.textContent !== 'â€” / â€”');
        
        if (!hasResumeData) {
          // Keep placeholder hidden to avoid duplicate empty-state copy
          const placeholder = document.getElementById('ats-placeholder');
          if (placeholder) placeholder.style.display = 'none';
          const regenBtn = document.getElementById('rf-regenerate-btn');
          if (regenBtn) regenBtn.style.display = 'none';
        }

        const optimizeBtn = document.getElementById('rf-optimize-btn');
        if (optimizeBtn) {
          optimizeBtn.addEventListener('click', async function() {
            const currentResumeId = sessionStorage.getItem('currentResumeId') || localStorage.getItem('jh_last_resume_id');
            if (!currentResumeId) {
              if (window.JobHackAIToast) {
                window.JobHackAIToast.error('Please upload a resume first');
              }
              return;
            }
            
            const canonicalJobTitle = getCanonicalJobTitle();
            
            try {
              showLoadingState('Optimizing for ATS complianceâ€¦');
              this.disabled = true;
              this.textContent = 'Optimizing...';
              
              const feedbackResult = await getResumeFeedbackWithAtsWait(currentResumeId, canonicalJobTitle, null);
              
              // Update history with new session (D1-backed)
              if (window.JobHackAIHistory && feedbackResult.sessionId) {
                window.JobHackAIHistory.addItem(feedbackResult.sessionId, feedbackResult.meta);
              }
              
              // Store latest feedback results for rewrite calls
              if (feedbackResult.atsIssues) {
                window.latestAtsIssues = feedbackResult.atsIssues;
              }
              if (feedbackResult.roleSpecificFeedback) {
                window.latestRoleSpecific = feedbackResult.roleSpecificFeedback;
                // Associate the stored tips with the active run token to avoid cross-run contamination
                window.latestRoleSpecificToken = feedbackRunToken || null;
              }
              
              updateFeedbackGrid(feedbackResult.roleSpecificFeedback);
              if (Array.isArray(feedbackResult.atsRubric)) {
                if (feedbackResult.atsRubric.length > 0) {
                  populateAtsRubric(feedbackResult.atsRubric);
                }
                hideATSSkeleton();
              }
              
              // CRITICAL: Ensure feedback content is visible after feedback is generated (Pro & Premium)
              const feedbackContentEl = document.getElementById('rf-feedback-content');
              const userPlanCheck = getCurrentUserPlan();
              if (feedbackContentEl && ['pro', 'premium'].includes(userPlanCheck)) {
                feedbackContentEl.style.display = 'block';
                console.log('[RESUME-FEEDBACK] Feedback content shown after optimize for:', userPlanCheck);
              }

              // Load cached score to check if ATS score exists
              let cachedScore = null;
              if (window.JobHackAIStatePersistence) {
                cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
              }
              
              const hasAtsScore = typeof cachedScore?.score === 'number';
              updateRoleTipsState({
                hasAtsScore,
                roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null
              });

              // Clear target role ONLY after a successful new analysis. History clicks must NOT change this input.
              const jobTitleInput = document.getElementById('rf-job-title');
              if (jobTitleInput) {
                jobTitleInput.value = '';
                currentJobTitle = '';
                markRoleValueChange('', 'optimize-role-clear');
              }

              // Refresh Last analyzed from D1 (guarded to avoid ReferenceError)
              if (typeof fetchLatestFeedbackFromD1 === 'function') {
                fetchLatestFeedbackFromD1();
              }
              
              // Save role-specific feedback without recalculating/persisting numeric ATS scores.
              // Numeric ATS scores are single-source and final: persisted only by /api/ats-score (via getAtsScore()).
              if (window.JobHackAIStatePersistence) {
                if (cachedScore && cachedScore.resumeId === currentResumeId) {
                  window.JobHackAIStatePersistence.saveATSScore({
                    ...cachedScore,
                    jobTitle: canonicalJobTitle || null,
                    roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null,
                    extractionQuality: cachedScore.extractionQuality
                  });
                }
              }
              
              // Show role feedback
              showRoleFeedback();
              
              if (window.JobHackAIToast) {
                window.JobHackAIToast.success('Feedback generated successfully!');
              }
              
              this.textContent = 'Optimize this resume';
              this.disabled = false;
              hideLoadingState();
            } catch (error) {
              handleApiError(error);
              this.textContent = 'Optimize this resume';
              this.disabled = false;
              hideLoadingState();
            }
          });
        }
      });

      function getCanonicalJobTitle() {
        const jobTitleInput = document.getElementById('rf-job-title');
        const trimmed = jobTitleInput?.value?.trim() || '';
        currentJobTitle = trimmed;
        return trimmed;
      }
      
      // Helper function to generate ATS score and feedback
      async function generateATSAndFeedback() {
        const uploadInput = document.getElementById('rf-upload');
        const file = uploadInput?.files[0];
        if (!file) {
          // Guard: always show pop-up if user clicks with no file
          // Check if user is on trial plan for trial-specific messaging
          const userPlan = getCurrentUserPlan();
          if (userPlan === 'trial') {
            // Show trial-specific popup
            if (window.showErrorModal) {
              window.showErrorModal('Upload Your Resume', 'Your trial includes 3 full ATS score & feedback runs. Upload your resume to get started and see how your resume performs!', {
                buttonText: 'Got it',
                onClose: null
              });
            } else {
              handleApiError(new Error('Please select a resume file first'));
            }
          } else {
            // Generic error for non-trial users
            handleApiError(new Error('Please select a resume file first'));
          }
          return;
        }

        const jobTitleInput = document.getElementById('rf-job-title');
        const canonicalJobTitle = getCanonicalJobTitle(); // Save final job title once per run
        
        // Save job title to state persistence (even if empty)
        if (window.JobHackAIStatePersistence) {
          // Pass current job title directly (empty string is valid and should be validated)
          // Only null should skip validation (page load scenario)
          const cachedScore = window.JobHackAIStatePersistence.loadATSScore(currentJobTitle ?? '');
          if (cachedScore) {
            window.JobHackAIStatePersistence.saveATSScore({
              ...cachedScore,
              jobTitle: currentJobTitle || null,
              extractionQuality: cachedScore.extractionQuality
            });
          }
        }

        const generateBtn = document.getElementById('rf-generate-btn');
        const statusDiv = document.getElementById('rf-generate-status');
        
        // Track whether ATS scoring succeeded (for credit restoration logic)
        let atsScoringSucceeded = false;
        
        try {
          generateBtn.disabled = true;
          if (statusDiv) {
            statusDiv.style.display = 'none';
          }
        showLoadingState('Analyzing your rÃ©sumÃ© for ATS criteriaâ€¦');
          uploadInput.disabled = true;

          // Check if we already have a resumeId for this file
          // IMPORTANT: Only reuse if file name AND size match to detect content changes
          // File size is a simple content check - if user edits resume, size likely changes
          const existingResumeId = sessionStorage.getItem('currentResumeId') || localStorage.getItem('jh_last_resume_id');
          const existingFileName = localStorage.getItem('lastUploadedResumeName');
          const existingFileSize = localStorage.getItem('lastUploadedResumeSize');
          const currentFileSize = file.size.toString();
          
          let uploadResult;
          if (existingResumeId && existingFileName === file.name && existingFileSize === currentFileSize) {
            // File name and size match - likely same file, reuse existing resumeId
            // CRITICAL: Still need to check and consume credit for free accounts even when reusing
            // This prevents free users from bypassing the limit by re-uploading the same file
            const userPlan = getCurrentUserPlan();
            if (userPlan === 'free') {
              const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
              let hasCredit = false;
              
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                if (creditsData) {
                  try {
                    const credits = JSON.parse(creditsData);
                    hasCredit = credits.ats_free_lifetime > 0;
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data (cached path):', e);
                    hasCredit = true; // Default to allowing for new users or corrupted data
                  }
                } else {
                  // No credits data means user hasn't used it yet - grant access
                  hasCredit = true;
                }
              } else {
                console.warn('[RESUME-FEEDBACK] No authenticated user found for free account check (cached path)');
                hasCredit = false;
              }
              
              // Also check freeAccountManager as fallback
              if (!hasCredit && window.freeAccountManager) {
                try {
                  const usageCheck = window.freeAccountManager.canUseATSScoring();
                  hasCredit = usageCheck.allowed;
                } catch (e) {
                  console.warn('[RESUME-FEEDBACK] Error checking free account manager (cached path):', e);
                  hasCredit = false;
                }
              }
              
              if (!hasCredit) {
                // Free account limit reached - show upgrade message
                uploadInput.disabled = false;
                // Only enable button if file still exists
                const fileStillExists = uploadInput?.files?.[0];
                if (generateBtn) {
                  generateBtn.disabled = !fileStillExists;
                }
                hideLoadingState();
                handleApiError(new Error('You have used your 1 free lifetime ATS score. Upgrade to continue scoring unlimited resumes.'));
                // Redirect to pricing page after showing error
                setTimeout(() => {
                  window.location.href = 'pricing-a.html?plan=essential';
                }, 2000);
                return;
              }
              
              // CRITICAL: Consume credit even when reusing cached resumeId
              // This prevents free users from bypassing the limit by re-uploading the same file
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                let credits = { ats_free_lifetime: 1 }; // Default for new users
                
                if (creditsData) {
                  try {
                    credits = JSON.parse(creditsData);
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data before consumption (cached path):', e);
                    credits = { ats_free_lifetime: 1 }; // Default to available on parse error
                  }
                }
                
                // Consume credit immediately (even for cached file reuse)
                credits.ats_free_lifetime = 0;
                localStorage.setItem(creditKey, JSON.stringify(credits));
                console.log('[RESUME-FEEDBACK] âœ… Free ATS credit consumed in localStorage (cached file reuse)');
              }
            }
            
            console.log('[RESUME-FEEDBACK] Reusing existing resumeId (name and size match):', existingResumeId);
            const existingResumeText = sessionStorage.getItem('currentResumeText');
            uploadResult = {
              success: true,
              resumeId: existingResumeId,
              resumeText: existingResumeText || undefined,
              textPreview: existingResumeText ? (existingResumeText.length > 200 ? existingResumeText.substring(0, 200) + '...' : existingResumeText) : undefined
            };
            currentResumeId = existingResumeId;
            // Ensure resumeId is in sessionStorage for consistency
            sessionStorage.setItem('currentResumeId', existingResumeId);
            // Update filename and size in localStorage to keep state consistent
            localStorage.setItem('lastUploadedResumeName', file.name);
            localStorage.setItem('lastUploadedResumeSize', currentFileSize);
          } else {
            // New file or file changed - check free account limits before upload
            const userPlan = getCurrentUserPlan();
            if (userPlan === 'free') {
              // Check if free account has remaining credit
              const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
              let hasCredit = false;
              
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                if (creditsData) {
                  try {
                    const credits = JSON.parse(creditsData);
                    hasCredit = credits.ats_free_lifetime > 0;
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data:', e);
                    // Default to allowing for new users or corrupted data
                    hasCredit = true;
                  }
                } else {
                  // No credits data means user hasn't used it yet - grant access
                  hasCredit = true;
                }
              } else {
                // No authenticated user - should not reach here due to access control, but handle gracefully
                console.warn('[RESUME-FEEDBACK] No authenticated user found for free account check');
                hasCredit = false;
              }
              
              // Also check freeAccountManager as fallback
              if (!hasCredit && window.freeAccountManager) {
                try {
                  const usageCheck = window.freeAccountManager.canUseATSScoring();
                  hasCredit = usageCheck.allowed;
                } catch (e) {
                  console.warn('[RESUME-FEEDBACK] Error checking free account manager:', e);
                  // If check fails, deny access to be safe
                  hasCredit = false;
                }
              }
              
              if (!hasCredit) {
                // Free account limit reached - show upgrade message
                uploadInput.disabled = false;
                // Only enable button if file still exists
                const fileStillExists = uploadInput?.files?.[0];
                if (generateBtn) {
                  generateBtn.disabled = !fileStillExists;
                }
                hideLoadingState();
                handleApiError(new Error('You have used your 1 free lifetime ATS score. Upgrade to continue scoring unlimited resumes.'));
                // Redirect to pricing page after showing error
                setTimeout(() => {
                  window.location.href = 'pricing-a.html?plan=essential';
                }, 2000);
                return;
              }
              
              // CRITICAL: Consume credit immediately after check passes to prevent multiple uploads
              // This prevents race conditions where multiple uploads could pass the check
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                let credits = { ats_free_lifetime: 1 }; // Default for new users
                
                if (creditsData) {
                  try {
                    credits = JSON.parse(creditsData);
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data before consumption:', e);
                    credits = { ats_free_lifetime: 1 }; // Default to available on parse error
                  }
                }
                
                // Consume credit immediately (before upload)
                credits.ats_free_lifetime = 0;
                localStorage.setItem(creditKey, JSON.stringify(credits));
                console.log('[RESUME-FEEDBACK] âœ… Free ATS credit consumed in localStorage (before upload)');
              }
            }
            
            // New file or file changed (name or size different), upload it
            // Store file name and size after determining we need to upload
            localStorage.setItem('lastUploadedResumeName', file.name);
            localStorage.setItem('lastUploadedResumeSize', currentFileSize);
            uploadResult = await uploadResume(file);
          }
          
          // CRITICAL: If upload failed, don't proceed to ATS scoring
          if (!uploadResult || !uploadResult.success || !uploadResult.resumeId) {
            // Restore credit if upload failed (for free accounts)
            const userPlan = getCurrentUserPlan();
            if (userPlan === 'free') {
              const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                let credits = { ats_free_lifetime: 1 }; // Default for new users
                
                if (creditsData) {
                  try {
                    credits = JSON.parse(creditsData);
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data during restoration:', e);
                    credits = { ats_free_lifetime: 1 }; // Default on parse error
                  }
                }
                
                // Restore only the ats_free_lifetime credit, preserving other credit types
                credits.ats_free_lifetime = 1;
                localStorage.setItem(creditKey, JSON.stringify(credits));
                console.log('[RESUME-FEEDBACK] âœ… Free ATS credit restored due to upload failure');
              }
            }
            
            // Error already shown by uploadResume, but we need to clean up UI state
            // Clean up any loading overlays
            if (window._currentFeedbackLoading) {
              window._currentFeedbackLoading();
              window._currentFeedbackLoading = null;
              // FIX: Restore role tips skeleton if still generating for this token
              const roleTipsStatus = getRoleTipsStatus();
              const activeToken = window.__rfActiveFeedbackToken;
              const isActuallyInFlight =
                window.roleTipsInFlight === true &&
                window.roleTipsInFlightToken === activeToken &&
                Boolean(activeToken);
              if (
                roleTipsStatus &&
                roleTipsStatus.status === 'generating' &&
                roleTipsStatus.token === feedbackRunToken &&
                isActuallyInFlight
              ) {
                updateRoleTipsState({
                  hasAtsScore: !!atsScoringSucceeded,
                  roleSpecificFeedback: null,
                  token: feedbackRunToken
                });
              }
            }
            uploadInput.disabled = false;
            // Only enable button if file still exists
            const fileStillExists = uploadInput?.files?.[0];
            if (generateBtn) {
              generateBtn.disabled = !fileStillExists;
            }
            hideLoadingState();
            return;
          }
          
          currentResumeId = uploadResult.resumeId;
          
          // Set active run ID for this generation to gate toast notifications
          // Use a timestamp-based ID that will be updated with sessionId when feedback completes
          if (window._rfToast) {
            window._rfToast.activeRunId = `run_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            window._rfToast.suppress = false;
          }
          
          // Clear previous feedback context when uploading a new resume
          // This prevents using feedback from the previous resume with the new one
          window.latestAtsIssues = null;
          window.latestRoleSpecific = null;
          window.latestRoleSpecificToken = null;

          // Step 1 complete: "Reading your resume..." overlay is already hidden by uploadResume()
          // Step 2: Show skeleton loading states instead of full-screen overlay
          // Free users only get ATS scoring, not AI feedback, so show different message
          const userPlan = getCurrentUserPlan();
          const willGetFeedback = ['trial', 'essential', 'pro', 'premium'].includes(userPlan);
          const hasRole = Boolean(canonicalJobTitle && canonicalJobTitle.trim().length > 0);
          
          // Ensure feedback token exists BEFORE showSkeletons runs
          const feedbackRunToken = createRunKey('feedback');
          setActiveFeedbackToken(feedbackRunToken);
          window.roleTipsInFlight = false;
          window.roleTipsInFlightToken = null;
          
          // mark Role Tips request as in-flight for this run BEFORE skeletons render
          if (willGetFeedback && hasRole) {
            window.roleTipsInFlight = true;
            window.roleTipsInFlightToken = feedbackRunToken;
            const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
            if (DEBUG_ROLE_TIPS) console.debug('[SKELETON-DEBUG] Flags set', {
              roleTipsInFlight: window.roleTipsInFlight,
              token: feedbackRunToken.substring(0, 8) + '...',
              willGetFeedback,
              hasRole
            });
          }
          
          // Show skeleton loading states (replaces full-screen overlay)
          // Only show role-specific skeleton if user has a plan AND provided a role
          showSkeletons(willGetFeedback, hasRole);
          if (willGetFeedback && hasRole) {
            setRoleStatus('Generating tipsâ€¦');
          } else {
            setRoleStatus('');
          }
          // Capture skeleton generation for this run to guard against stale callbacks
          const atsRequestGeneration = skeletonOperationGeneration;
          // Hide skeleton header since real progress header is already visible
          hideHeaderSkeleton();
          
          // PERFORMANCE FIX: Load original snippet immediately (don't wait for API)
          // This provides instant feedback to users while API processes in background
          if (userPlan === 'pro' || userPlan === 'premium') {
            const origBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[0];
            if (origBox) {
              // Show skeleton initially
              origBox.classList.add('rf-snippet-skeleton');
              
              // Load text immediately from sessionStorage or upload result
              const resumeText = sessionStorage.getItem('currentResumeText') || uploadResult.resumeText;
              if (resumeText && resumeText.length > 0) {
                // Clean up text for display
                let cleanText = resumeText.replace(/\s+/g, ' ').trim();
                
                if (cleanText.length > 0) {
                  // Use first 500 characters for snippet display
                  let snippet = cleanText.length > 500 ? cleanText.substring(0, 500) : cleanText;
                  const lastSpace = snippet.lastIndexOf(' ');
                  if (cleanText.length > 500 && lastSpace > 400) {
                    snippet = snippet.substring(0, lastSpace) + '...';
                  } else if (cleanText.length > 500) {
                    snippet = snippet + '...';
                  }
                  origBox.value = snippet;
                  // Remove skeleton after a brief delay to show it loaded
                  setTimeout(() => {
                    origBox.classList.remove('rf-snippet-skeleton');
                  }, 300);
                }
              }
            }
          }
          
          // Store cleanup function for error handling (skeleton hide function)
          window._currentFeedbackLoading = () => {
            hideSkeletons();
            hideATSSkeleton();
          };

          // Pre-flight trial limit check (before any API calls)
          if (userPlan === 'trial') {
            try {
              const token = await getAuthToken();
              const usageResponse = await fetch('/api/usage', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}`
                }
              });
              
              if (usageResponse.ok) {
                const usageData = await usageResponse.json();
                if (usageData.success && usageData.usage && usageData.usage.resumeFeedback) {
                  const feedbackUsed = usageData.usage.resumeFeedback.used || 0;
                  const feedbackLimit = usageData.usage.resumeFeedback.limit || 3;
                  
                  if (feedbackUsed >= feedbackLimit) {
                    // Show modal immediately, block all API calls
                    if (window.showErrorModal) {
                      window.showErrorModal(
                        'Trial Complete',
                        'You\'ve used all 3 feedback attempts. Upgrade to Pro for unlimited feedback and unlock all features.',
                        {
                          showUpgrade: true,
                          upgradeCallback: async () => {
                            try {
                          if (typeof window.upgradePlan === 'function') {
                            await window.upgradePlan('pro', {
                              source: 'resume-feedback',
                              returnUrl: window.location.href
                            });
                            return;
                          }
                          
                          const user = window.FirebaseAuthManager?.getCurrentUser?.();
                          const idToken = user ? await user.getIdToken() : null;
                          const confirmed = typeof window.requestUpgradeConfirmation === 'function'
                            ? await window.requestUpgradeConfirmation('pro', { mode: 'checkout', currentPlan: localStorage.getItem('user-plan') || 'free' })
                            : true;
                          if (!confirmed) {
                            return;
                          }
                          // Show loading state after confirmation
                          if (window.showLoadingOverlay) {
                            window._currentLoadingOverlay = window.showLoadingOverlay('Redirecting to checkout...');
                          }
                          const res = await fetch('/api/stripe-checkout', {
                            method: 'POST',
                            headers: { 
                              'Content-Type': 'application/json', 
                              ...(idToken ? { Authorization: `Bearer ${idToken}` } : {}) 
                                },
                                body: JSON.stringify({ plan: 'pro' })
                              });
                              const data = await res.json();
                              if (data && data.ok && data.url) {
                                window.location.href = data.url;
                                return;
                              }
                              throw new Error(data?.error || 'Checkout failed');
                            } catch (e) {
                              console.error('Upgrade checkout error:', e);
                              // Hide loading overlay
                              if (window._currentLoadingOverlay) {
                                window._currentLoadingOverlay();
                                window._currentLoadingOverlay = null;
                              }
                              // Fallback to pricing page if checkout fails
                              window.location.href = 'pricing-a.html';
                            }
                          },
                          upgradeButtonText: 'Upgrade to Pro',
                          buttonText: 'Maybe Later'
                        }
                      );
                    }
                    hideLoadingState();
                    if (typeof window._currentFeedbackLoading === 'function') {
                      window._currentFeedbackLoading();
                    }
                    window._currentFeedbackLoading = null;
                    setRoleStatus('');
                    clearActiveFeedbackToken();
                    uploadInput.disabled = false;
                    if (generateBtn) generateBtn.disabled = false;
                    if (window.roleTipsInFlightToken === feedbackRunToken) {
                      window.roleTipsInFlight = false;
                      window.roleTipsInFlightToken = null;
                    }
                    return; // Block all API calls
                  }
                }
              }
            } catch (usageError) {
              console.warn('[RESUME-FEEDBACK] Usage check failed, proceeding with caution:', usageError);
              // Continue if usage check fails (non-blocking)
            }
          }

          // --- PARALLEL API CALLS: ATS Score + Feedback ---
          const canonicalJobTitleForApis = canonicalJobTitle;
          
          // FIX: Seed role tips status IMMEDIATELY at run start (before any API calls)
          // Use the same role string that will be sent to /api/role-tips
          const hasRoleForTips = canonicalJobTitleForApis && canonicalJobTitleForApis.trim().length > 0;
          const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
          if (hasRoleForTips) {
            setRoleTipsStatus(feedbackRunToken, 'generating');
            updateRoleTipsState({ token: feedbackRunToken });
            if (DEBUG_ROLE_TIPS) console.debug('[SKELETON-DEBUG] Status set to generating', {
              token: feedbackRunToken.substring(0, 8) + '...',
              status: getRoleTipsStatus()?.status
            });
            if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Start generating', { token: feedbackRunToken.substring(0, 8) + '...', hasRole: true });
            // Show skeleton immediately
            showRoleFeedback();
          } else {
            // FIX: Do NOT clear status when no role - only clear on explicit reset actions
            // Status will remain from previous run, which is fine for UI consistency
            if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Start (no role, status preserved)', { token: feedbackRunToken.substring(0, 8) + '...', hasRole: false, existingStatus: getRoleTipsStatus()?.status });
          }
          
          // Track role tips promises to prevent premature token clearing
          let roleTipsPromise = null;
          let retryRoleTipsPromise = null;
          
          // Helper: Only clear token if role tips aren't in-flight
          // Uses closure state (roleTipsPromise/retryRoleTipsPromise) as source of truth
          function maybeClearFeedbackToken(reason) {
            if (!isActiveFeedbackToken(feedbackRunToken)) return;
            // If role tips were started (or retry started), token must remain active until those promises settle.
            if (roleTipsPromise || retryRoleTipsPromise) {
              return;
            }
            clearActiveFeedbackToken();
          }

          // Start both API calls in parallel (ATS handles the numeric score)
          const atsPromise = getAtsScore(uploadResult.resumeId, canonicalJobTitleForApis);
          const feedbackPromise = (async () => {
            const plan = getCurrentUserPlan();
            if (['trial', 'essential', 'pro', 'premium'].includes(plan)) {
              return await getResumeFeedbackWithAtsWait(uploadResult.resumeId, canonicalJobTitleForApis, atsPromise);
            }
            return null; // Free plan doesn't get feedback
          })();

          // Handle ATS result immediately without waiting for feedback (progressive display)
          // This ensures ATS scores appear in 2-3s as claimed in the PR
          let atsSettled;
          let feedbackSettled;
          // Track whether we showed (or intended to show) the low-extraction warning toast for this run.
          // Used to suppress stacked success toasts in later combined ATS+tips messaging.
          let atsExtractionWarned = false;
          
          // Process ATS result as soon as it's available
          atsPromise
            .then((result) => {
              // ATS succeeded - update UI immediately
              atsScoringSucceeded = result.success && result.score !== undefined;
              
              if (atsScoringSucceeded) {
                const candidate = {
                  runKey: createRunKey('live'),
                  resumeId: uploadResult.resumeId,
                  role: canonicalJobTitleForApis,
                  score: result.score,
                  breakdown: result.breakdown,
                  source: 'live',
                  timestamp: Date.now()
                };
                const applied = attemptApplyScoreCandidate(
                  candidate,
                  () => {
                    sessionStorage.setItem('currentAtsScore', result.score.toString());
                    if (result.breakdown) {
                      sessionStorage.setItem('currentAtsBreakdown', JSON.stringify(result.breakdown));
                    }

                    let summary;
                    if (result.extractionQuality) {
                      const confidence = typeof result.extractionQuality.confidence === 'number' ? result.extractionQuality.confidence : 1.0;
                      const tokenCount = typeof result.extractionQuality.tokenCount === 'number' ? result.extractionQuality.tokenCount : 0;
                      const status = result.extractionQuality.extractionStatus || 'ok';
                      const isHighQuality = status === 'ok' && confidence >= 0.65 && tokenCount >= 80;

                      if (isHighQuality) {
                        summary = result.score > 85 ? 'Excellent! Your resume is highly ATS compatible.' :
                          result.score > 70 ? 'Your resume meets many ATS criteria and is likely to be noticed.' :
                          'Your resume needs improvement for better ATS results.';
                      } else {
                        summary = 'We may not have detected all sections in your resume. Consider checking formatting.';
                      }
                    } else {
                      summary = result.score > 85 ? 'Excellent! Your resume is highly ATS compatible.' :
                        result.score > 70 ? 'Your resume meets many ATS criteria and is likely to be noticed.' :
                        'Your resume needs improvement for better ATS results.';
                    }
                    // NOTE: Removed unscoped localStorage writes (lastATSScore, lastATSSummary) to prevent cross-user data leakage
                    // All ATS score data should be stored via user-scoped keys in JobHackAIStatePersistence.saveATSScore()

                    updateProgressRing(result.score);
                    updateExtractionQualityIndicator(result.extractionQuality);
                    hidePlaceholder();

                    const getScore = (value) => {
                      if (typeof value === 'number') return value;
                      if (value && typeof value === 'object' && typeof value.score === 'number') return value.score;
                      return 0;
                    };

                    const getFeedback = (value, feedbackArray, index) => {
                      if (value && typeof value === 'object') {
                        if (typeof value.feedback === 'string') {
                          return limitFeedbackToSentences(value.feedback);
                        }
                        if (typeof value.tip === 'string') {
                          return limitFeedbackToSentences(value.tip);
                        }
                      }
                      if (feedbackArray && Array.isArray(feedbackArray) && feedbackArray[index]) {
                        return limitFeedbackToSentences(feedbackArray[index]);
                      }
                      return '';
                    };

                    // PHASE 4: Do NOT render rubric with rule-based text here
                    // Wait for structured AI feedback from /api/resume-feedback
                    // applyFeedbackTipsToRubric will render the rubric when AI feedback is ready
                    // This prevents "raw text flash" before structured content
                    
                    // Store scores for later use (if needed for fallback)
                    window._pendingAtsScores = {
                      score: result.score,
                      breakdown: result.breakdown
                    };

                    // PHASE 4: Keep rubric skeleton visible until structured AI feedback arrives
                    // Do NOT hide rubric skeleton here - applyFeedbackTipsToRubric will hide it when rendering
                    const skeletonHeader = document.getElementById('rf-skeleton-header');
                    if (skeletonHeader) skeletonHeader.style.display = 'none';
                    
                    // Hide only the ATS score skeleton (progress ring), keep rubric skeleton
                    // Rubric skeleton will be hidden by applyFeedbackTipsToRubric when structured data is ready

                    const feedbackContentEl = document.getElementById('rf-feedback-content');
                    if (feedbackContentEl) {
                      feedbackContentEl.style.display = 'block';
                    }

                    // PHASE 4: Do NOT show rubric grid yet - wait for structured AI feedback
                    // applyFeedbackTipsToRubric will show it when ready

                    setTimeout(() => {
                      showATSFeedback();
                    }, 100);

                    const warned = maybeWarnLowExtractionQuality(result.extractionQuality);
                    atsExtractionWarned = warned;
                    updateExtractionQualityIndicator(result.extractionQuality);
                    if (!warned && window.JobHackAIToast) {
                      window.JobHackAIToast.success('ATS score calculated successfully.');
                    }

                    // NOTE: ATS numeric score persistence is handled inside getAtsScore().
                  },
                  {
                    resumeId: uploadResult.resumeId,
                    role: canonicalJobTitleForApis
                  }
                );

                if (!applied) {
                  console.log('[RESUME-FEEDBACK] ATS score ignored by authority', candidate);
                }
              } else {
                // ATS scoring failed
                // Clean up feedback loading overlay (consistent with .catch() handler)
                if (window._currentFeedbackLoading) {
                  window._currentFeedbackLoading();
                  window._currentFeedbackLoading = null;
                }
                // Dismiss "Analysis still running" toast if it exists
                if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
                  try {
                    if (typeof window._rfToast.currentToast.dismiss === 'function') {
                      window._rfToast.currentToast.dismiss();
                    }
                  } catch (e) { /* ignore */ }
                }
                handleApiError(new Error('Failed to calculate ATS score. Please try again.'));
              }
            })
            .catch((error) => {
              // ATS promise rejected
              console.error('[RESUME-FEEDBACK] ATS scoring failed:', error);
              // Clean up feedback loading overlay
              if (window._currentFeedbackLoading) {
                window._currentFeedbackLoading();
                window._currentFeedbackLoading = null;
              }
              // Dismiss "Analysis still running" toast if it exists
              if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
                try {
                  if (typeof window._rfToast.currentToast.dismiss === 'function') {
                    window._rfToast.currentToast.dismiss();
                  }
                } catch (e) { /* ignore */ }
              }
              handleApiError(error);
            });

          // Wait for both promises to settle (for error handling and final state)
          [atsSettled, feedbackSettled] = await Promise.allSettled([atsPromise, feedbackPromise]);
          
          // --- Process ATS Result (for error handling and state management) ---
          // Note: UI updates already happened in the .then() above for progressive display
          // This block is only for state management and error handling
          let scoreResult = null;
          if (atsSettled.status === 'fulfilled') {
            scoreResult = atsSettled.value;
            // atsScoringSucceeded already set in .then() handler above
          } else {
            // ATS promise rejected - error already handled in .catch() above
          }

          // --- Process Feedback Result (show when ready) ---
          if (feedbackSettled.status === 'fulfilled' && feedbackSettled.value) {
            const feedbackResult = feedbackSettled.value;
            if (!isActiveFeedbackToken(feedbackRunToken)) {
              console.warn('[RESUME-FEEDBACK] Stale feedback response ignored (token mismatch).');
              // If the active token has been cleared (e.g. user reset or role change),
              // perform UI cleanup so the user isn't left with disabled controls or loading overlays.
              if (!window.__rfActiveFeedbackToken) {
                try {
                  if (window._currentFeedbackLoading) {
                    try { window._currentFeedbackLoading(); } catch (e) { /* ignore */ }
                    window._currentFeedbackLoading = null;
                  }
                  if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
                    try { if (typeof window._rfToast.currentToast.dismiss === 'function') window._rfToast.currentToast.dismiss(); } catch (e) { /* ignore */ }
                  }
                  const generateBtn = document.getElementById('rf-generate-btn');
                  if (generateBtn) generateBtn.disabled = false;
                  const regenBtn = document.getElementById('rf-regenerate-btn');
                  if (regenBtn) { regenBtn.disabled = false; regenBtn.textContent = 'Regenerate Feedback'; }
                  try { hideLoadingState(); } catch (e) { /* ignore */ }
                } catch (cleanupErr) {
                  console.warn('[RESUME-FEEDBACK] Cleanup after stale feedback ignored failed', cleanupErr);
                }
              }
              return;
            } else {
              // roleTipsPromise already declared at function scope
              try {
                // Update activeRunId with sessionId if available (for proper toast gating)
                if (window._rfToast && feedbackResult.sessionId) {
                  window._rfToast.activeRunId = feedbackResult.sessionId;
                }
                
                // Update history with new session (D1-backed)
                if (window.JobHackAIHistory && feedbackResult.sessionId) {
                  window.JobHackAIHistory.addItem(feedbackResult.sessionId, feedbackResult.meta);
                }
                
                if (feedbackResult.atsIssues) {
                  window.latestAtsIssues = feedbackResult.atsIssues;
                }

                // PHASE 2: Tier 1 does not include roleSpecificFeedback (it's null)
                // Role tips will be fetched separately asynchronously
                const feedbackGrid = document.getElementById('rf-feedback-grid');
                if (feedbackGrid) {
                  feedbackGrid.innerHTML = '';
                  if (feedbackGrid.dataset) {
                    delete feedbackGrid.dataset.placeholder;
                  }
                }

                // PHASE 4: Only render rubric when AI structured feedback is ready
                // Do not render rule-based text first - wait for structured data
                if (Array.isArray(feedbackResult.atsRubric)) {
                  if (feedbackResult.atsRubric.length > 0) {
                    populateAtsRubric(feedbackResult.atsRubric);
                  }
                  hideATSSkeleton();
                }
                const hasAtsScore = !!(atsSettled.status === 'fulfilled' && atsSettled.value && atsSettled.value.success);
                const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
                const skeletonEl = document.getElementById('rf-skeleton-feedback');
                const skeletonDisplay = skeletonEl ? skeletonEl.style.display : 'not found';
                const roleTipsStatus = getRoleTipsStatus();
                if (DEBUG_ROLE_TIPS) console.debug('[SKELETON-DEBUG] BEFORE hideFeedbackSkeleton()', {
                  flags: {
                    roleTipsInFlight: window.roleTipsInFlight,
                    roleTipsInFlightToken: window.roleTipsInFlightToken,
                    activeToken: window.__rfActiveFeedbackToken
                  },
                  status: roleTipsStatus ? {
                    status: roleTipsStatus.status,
                    token: roleTipsStatus.token?.substring(0, 8) + '...'
                  } : null,
                  skeletonCurrentDisplay: skeletonDisplay,
                  feedbackRunToken: feedbackRunToken.substring(0, 8) + '...',
                  hasRole: canonicalJobTitleForApis && canonicalJobTitleForApis.trim().length > 0
                });
                hideFeedbackSkeleton();
                if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] ATS done', { token: feedbackRunToken.substring(0, 8) + '...', hasAtsScore, roleTipsStatus: getRoleTipsStatus()?.status });

                // PHASE 2: Fetch role tips asynchronously after Tier 1 completes
                // D2: Pass sessionId from Tier 1 response to role tips endpoint
                const hasRole = canonicalJobTitleForApis && canonicalJobTitleForApis.trim().length > 0;
                if (hasRole) {
                  // FIX: Status already set at run start - just update UI with ATS score
                  // Force show role feedback container immediately (not dependent on ATS score)
                  showRoleFeedback();
                  // Don't pass roleSpecificFeedback: null here - updateRoleTipsState will detect 'generating' status
                  // and show skeleton without resetting/hiding the UI
                  updateRoleTipsState({
                    hasAtsScore,
                    token: feedbackRunToken
                  });
                  if (DEBUG_ROLE_TIPS) console.debug('[SKELETON-DEBUG] AFTER updateRoleTipsState()', {
                    token: feedbackRunToken.substring(0, 8) + '...',
                    hasAtsScore,
                    skeletonDisplay: document.getElementById('rf-skeleton-feedback')?.style.display,
                    status: getRoleTipsStatus()?.status
                  });
                  
                  // Start role tips fetch in background (non-blocking)
                  // Use feedbackSessionId for role-tips endpoint (expects feedback_sessions.id), fallback to null if not available
                  const tier1SessionId = feedbackResult.feedbackSessionId || null;
                  let roleTipsResult = null; // Track updated result with role tips for persistence
                  roleTipsPromise = getRoleTips(uploadResult.resumeId, canonicalJobTitleForApis, feedbackRunToken, tier1SessionId)
                    .then((roleTips) => {
                      // PHASE 2: Token-gate: only update if token is still active
                      if (!isActiveFeedbackToken(feedbackRunToken)) {
                        console.warn('[RESUME-FEEDBACK] Stale role tips update ignored (token mismatch)');
                        return;
                      }

                      if (roleTips) {
                        window.latestRoleSpecific = roleTips;
                        window.latestRoleSpecificToken = feedbackRunToken;
                        updateFeedbackGrid(roleTips, { token: feedbackRunToken });
                        const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
                        const sectionCount = roleTips?.sections?.length || (Array.isArray(roleTips) ? roleTips.length : 0);
                        if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Response handled', { token: feedbackRunToken.substring(0, 8) + '...', status: 'ready', sectionCount, hasAtsScore });
                        updateRoleTipsState({
                          hasAtsScore,
                          roleSpecificFeedback: roleTips,
                          token: feedbackRunToken
                        });
                        // Architectural rule: UI visibility is NOT token-gated; only data/state mutations are gated.
                        // showRoleFeedback() is called unconditionally to ensure container visibility even if
                        // updateRoleTipsState() returned early due to token check (which protects against stale data).
                        showRoleFeedback();
                        
                        // Token-gate state mutations only (not UI visibility)
                        if (isActiveFeedbackToken(feedbackRunToken)) {
                          // Normalize role tips shape: extract roleSpecificFeedback if nested, otherwise use roleTips directly
                          const roleSpecific = roleTips?.roleSpecificFeedback ?? roleTips ?? null;
                          roleTipsResult = {
                            ...feedbackResult,
                            roleSpecificFeedback: roleSpecific
                          };
                          
                          // FIX 2: Populate original snippet after analysis completes (for Pro/Premium users)
                          populateOriginalSnippetAfterAnalysis(uploadResult);
                        }
                      } else {
                        // Role tips failed or timed out - update state to failed
                        updateRoleTipsState({
                          hasAtsScore,
                          roleSpecificFeedback: null,
                          token: feedbackRunToken
                        });
                      }
                    })
                    .catch((error) => {
                      console.error('[RESUME-FEEDBACK] Role tips fetch error', error);
                      // Token-gate error handling
                      if (isActiveFeedbackToken(feedbackRunToken)) {
                        updateRoleTipsState({
                          hasAtsScore,
                          roleSpecificFeedback: null,
                          token: feedbackRunToken
                        });
                      }
                    })
                    .finally(() => {
                      // Persist feedback after role tips completes (success or failure)
                      // Use roleTipsResult if available (success with role tips), otherwise use feedbackResult (failure or no role tips)
                      if (isActiveFeedbackToken(feedbackRunToken)) {
                        persistRoleFeedbackIfPossible(roleTipsResult ?? feedbackResult);
                      }
                      
                      // Clear token only after role tips settles (success/failure/timeout)
                      // Only clear if this is still the active token (not overwritten by new run)
                      // Note: Token clearing is safe even after showRoleFeedback() since UI visibility is not token-gated
                      if (isActiveFeedbackToken(feedbackRunToken)) {
                        clearActiveFeedbackToken();
                      }
                    });
                } else {
                  // NO-ROLE path: Clear stale role tips UI when no role is specified
                  // Ensure role tips section does NOT show stale cards from a previous run
                  const feedbackGrid = document.getElementById('rf-feedback-grid');
                  if (feedbackGrid) {
                    feedbackGrid.innerHTML = '';
                    if (feedbackGrid.dataset) {
                      delete feedbackGrid.dataset.placeholder;
                    }
                  }
                  // FIX: Do NOT set status to 'idle' - let status remain until role tips completes or fails
                  // Only update UI state, status will be updated when role tips fetch completes
                  if (isActiveFeedbackToken(feedbackRunToken)) {
                    updateRoleTipsState({
                      hasAtsScore,
                      roleSpecificFeedback: null,
                      token: feedbackRunToken
                    });
                  }
                }

                const persistRoleFeedbackIfPossible = (updatedFeedbackResult = null) => {
                  if (!window.JobHackAIStatePersistence) return;
                  const cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
                  if (!cachedScore || cachedScore.resumeId !== uploadResult.resumeId) return;
                  const persistedJobTitle = canonicalJobTitle || cachedScore.jobTitle || null;
                  // Use updatedFeedbackResult if provided (for role tips), otherwise use feedbackResult
                  const resultToPersist = updatedFeedbackResult || feedbackResult;
                  // Guard: Never overwrite existing roleSpecificFeedback with null
                  const newRoleFeedback = resultToPersist?.roleSpecificFeedback;
                  const roleSpecificFeedback = (newRoleFeedback != null) 
                    ? newRoleFeedback 
                    : (cachedScore.roleSpecificFeedback != null ? cachedScore.roleSpecificFeedback : null);
                  window.JobHackAIStatePersistence.saveATSScore({
                    ...cachedScore,
                    jobTitle: persistedJobTitle,
                    roleSpecificFeedback: roleSpecificFeedback,
                    timestamp: Date.now()
                  });
                };

                // Persistence is handled by roleTipsPromise.finally() if role tips were started
                // If role tips never started (no hasRole), persist after ATS completes
                if (typeof atsPromise?.finally === 'function') {
                  atsPromise.finally(() => {
                    // Only persist if role tips didn't start (handles case where hasRole was false)
                    if (!roleTipsPromise) {
                      persistRoleFeedbackIfPossible();
                    }
                  });
                }

                setTimeout(() => {
                  showRoleFeedback();
                }, 100);

                // PHASE 2: Tier 1 doesn't include role tips, so only show ATS toast
                // Role tips toast will be shown when role tips complete (if they succeed)
                if (atsScoringSucceeded && !atsExtractionWarned && window.JobHackAIToast) {
                  window.JobHackAIToast.success('ATS score calculated successfully.');
                }
                setRoleStatus(''); // Clear status - role tips will update separately
              } catch (feedbackError) {
                console.error('[RESUME-FEEDBACK] Error processing feedback result:', feedbackError);
                
                updateRoleTipsState({
                  hasAtsScore: !!atsScoringSucceeded,
                  roleSpecificFeedback: null,
                  token: feedbackRunToken
                });
              }
              
              // Clear feedback token only if role tips was not started
              // If role tips was started, it will clear the token in its .finally() handler
              maybeClearFeedbackToken('no-role-tips-started');
            }
          } else if (feedbackSettled.status === 'rejected') {
            const error = feedbackSettled.reason;
            if (isFeedbackNotReadyError(error)) {
              console.warn('[RESUME-FEEDBACK] Feedback still processing - keeping skeleton.', error);
              
              // Set UI to "waiting_on_ats" state BEFORE any async work
              const hasRole = canonicalJobTitleForApis && canonicalJobTitleForApis.length > 0;
              if (hasRole) {
                showSkeletons(true, true);
                setRoleStatus('Waiting for ATS score to finishâ€¦');
                const roleContainer = document.getElementById('role-feedback-container');
                if (roleContainer) {
                  roleContainer.style.display = 'block';
                }
              }
              
              // Ensure UI cleanup so user isn't left stuck while feedback is processing server-side.
              try {
                // Dismiss any loading handlers/overlays
                if (window._currentFeedbackLoading) {
                  try { window._currentFeedbackLoading(); } catch (e) { /* ignore */ }
                  window._currentFeedbackLoading = null;
                }
                // Dismiss analysis-running toast if present
                if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
                  try { if (typeof window._rfToast.currentToast.dismiss === 'function') window._rfToast.currentToast.dismiss(); } catch (e) { /* ignore */ }
                }
                // Hide any loading overlays
                try { hideLoadingState(); } catch (e) { /* ignore */ }
                // NOTE: Do NOT re-enable buttons here - wait until retry completes to prevent concurrent operations
              } catch (cleanupErr) {
                console.warn('[RESUME-FEEDBACK] Cleanup after not-ready error failed', cleanupErr);
              }
              
              // Do ONE bounded retry after ATS resolves (if still pending)
              try {
                // Ensure ATS is complete before retry
                if (atsPromise && typeof atsPromise.then === 'function') {
                  try {
                    await atsPromise;
                  } catch (_) {
                    // ATS failure handled elsewhere
                  }
                }
                // Brief backoff for D1 write propagation
                await _rfSleep(1000);
                
                // Single retry attempt
                const retryResult = await getResumeFeedback(uploadResult.resumeId, canonicalJobTitleForApis);
                if (retryResult && isActiveFeedbackToken(feedbackRunToken)) {
                  // Success - update UI
                if (retryResult.roleSpecificFeedback) {
                    window.latestRoleSpecific = retryResult.roleSpecificFeedback;
                    window.latestRoleSpecificToken = feedbackRunToken || null;
                  }
                  if (retryResult.atsIssues) {
                    window.latestAtsIssues = retryResult.atsIssues;
                  }
                  // PHASE 2: Retry result also has roleSpecificFeedback: null (Tier 1)
                  if (Array.isArray(retryResult.atsRubric)) {
                    if (retryResult.atsRubric.length > 0) {
                      populateAtsRubric(retryResult.atsRubric);
                    }
                    hideATSSkeleton();
                  }
                  hideFeedbackSkeleton();
                  const hasAtsScore = !!(atsSettled.status === 'fulfilled' && atsSettled.value && atsSettled.value.success);
                  updateRoleTipsState({
                    hasAtsScore,
                    roleSpecificFeedback: null,  // PHASE 2: Tier 1 doesn't include role tips
                    token: feedbackRunToken
                  });

                  // PHASE 2: Fetch role tips asynchronously after retry succeeds
                  // D2: Pass feedbackSessionId from retry result to role tips endpoint (expects feedback_sessions.id)
                  const hasRole = canonicalJobTitleForApis && canonicalJobTitleForApis.trim().length > 0;
                  // retryRoleTipsPromise already declared at function scope
                  if (hasRole) {
                    // Force show role feedback container immediately when starting role tips fetch
                    showRoleFeedback();
                    const retrySessionId = retryResult.feedbackSessionId || null;
                    retryRoleTipsPromise = getRoleTips(uploadResult.resumeId, canonicalJobTitleForApis, feedbackRunToken, retrySessionId)
                      .then((roleTips) => {
                        if (!isActiveFeedbackToken(feedbackRunToken)) {
                          return;
                        }
                        if (roleTips) {
                          window.latestRoleSpecific = roleTips;
                          window.latestRoleSpecificToken = feedbackRunToken;
                          updateFeedbackGrid(roleTips, { token: feedbackRunToken });
                          updateRoleTipsState({
                            hasAtsScore,
                            roleSpecificFeedback: roleTips,
                            token: feedbackRunToken
                          });
                          // Architectural rule: UI visibility is NOT token-gated; only data/state mutations are gated.
                          // showRoleFeedback() is called unconditionally to ensure container visibility even if
                          // updateRoleTipsState() returned early due to token check (which protects against stale data).
                          showRoleFeedback();
                          
                          // Token-gate persistence and state mutations only (not UI visibility)
                          if (isActiveFeedbackToken(feedbackRunToken)) {
                            // Normalize role tips shape: extract roleSpecificFeedback if nested, otherwise use roleTips directly
                            const roleSpecific = roleTips?.roleSpecificFeedback ?? roleTips ?? null;
                            const updatedFeedbackResult = {
                              ...retryResult,
                              roleSpecificFeedback: roleSpecific
                            };
                            persistRoleFeedbackIfPossible(updatedFeedbackResult);
                            
                            // FIX 2: Populate original snippet after analysis completes (for Pro/Premium users)
                            populateOriginalSnippetAfterAnalysis(uploadResult);
                          }
                        } else {
                          // Role tips returned null - update state to failed
                          if (isActiveFeedbackToken(feedbackRunToken)) {
                            updateRoleTipsState({
                              hasAtsScore,
                              roleSpecificFeedback: null,
                              token: feedbackRunToken
                            });
                          }
                        }
                      })
                      .catch((error) => {
                        console.error('[RESUME-FEEDBACK] Role tips fetch error in retry', error);
                        // Update state to failed on error
                        if (isActiveFeedbackToken(feedbackRunToken)) {
                          updateRoleTipsState({
                            hasAtsScore,
                            roleSpecificFeedback: null,
                            token: feedbackRunToken
                          });
                        }
                      })
                      .finally(() => {
                        // Clear token only after role tips settles (success/failure/timeout)
                        // Only clear if this is still the active token (not overwritten by new run)
                        // Note: Token clearing is safe even after showRoleFeedback() since UI visibility is not token-gated
                        if (isActiveFeedbackToken(feedbackRunToken)) {
                          clearActiveFeedbackToken();
                        }
                      });
                  }

                  if (atsScoringSucceeded && !atsExtractionWarned && window.JobHackAIToast) {
                    window.JobHackAIToast.success('ATS score calculated successfully.');
                  }
                  setRoleStatus('');
                  
                  // Persist role-specific feedback (same as normal fulfilled path)
                  const persistRoleFeedbackIfPossible = (updatedFeedbackResult = null) => {
                    if (!window.JobHackAIStatePersistence) return;
                    const cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
                    if (!cachedScore || cachedScore.resumeId !== uploadResult.resumeId) return;
                    const persistedJobTitle = canonicalJobTitleForApis || cachedScore.jobTitle || null;
                    // Use updatedFeedbackResult if provided (for role tips), otherwise use retryResult
                    const resultToPersist = updatedFeedbackResult || retryResult;
                    // Guard: Never overwrite existing roleSpecificFeedback with null
                    const newRoleFeedback = resultToPersist?.roleSpecificFeedback;
                    const roleSpecificFeedback = (newRoleFeedback != null) 
                      ? newRoleFeedback 
                      : (cachedScore.roleSpecificFeedback != null ? cachedScore.roleSpecificFeedback : null);
                    window.JobHackAIStatePersistence.saveATSScore({
                      ...cachedScore,
                      jobTitle: persistedJobTitle,
                      roleSpecificFeedback: roleSpecificFeedback,
                      timestamp: Date.now()
                    });
                  };
                  persistRoleFeedbackIfPossible();
                  if (typeof atsPromise?.finally === 'function') {
                    atsPromise.finally(persistRoleFeedbackIfPossible);
                  }
                  
                  setTimeout(() => {
                    showRoleFeedback();
                  }, 100);
                  // Re-enable buttons now that retry completed successfully
                const generateBtn = document.getElementById('rf-generate-btn');
                if (generateBtn) generateBtn.disabled = false;
                const regenBtn = document.getElementById('rf-regenerate-btn');
                if (regenBtn) { regenBtn.disabled = false; regenBtn.textContent = 'Regenerate Feedback'; }
                  // Clear token only if role tips was not started
                  // If role tips was started, it will clear the token in its .finally() handler
                  maybeClearFeedbackToken('retry-no-role-tips-started');
                  return;
                } else {
                  // Retry completed but either:
                  // 1) retryResult is falsy (API returned null/undefined), OR
                  // 2) Token is no longer active (user started new run)
                  if (isActiveFeedbackToken(feedbackRunToken)) {
                    // Case 1: Retry returned falsy result but token still active
                    // Clean up UI and show error state
                    hideFeedbackSkeleton();
                    setRoleStatus('Role tips unavailable. Try regenerating feedback.');
                    const hasAtsScore = !!(atsSettled.status === 'fulfilled' && atsSettled.value && atsSettled.value.success);
                    updateRoleTipsState({
                      hasAtsScore,
                      roleSpecificFeedback: null,
                      token: feedbackRunToken
                    });
                    // Re-enable buttons
                    const generateBtn = document.getElementById('rf-generate-btn');
                    if (generateBtn) generateBtn.disabled = false;
                    const regenBtn = document.getElementById('rf-regenerate-btn');
                    if (regenBtn) { regenBtn.disabled = false; regenBtn.textContent = 'Regenerate Feedback'; }
                    maybeClearFeedbackToken('retry-falsy-result');
                  } else {
                    // Case 2: Token is stale (user started new run)
                    // Clean up skeleton/status we showed for this stale run, but don't touch role tips state or token
                    // This prevents UI from being stuck while avoiding interference with the new run
                    hideFeedbackSkeleton();
                    setRoleStatus('');
                    // Do NOT update role tips state, re-enable buttons, or clear token - new run is active
                  }
                  return;
                }
              } catch (retryError) {
                // Retry failed - show clear non-stuck message only if this run is still active
                if (isActiveFeedbackToken(feedbackRunToken)) {
                  console.warn('[RESUME-FEEDBACK] Retry after ATS wait failed:', retryError);
                  setRoleStatus('Role tips unavailable. Try regenerating feedback.');
                  const hasAtsScore = !!(atsSettled.status === 'fulfilled' && atsSettled.value && atsSettled.value.success);
                  updateRoleTipsState({
                    hasAtsScore,
                    roleSpecificFeedback: null,
                    token: feedbackRunToken
                  });
                  // Re-enable buttons after retry failure
                  const generateBtn = document.getElementById('rf-generate-btn');
                  if (generateBtn) generateBtn.disabled = false;
                  const regenBtn = document.getElementById('rf-regenerate-btn');
                  if (regenBtn) { regenBtn.disabled = false; regenBtn.textContent = 'Regenerate Feedback'; }
                  // Only clear token if this is still the active run and role tips aren't in-flight
                  maybeClearFeedbackToken('retry-catch-error');
                } else {
                  // Retry failed but token is no longer active (user started new run)
                  // Clean up UI state for this stale run
                  hideFeedbackSkeleton();
                  setRoleStatus('');
                  // Do NOT update role tips state or clear token - new run is active
                }
              }
              
              return;
            }

            console.warn('[RESUME-FEEDBACK] Feedback generation failed (non-blocking):', error);

            if (window.roleTipsInFlightToken === feedbackRunToken) {
              window.roleTipsInFlight = false;
              window.roleTipsInFlightToken = null;
            }
            setRoleTipsStatus(feedbackRunToken, 'failed');

            setRoleStatus('');

            updateRoleTipsState({
              hasAtsScore: !!atsScoringSucceeded,
              roleSpecificFeedback: null,
              token: feedbackRunToken
            });

            // Fallback: Render rubric from rule-based scores if available
            if (window._pendingAtsScores && window._pendingAtsScores.breakdown) {
              const breakdown = window._pendingAtsScores.breakdown;
              const getScore = (value) => {
                if (typeof value === 'number') return value;
                if (value && typeof value === 'object' && typeof value.score === 'number') return value.score;
                return 0;
              };
              const getMax = (value, category = '') => {
                if (value && typeof value === 'object' && typeof value.max === 'number') return value.max;
                // Category-aware fallback max values
                const cat = (category || '').toLowerCase();
                if (cat.includes('keyword')) return 40;
                if (cat.includes('format')) return 20;
                if (cat.includes('structure') || cat.includes('organization')) return 15;
                if (cat.includes('tone') || cat.includes('clarity')) return 15;
                if (cat.includes('grammar') || cat.includes('spelling')) return 10;
                return 10; // Default fallback
              };
              const getFeedback = (value) => {
                if (value && typeof value === 'object' && typeof value.feedback === 'string') {
                  return limitFeedbackToSentences(value.feedback);
                }
                return '';
              };
              const rubric = [
                {
                  label: 'Keyword Match',
                  score: getScore(breakdown.keywordScore),
                  max: ATS_RUBRIC_MAX.KEYWORD_RELEVANCE,
                  tip: getFeedback(breakdown.keywordScore)
                },
                {
                  label: 'ATS Formatting',
                  score: getScore(breakdown.formattingScore),
                  max: ATS_RUBRIC_MAX.FORMATTING_COMPLIANCE,
                  tip: getFeedback(breakdown.formattingScore)
                },
                {
                  label: 'Structure & Organization',
                  score: getScore(breakdown.structureScore),
                  max: ATS_RUBRIC_MAX.STRUCTURE_COMPLETENESS,
                  tip: getFeedback(breakdown.structureScore)
                },
                {
                  label: 'Tone & Clarity',
                  score: getScore(breakdown.toneScore),
                  max: ATS_RUBRIC_MAX.TONE_CLARITY,
                  tip: getFeedback(breakdown.toneScore)
                },
                {
                  label: 'Grammar & Spelling',
                  score: getScore(breakdown.grammarScore),
                  max: ATS_RUBRIC_MAX.GRAMMAR_SPELLING,
                  tip: getFeedback(breakdown.grammarScore)
                }
              ];
              updateRubricGrid(rubric);
              // Show rubric grid and hide skeleton (mirror applyFeedbackTipsToRubric behavior)
              const rubricGrid = document.getElementById('rf-rubric-grid');
              if (rubricGrid) rubricGrid.style.display = 'grid';
              const skeletonRubric = document.getElementById('rf-skeleton-rubric');
              if (skeletonRubric) skeletonRubric.style.display = 'none';
              hideFeedbackSkeleton();
              // FIX: Restore role tips skeleton if still generating for this token
              const roleTipsStatus = getRoleTipsStatus();
              const activeToken = window.__rfActiveFeedbackToken;
              const isActuallyInFlight =
                window.roleTipsInFlight === true &&
                window.roleTipsInFlightToken === activeToken &&
                Boolean(activeToken);
              if (
                roleTipsStatus &&
                roleTipsStatus.status === 'generating' &&
                roleTipsStatus.token === feedbackRunToken &&
                isActuallyInFlight
              ) {
                updateRoleTipsState({
                  hasAtsScore: !!atsScoringSucceeded,
                  roleSpecificFeedback: null,
                  token: feedbackRunToken
                });
              }
            }

            handleApiError(error, {
              title: 'Feedback Generation Failed',
              message: 'Failed to generate feedback. Your ATS score is still available.'
            });

            if (window._currentFeedbackLoading) {
              window._currentFeedbackLoading();
              window._currentFeedbackLoading = null;
              // FIX: Restore role tips skeleton if still generating for this token
              const roleTipsStatus = getRoleTipsStatus();
              const activeToken = window.__rfActiveFeedbackToken;
              const isActuallyInFlight =
                window.roleTipsInFlight === true &&
                window.roleTipsInFlightToken === activeToken &&
                Boolean(activeToken);
              if (
                roleTipsStatus &&
                roleTipsStatus.status === 'generating' &&
                roleTipsStatus.token === feedbackRunToken &&
                isActuallyInFlight
              ) {
                updateRoleTipsState({
                  hasAtsScore: !!atsScoringSucceeded,
                  roleSpecificFeedback: null,
                  token: feedbackRunToken
                });
              }
            }

            if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
              try {
                if (typeof window._rfToast.currentToast.dismiss === 'function') {
                  window._rfToast.currentToast.dismiss();
                }
              } catch (e) { /* ignore */ }
            }
            
            // Clear feedback token after error handling (but not for 409/not-ready errors)
            // Only clear if role tips aren't in-flight (role tips will clear token in its .finally() handler)
            maybeClearFeedbackToken('feedback-error-handling');
          } else {
            // Only hide role feedback if role tips aren't available and aren't generating
            // Role tips are fetched independently, so they might still be available even if feedback endpoint fails
            // ROLE TIPS LOCK: Check in-flight flag, not just persisted status
            const roleTipsStatus = getRoleTipsStatus();
            const isRoleTipsGenerating = isRoleTipsLocked() ||
                                        (roleTipsStatus && roleTipsStatus.status === 'generating' && 
                                         isActiveFeedbackToken(roleTipsStatus.token));
            const hasAvailableRoleTips = window.latestRoleSpecific && isValidRoleTips(window.latestRoleSpecific);
            
            // Don't hide if role tips are generating or already available
            if (!isRoleTipsGenerating && !hasAvailableRoleTips) {
              hideRoleFeedback();
            }
          }
          
          // Hide "Generating AI feedback..." overlay when both API calls complete
          if (window._currentFeedbackLoading) {
            window._currentFeedbackLoading();
            window._currentFeedbackLoading = null;
          }
          
          // Dismiss "Analysis still running" toast if it exists
          if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
            try {
              if (typeof window._rfToast.currentToast.dismiss === 'function') {
                window._rfToast.currentToast.dismiss();
              }
            } catch (e) { /* ignore */ }
          }
          
          // Show "Analysis complete" toast only when both ATS and feedback are complete (if feedback is expected)
          // If both ATS and feedback failed, error modals are already shown, so don't show misleading success toast
          // Gate toast by activeRunId to prevent showing for history loads or after Start Fresh
          const toastPlan = getCurrentUserPlan();
          const toastExpectsFeedback = ['trial', 'essential', 'pro', 'premium'].includes(toastPlan);
          const toastHasRole = canonicalJobTitleForApis && canonicalJobTitleForApis.length > 0;
          const feedbackExpected = toastExpectsFeedback && toastHasRole;
          const atsDone = atsScoringSucceeded;
          // Require feedback to be fulfilled AND have valid role-specific tips (same validation UI uses)
          const feedbackDone = feedbackSettled.status === 'fulfilled' && 
            feedbackSettled.value && 
            (feedbackExpected ? isValidRoleTips(feedbackSettled.value.roleSpecificFeedback) : true);
          const bothComplete = atsDone && (feedbackExpected ? feedbackDone : true);
          
          if (bothComplete && window._rfToast && window._rfToast.activeRunId && !window._rfToast.suppress) {
            showRfToast('success', 'Analysis complete â€” View results', {
              id: 'rf:analysis-finished',
              actionText: 'View',
              onAction: () => { const tile = document.getElementById('rf-ats-score-tile'); if (tile) tile.scrollIntoView({ behavior: 'smooth', block: 'start' }); },
              autoDismissMs: 8000
            });
          }
          
          // Both ATS scoring and feedback completed (successfully or with errors)

          // Update original snippet in rewrite section (only if not already loaded)
          // Use full resume text if available, otherwise use preview
          const origBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[0];
          if (origBox) {
            // Remove skeleton effect before populating text
            origBox.classList.remove('rf-skeleton', 'rf-snippet-skeleton');
            
            // Check if box is empty or still has placeholder/skeleton text
            const currentValue = origBox.value || '';
            const isEmptyOrPlaceholder = !currentValue || 
              currentValue.includes('Original resume excerpt') || 
              currentValue.includes('will appear here');
            
            // Always validate quality, even if box was pre-populated (performance fix)
            // This ensures pro/premium users see quality warnings for corrupted OCR text
            const resumeText = sessionStorage.getItem('currentResumeText') || uploadResult.resumeText;
            
            if (resumeText && resumeText.length > 0) {
              // Clean up text for display - remove excessive whitespace and ensure readability
              let cleanText = resumeText.replace(/\s+/g, ' ').trim();
              
              // Check if text became empty after cleaning (only whitespace was present)
              if (cleanText.length === 0) {
                // Text was only whitespace - show helpful message
                origBox.value = 'âš ï¸ No readable text could be extracted from this file. Please upload a text-based PDF or DOCX file.';
              } else {
                // Validate text quality - check for excessive non-alphanumeric characters (possible OCR corruption)
                // Only calculate ratio if cleanText has content to avoid division by zero
                const alphanumericRatio = cleanText.length > 0 
                  ? (cleanText.match(/[a-zA-Z0-9\s]/g) || []).length / cleanText.length 
                  : 0;
                
                if (alphanumericRatio < 0.7 && cleanText.length > 100) {
                  // Text appears corrupted - show warning message instead (overwrite pre-populated value if needed)
                  origBox.value = 'âš ï¸ Text extraction quality is low. For best results, please upload a text-based PDF or DOCX file.\n\nExtracted text preview:\n' + cleanText.substring(0, 200) + '...';
                } else if (isEmptyOrPlaceholder) {
                  // Only update if box was empty - don't overwrite pre-populated good-quality text
                  // Use first 500 characters for snippet display (more readable than 200)
                  // Ensure we don't cut in the middle of a word if possible
                  let snippet = cleanText.length > 500 ? cleanText.substring(0, 500) : cleanText;
                  const lastSpace = snippet.lastIndexOf(' ');
                  if (cleanText.length > 500 && lastSpace > 400) {
                    snippet = snippet.substring(0, lastSpace) + '...';
                  } else if (cleanText.length > 500) {
                    snippet = snippet + '...';
                  }
                  origBox.value = snippet;
                }
                // If box already has content (pre-populated) and quality is good, keep it
              }
            } else if (isEmptyOrPlaceholder) {
              // Only update placeholder if box was empty
              if (uploadResult.textPreview) {
                origBox.value = uploadResult.textPreview;
              } else {
                // If no text available, show placeholder
                origBox.value = 'Resume text will appear here after analysis.';
              }
            }
            // Ensure skeleton is removed regardless of whether we updated the value
            origBox.classList.remove('rf-skeleton', 'rf-snippet-skeleton');
          }

          /* Description update disabled to preserve plan-specific info matching Interview Questions UI */
          /*
          const descEl = document.getElementById('rf-header-desc');
          if (descEl && atsScoringSucceeded) {
            const existingTooltip = descEl.querySelector('.rf-tooltip-trigger');
            const tooltipHtml = existingTooltip ? existingTooltip.outerHTML : '';
            descEl.innerHTML = 'Your resume was analyzed. See your ATS score and feedback below.' + (tooltipHtml ? ' ' + tooltipHtml : '');
          }
          */

          uploadInput.disabled = false;
          // Only enable button if file still exists
          const fileStillExists = uploadInput?.files?.[0];
          if (generateBtn) {
            generateBtn.disabled = !fileStillExists;
          }
          hideLoadingState();
          
          // Refresh usage indicator after feedback completes (to show updated count)
          if (feedbackSettled.status === 'fulfilled' && feedbackSettled.value && typeof refreshUsageIndicator === 'function') {
            refreshUsageIndicator();
          }
          
          // Clear feedback token at end of Promise.allSettled processing
          // Only clear if role tips aren't in-flight (role tips will clear token in its .finally() handler)
          maybeClearFeedbackToken('promise-all-settled-complete');
        } catch (error) {
          // Restore credit ONLY if ATS scoring failed (not for post-scoring errors)
          // If scoring succeeded but UI/feedback generation failed, user already got value
          const userPlan = getCurrentUserPlan();
          if (userPlan === 'free' && !atsScoringSucceeded) {
            const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
            if (currentUser && currentUser.uid) {
              const creditKey = `creditsByUid:${currentUser.uid}`;
              const creditsData = localStorage.getItem(creditKey);
              let credits = { ats_free_lifetime: 1 }; // Default for new users
              
              if (creditsData) {
                try {
                  credits = JSON.parse(creditsData);
                } catch (e) {
                  console.warn('[RESUME-FEEDBACK] Failed to parse credits data during restoration:', e);
                  credits = { ats_free_lifetime: 1 }; // Default on parse error
                }
              }
              
              // Restore only the ats_free_lifetime credit, preserving other credit types
              credits.ats_free_lifetime = 1;
              localStorage.setItem(creditKey, JSON.stringify(credits));
              console.log('[RESUME-FEEDBACK] âœ… Free ATS credit restored due to scoring/upload failure');
            }
          } else if (userPlan === 'free' && atsScoringSucceeded) {
            // Log that credit is NOT restored because scoring succeeded
            console.log('[RESUME-FEEDBACK] âš ï¸ Error occurred but ATS scoring succeeded - credit NOT restored');
          }
          
          // Clear state on error
          // Clean up feedback loading overlay
          if (window._currentFeedbackLoading) {
            window._currentFeedbackLoading();
            window._currentFeedbackLoading = null;
          }
          // Dismiss "Analysis still running" toast if it exists
          if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
            try {
              if (typeof window._rfToast.currentToast.dismiss === 'function') {
                window._rfToast.currentToast.dismiss();
              }
            } catch (e) { /* ignore */ }
          }
          // Ensure token is cleared on unexpected errors so cached/legacy feedback can be shown
          // Only clear if role tips aren't in-flight (role tips will clear token in its .finally() handler)
          // Guard: maybeClearFeedbackToken is declared at line ~4391 inside this try block.
          // If an error is thrown before that line (e.g., uploadResume fails at line ~4114),
          // the function declaration is never executed. Function declarations inside blocks
          // have undefined hoisting behavior in non-strict mode - some browsers hoist them,
          // others don't. This guard handles both cases correctly.
          // Evidence: Users encountered "TypeError: maybeClearFeedbackToken is not a function"
          if (typeof maybeClearFeedbackToken === 'function') {
            maybeClearFeedbackToken('outer-catch-error');
          } else {
            // Fallback: directly clear token if the function isn't available
            // (error occurred before function declaration was reached)
            clearActiveFeedbackToken();
          }
          clearAtsState();
          handleApiError(error);
          uploadInput.disabled = false;
          // Only enable button if file still exists
          const fileStillExists = uploadInput?.files?.[0];
          if (generateBtn) {
            generateBtn.disabled = !fileStillExists;
          }
          hideLoadingState();
        }
      }

      // ATS Resume Upload Logic - Only update UI, don't trigger processing
      const uploadInput = document.getElementById('rf-upload');
      const fileNameSpan = document.getElementById('rf-file-name');
      const generateBtn = document.getElementById('rf-generate-btn');
      const statusDiv = document.getElementById('rf-generate-status');
      const startFreshBtn = document.getElementById('rf-start-fresh-btn');
      
      if (startFreshBtn) {
        startFreshBtn.addEventListener('click', function() {
          // User reset - suppress any pending analysis-toasts
          if (window._rfToast) {
            window._rfToast.activeRunId = null;
            window._rfToast.suppress = true;
            if (window._rfToast.currentToast && typeof window._rfToast.currentToast.dismiss === 'function') {
              try { window._rfToast.currentToast.dismiss(); } catch (e) { /* ignore */ }
            }
            window._rfToast.currentId = null;
            window._rfToast.currentToast = null;
          }
          resetSession();
        });
      }
      
      if (uploadInput) {
        uploadInput.addEventListener('change', async function(e) {
          const file = e.target.files[0];
          const pdfHelper = document.getElementById('rf-pdf-helper');
          clearScoreAuthority('resume-change');
          if (file) {
            // Hide status pill initially while validating
            hideFileStatus();
            
            // Track file type for conditional warning messages
            _rfLastUploadedFileType = file.type || (file.name.toLowerCase().endsWith('.pdf') ? 'application/pdf' : 
              file.name.toLowerCase().endsWith('.docx') ? 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' :
              file.name.toLowerCase().endsWith('.txt') ? 'text/plain' : null);

            // Show/hide PDF helper text based on file type
            if (pdfHelper) {
              if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                pdfHelper.style.display = 'block';
              } else {
                pdfHelper.style.display = 'none';
              }
            }
            
            // Validate file and show status pill
            try {
              const validation = await window.JobHackAIFileValidation.validateFile(file);
              
              if (!validation.valid) {
                // Invalid file - show error status
                showFileStatus('error', validation.error || 'File validation failed');
                if (fileNameSpan) {
                  fileNameSpan.textContent = file.name;
                  fileNameSpan.style.color = 'var(--color-error)';
                  fileNameSpan.style.fontWeight = '600';
                }
                if (generateBtn) {
                  generateBtn.disabled = true;
                }
                if (statusDiv) {
                  statusDiv.style.display = 'none';
                }
                return;
              }
              
              // Valid file - check for warnings
              if (validation.warning && validation.isScanned) {
                showFileStatus('warning', 'Scanned PDF detected â€“ may take longer');
              } else {
                showFileStatus('success', 'Ready to analyze');
              }
              
              // Preserve targeted role selection when uploading a resume
              // Don't clear job title input - user may want to analyze different resumes for the same role
              
              // Store file name in localStorage for persistence
              localStorage.setItem('lastUploadedResumeName', file.name);
              
              // Update file name display
              if (fileNameSpan) {
                fileNameSpan.textContent = file.name;
                fileNameSpan.style.color = 'var(--color-success)';
                fileNameSpan.style.fontWeight = '600';
              }
              
              // Enable generate button
              if (generateBtn) {
                generateBtn.disabled = false;
              }
              
              // Show ready status (legacy status div - keep for compatibility)
              if (statusDiv) {
                statusDiv.style.display = 'block';
                statusDiv.textContent = 'Ready to analyze';
                statusDiv.style.background = 'rgba(5,150,105,0.08)';
                statusDiv.style.color = 'var(--color-success)';
                statusDiv.style.width = 'fit-content';
                statusDiv.style.maxWidth = '100%';
              }
            } catch (validationError) {
              // Validation error - show error status
              console.error('[RESUME-FEEDBACK] File validation error:', validationError);
              showFileStatus('error', 'File validation failed');
              if (fileNameSpan) {
                fileNameSpan.textContent = file.name;
                fileNameSpan.style.color = 'var(--color-error)';
                fileNameSpan.style.fontWeight = '600';
              }
              if (generateBtn) {
                // Keep button clickable; validation failure is shown via status and name color
                // generateBtn.disabled = true;
              }
              if (statusDiv) {
                statusDiv.style.display = 'none';
              }
            }
          } else {
            // Reset if file cleared
            hideFileStatus();
            if (pdfHelper) {
              pdfHelper.style.display = 'none';
            }
            if (fileNameSpan) {
              fileNameSpan.textContent = 'No file selected';
              fileNameSpan.style.color = 'var(--color-text-muted)';
              fileNameSpan.style.fontWeight = 'normal';
            }
            // Leave generate button clickable; click guard will show modal if no file
            // if (generateBtn) {
            //   generateBtn.disabled = true;
            // }
            if (statusDiv) {
              statusDiv.style.display = 'none';
            }
            localStorage.removeItem('lastUploadedResumeName');
          }
        });
      }

      // Generate Button Click Handler
      if (generateBtn) {
        generateBtn.addEventListener('click', generateATSAndFeedback);
        
        // Enable button on page load - click guard will handle missing file
        // This ensures the popup works even when no file is selected
        generateBtn.disabled = false;
      }
      // Regenerate Feedback Button
      const regenBtn = document.getElementById('rf-regenerate-btn');
      if (regenBtn) {
        regenBtn.addEventListener('click', async function() {
          if (!currentResumeId) {
            handleApiError(new Error('Please upload a resume first'));
            return;
          }

          const jobTitleInput = document.getElementById('rf-job-title');
          const previousJobTitle = currentJobTitle || '';
          const canonicalJobTitle = getCanonicalJobTitle(); // Reuse the same normalized role

          // Check if we need to regenerate (resume changed or role changed)
          // If nothing changed, skip API call to save tokens
          if (window.JobHackAIStatePersistence) {
            const cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
            if (cachedScore && cachedScore.resumeId === currentResumeId) {
              const cachedJobTitle = (cachedScore.jobTitle || '').trim();
              const newJobTitle = (canonicalJobTitle || '').trim();
              
              // If resume and role haven't changed, and cached tips are valid, don't call API
              const cachedTips = cachedScore.roleSpecificFeedback;
              if (cachedJobTitle === newJobTitle && isValidRoleTips(cachedTips)) {
                console.log('[RESUME-FEEDBACK] Resume and role unchanged, skipping API call');
                if (window.JobHackAIToast) {
                  window.JobHackAIToast.info('No changes detected. Feedback is already up to date.');
                }
                return;
              }
            }
          }

          let scoreResult = null;
          let scoreUpdated = false;

          try {
            showLoadingState('Regenerating feedback...');
            this.disabled = true;
            this.textContent = 'Regenerating...';
            
            // Only show "Generating tips..." if user has a plan AND provided a role
            const userPlan = getCurrentUserPlan();
            const willGetFeedback = ['trial', 'essential', 'pro', 'premium'].includes(userPlan);
            const hasRole = canonicalJobTitle && canonicalJobTitle.trim().length > 0;
            if (willGetFeedback && hasRole) {
              setRoleStatus('Generating tipsâ€¦');
            } else {
              setRoleStatus('');
            }
            
            const roleChanged = previousJobTitle !== canonicalJobTitle;

            // Set active run ID for this regeneration to gate toast notifications
            if (window._rfToast) {
              window._rfToast.activeRunId = `run_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              window._rfToast.suppress = false;
            }

            // Start ATS (if role changed) and feedback in parallel
            const feedbackRunToken = createRunKey('feedback');
            setActiveFeedbackToken(feedbackRunToken);
            window.roleTipsInFlight = false;
            window.roleTipsInFlightToken = null;
            
            // mark Role Tips request as in-flight for this run BEFORE skeletons render
            if (willGetFeedback && hasRole) {
              window.roleTipsInFlight = true;
              window.roleTipsInFlightToken = feedbackRunToken;
            }
            
            // FIX: Seed role tips status IMMEDIATELY at run start (before any API calls)
            // Use the same role string that will be sent to /api/role-tips
            const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
            if (hasRole) {
              setRoleTipsStatus(feedbackRunToken, 'generating');
              updateRoleTipsState({ token: feedbackRunToken });
              if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Regenerate start generating', { token: feedbackRunToken.substring(0, 8) + '...', hasRole: true });
              // Show skeleton immediately
              showRoleFeedback();
            } else {
              // FIX: Do NOT clear status when no role - only clear on explicit reset actions
              if (DEBUG_ROLE_TIPS) console.debug('[ROLE_TIPS] Regenerate start (no role, status preserved)', { token: feedbackRunToken.substring(0, 8) + '...', hasRole: false, existingStatus: getRoleTipsStatus()?.status });
            }
            
            const atsPromise = roleChanged ? getAtsScore(currentResumeId, canonicalJobTitle) : Promise.resolve(null);
            const feedbackPromise = getResumeFeedbackWithAtsWait(currentResumeId, canonicalJobTitle, atsPromise);
            let roleAtsExtractionWarned = false;
            const [atsSettled, feedbackSettled] = await Promise.allSettled([atsPromise, feedbackPromise]);

            if (atsSettled.status === 'fulfilled' && atsSettled.value) {
              const possibleScore = atsSettled.value;
              if (possibleScore.success && possibleScore.score !== undefined && possibleScore.breakdown) {
                scoreResult = possibleScore;
                const candidate = {
                  runKey: createRunKey('live'),
                  resumeId: currentResumeId,
                  role: canonicalJobTitle,
                  score: possibleScore.score,
                  breakdown: possibleScore.breakdown,
                  source: 'live',
                  timestamp: Date.now()
                };
                const applied = attemptApplyScoreCandidate(
                  candidate,
                  () => {
                    scoreUpdated = true;
                    roleAtsExtractionWarned = maybeWarnLowExtractionQuality(possibleScore.extractionQuality);
                    updateProgressRing(scoreResult.score);
                    updateExtractionQualityIndicator(possibleScore.extractionQuality);
                    const rubric = [
                      {
                        label: 'Keyword Relevance',
                        score: scoreResult.breakdown.keywordScore?.score || 0,
                        max: ATS_RUBRIC_MAX.KEYWORD_RELEVANCE,
                        tip: limitFeedbackToSentences(scoreResult.breakdown.keywordScore?.feedback || '')
                      },
                      {
                        label: 'Formatting Compliance',
                        score: scoreResult.breakdown.formattingScore?.score || 0,
                        max: ATS_RUBRIC_MAX.FORMATTING_COMPLIANCE,
                        tip: limitFeedbackToSentences(scoreResult.breakdown.formattingScore?.feedback || '')
                      },
                      {
                        label: 'Structure & Section Completeness',
                        score: scoreResult.breakdown.structureScore?.score || 0,
                        max: ATS_RUBRIC_MAX.STRUCTURE_COMPLETENESS,
                        tip: limitFeedbackToSentences(scoreResult.breakdown.structureScore?.feedback || '')
                      },
                      {
                        label: 'Tone & Clarity',
                        score: scoreResult.breakdown.toneScore?.score || 0,
                        max: ATS_RUBRIC_MAX.TONE_CLARITY,
                        tip: limitFeedbackToSentences(scoreResult.breakdown.toneScore?.feedback || '')
                      },
                      {
                        label: 'Grammar & Spelling',
                        score: scoreResult.breakdown.grammarScore?.score || 0,
                        max: ATS_RUBRIC_MAX.GRAMMAR_SPELLING,
                        tip: limitFeedbackToSentences(scoreResult.breakdown.grammarScore?.feedback || ''),
                        flaggedTerms: scoreResult.breakdown.grammarScore?.flaggedTerms
                      }
                    ];
                    updateRubricGrid(rubric);
                    sessionStorage.setItem('currentAtsScore', scoreResult.score.toString());
                    sessionStorage.setItem('currentAtsBreakdown', JSON.stringify(scoreResult.breakdown));
                  },
                  {
                    resumeId: currentResumeId,
                    role: canonicalJobTitle
                  }
                );
                if (!applied) {
                  console.log('[RESUME-FEEDBACK] ATS score update ignored by authority', candidate);
                }
              } else {
                console.warn('[RESUME-FEEDBACK] ATS score update incomplete:', {
                  success: possibleScore?.success,
                  hasScore: possibleScore?.score !== undefined,
                  hasBreakdown: !!possibleScore?.breakdown
                });
              }
            } else if (atsSettled.status === 'rejected') {
              console.warn('[RESUME-FEEDBACK] Failed to update ATS score:', atsSettled.reason);
            }

            if (feedbackSettled.status !== 'fulfilled' || !feedbackSettled.value) {
              // Feedback failed - log but don't block (ATS score may be shown)
            const error = feedbackSettled.status === 'rejected' ? feedbackSettled.reason : new Error('No feedback result');
            if (isFeedbackNotReadyError(error)) {
              console.warn('[RESUME-FEEDBACK] Feedback still processing - keeping skeleton.', error);
              // Ensure UI cleanup so user isn't left stuck while feedback is processing server-side.
              try {
                if (window._currentFeedbackLoading) {
                  try { window._currentFeedbackLoading(); } catch (e) { /* ignore */ }
                  window._currentFeedbackLoading = null;
                }
                if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
                  try { if (typeof window._rfToast.currentToast.dismiss === 'function') window._rfToast.currentToast.dismiss(); } catch (e) { /* ignore */ }
                }
                const generateBtn = document.getElementById('rf-generate-btn');
                if (generateBtn) generateBtn.disabled = false;
                const regenBtn = document.getElementById('rf-regenerate-btn');
                if (regenBtn) { regenBtn.disabled = false; regenBtn.textContent = 'Regenerate Feedback'; }
                try { hideLoadingState(); } catch (e) { /* ignore */ }
                clearActiveFeedbackToken();
              } catch (cleanupErr) {
                console.warn('[RESUME-FEEDBACK] Cleanup after not-ready error failed', cleanupErr);
              }
              return;
            }
            console.warn('[RESUME-FEEDBACK] Feedback generation failed (non-blocking):', error);
              if (window.roleTipsInFlightToken === feedbackRunToken) {
                window.roleTipsInFlight = false;
                window.roleTipsInFlightToken = null;
              }
              setRoleTipsStatus(feedbackRunToken, 'failed');
              // Clear status - updateRoleTipsState will handle messaging and container visibility
              setRoleStatus(''); 

              // Load cached score to check if ATS score exists (to show helpful message)
              let cachedScore = null;
              if (window.JobHackAIStatePersistence) {
                cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
              }
              const hasAtsScore = !!(scoreResult?.success || cachedScore?.score);
              
              updateRoleTipsState({
                hasAtsScore,
                roleSpecificFeedback: null,
                token: feedbackRunToken
              });

              // Use handleApiError to check for upgradeRequired and show appropriate modal
              // For non-upgrade errors, show feedback-specific messaging
              handleApiError(error, {
                title: 'Feedback Generation Failed',
                message: 'Failed to generate feedback. Your ATS score is still available.'
              });
              this.textContent = 'Regenerate Feedback';
              this.disabled = false;
              hideLoadingState();
              
              // Clear feedback token after error handling (but not for 409/not-ready errors)
              clearActiveFeedbackToken();
              return;
            }

            const feedbackResult = feedbackSettled.value;
            if (!isActiveFeedbackToken(feedbackRunToken)) {
              console.warn('[RESUME-FEEDBACK] Stale regen feedback ignored (token mismatch).');
              // If the token was cleared (user reset/role change), ensure UI cleanup so controls aren't stuck.
              if (!window.__rfActiveFeedbackToken) {
                try {
                  if (window._currentFeedbackLoading) {
                    try { window._currentFeedbackLoading(); } catch (e) { /* ignore */ }
                    window._currentFeedbackLoading = null;
                  }
                  if (window._rfToast && window._rfToast.currentId === 'rf:analysis-running' && window._rfToast.currentToast) {
                    try { if (typeof window._rfToast.currentToast.dismiss === 'function') window._rfToast.currentToast.dismiss(); } catch (e) { /* ignore */ }
                  }
                  const generateBtn = document.getElementById('rf-generate-btn');
                  if (generateBtn) generateBtn.disabled = false;
                  const regenBtn = document.getElementById('rf-regenerate-btn');
                  if (regenBtn) { regenBtn.disabled = false; regenBtn.textContent = 'Regenerate Feedback'; }
                  try { hideLoadingState(); } catch (e) { /* ignore */ }
                } catch (cleanupErr) {
                  console.warn('[RESUME-FEEDBACK] Cleanup after stale regen feedback ignored failed', cleanupErr);
                }
              }
              return;
            } else {
              if (window._rfToast && feedbackResult.sessionId) {
                window._rfToast.activeRunId = feedbackResult.sessionId;
              }
              if (window.JobHackAIHistory && feedbackResult.sessionId) {
                window.JobHackAIHistory.addItem(feedbackResult.sessionId, feedbackResult.meta);
              }

              const feedbackGrid = document.getElementById('rf-feedback-grid');
              if (feedbackGrid) {
                feedbackGrid.innerHTML = '';
                if (feedbackGrid.dataset) {
                  delete feedbackGrid.dataset.placeholder;
                }
              }

              updateFeedbackGrid(feedbackResult.roleSpecificFeedback, { token: feedbackRunToken });
              if (Array.isArray(feedbackResult.atsRubric)) {
                if (feedbackResult.atsRubric.length > 0) {
                  populateAtsRubric(feedbackResult.atsRubric);
                }
                hideATSSkeleton();
              }

              const feedbackContentEl = document.getElementById('rf-feedback-content');
              const userPlanCheck = getCurrentUserPlan();
              if (feedbackContentEl && ['pro', 'premium'].includes(userPlanCheck)) {
                feedbackContentEl.style.display = 'block';
              }

              let cachedScore = null;
              if (window.JobHackAIStatePersistence) {
                cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
              }
              
              const hasAtsScore = !!(scoreResult?.success || cachedScore?.score);
                updateRoleTipsState({
                  hasAtsScore,
                  roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null,
                  token: feedbackRunToken
                });

              // FIX: Fetch role tips asynchronously after regenerate completes (mirror main path)
              if (hasRole) {
                const regenSessionId = feedbackResult.feedbackSessionId || null;
                getRoleTips(currentResumeId, canonicalJobTitle, feedbackRunToken, regenSessionId)
                  .then((roleTips) => {
                    // PHASE 2: Token-gate: only update if token is still active
                    if (!isActiveFeedbackToken(feedbackRunToken)) {
                      console.warn('[RESUME-FEEDBACK] Stale regen role tips update ignored (token mismatch)');
                      return;
                    }

                    if (roleTips) {
                      window.latestRoleSpecific = roleTips;
                      window.latestRoleSpecificToken = feedbackRunToken;
                      updateFeedbackGrid(roleTips, { token: feedbackRunToken });
                      // FIX: Update role tips state to hide skeleton and display content
                      updateRoleTipsState({
                        hasAtsScore,
                        roleSpecificFeedback: roleTips,
                        token: feedbackRunToken
                      });
                      // Architectural rule: UI visibility is NOT token-gated
                      showRoleFeedback();
                    }
                  })
                  .catch((error) => {
                    console.error('[RESUME-FEEDBACK] Regen role tips fetch error', error);
                    // FIX: Token-gate error handling and update state to show unavailable message
                    if (isActiveFeedbackToken(feedbackRunToken)) {
                      updateRoleTipsState({
                        hasAtsScore,
                        roleSpecificFeedback: null,
                        token: feedbackRunToken
                      });
                    }
                  })
                  .finally(() => {
                    // FIX: Persist regenerated role tips after fetch completes
                    if (isActiveFeedbackToken(feedbackRunToken)) {
                      const persistedFeedback = window.latestRoleSpecific ? {
                        ...feedbackResult,
                        roleSpecificFeedback: window.latestRoleSpecific
                      } : feedbackResult;
                      persistRoleFeedbackIfPossible(persistedFeedback);
                      
                      // FIX: Clear token after role tips completes (success or failure)
                      clearActiveFeedbackToken();
                    }
                  });
              }

            // Clear target role ONLY after a successful new analysis. History clicks must NOT change this input.
            const jobTitleInput = document.getElementById('rf-job-title');
            if (jobTitleInput) {
              jobTitleInput.value = '';
              currentJobTitle = '';
              lastNormalizedRoleValue = '';
            }

            // Refresh Last analyzed from D1 (guarded to avoid ReferenceError)
            if (typeof fetchLatestFeedbackFromD1 === 'function') {
              fetchLatestFeedbackFromD1();
            }

            // Refresh usage indicator to show updated count after a successful analysis
            if (typeof refreshUsageIndicator === 'function') {
              refreshUsageIndicator();
            }
            
            // Save role-specific feedback without touching the numeric ATS score
            if (window.JobHackAIStatePersistence) {
              const cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
              if (cachedScore && cachedScore.resumeId === currentResumeId) {
                const persistedJobTitle = canonicalJobTitle || cachedScore.jobTitle || null;
                window.JobHackAIStatePersistence.saveATSScore({
                  ...cachedScore,
                  jobTitle: persistedJobTitle,
                  roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null,
                  timestamp: Date.now()
                });
              }
            }
            
            // Clear feedback token after successful processing
            // Only clear if role tips aren't generating (role tips will clear token in its .finally() handler)
            const roleTipsStatus = getRoleTipsStatus();
            const isRoleTipsGenerating = roleTipsStatus && roleTipsStatus.status === 'generating' && 
                                        isActiveFeedbackToken(roleTipsStatus.token);
            if (!isRoleTipsGenerating) {
              clearActiveFeedbackToken();
            }
            }
        // Do NOT restore job title from cache; must be explicitly provided each run.

            const toastStatus = toastForAtsAndTips({
              atsOk: scoreUpdated,
              tips: feedbackResult.roleSpecificFeedback,
              // If we showed a low-extraction warning, avoid stacking a success toast on top.
              suppressSuccess: roleAtsExtractionWarned,
              token: feedbackRunToken
            });
            if (toastStatus === 'tips_ok' || toastStatus === 'tips_only') {
              setRoleStatus('Role-specific tips updated.');
            } else if (toastStatus === 'ats_only') {
              // Don't set status - let updateRoleTipsState handle the message in description area
              setRoleStatus(''); // Clear status, description area will show helpful message
            } else if (toastStatus === 'missing') {
              // Don't set status - let updateRoleTipsState handle the message in description area
              setRoleStatus(''); // Clear status, description area will show helpful message
            }

            this.textContent = 'Regenerate Feedback';
            this.disabled = false;
            hideLoadingState();
            
            // Clear feedback token at end of Promise.allSettled processing
            // Only clear if role tips aren't generating (role tips will clear token in its .finally() handler)
            const roleTipsStatus = getRoleTipsStatus();
            const isRoleTipsGenerating = roleTipsStatus && roleTipsStatus.status === 'generating' && 
                                        isActiveFeedbackToken(roleTipsStatus.token);
            if (!isRoleTipsGenerating) {
              clearActiveFeedbackToken();
            }
          } catch (error) {
            handleApiError(error);
            this.textContent = 'Regenerate Feedback';
            this.disabled = false;
            hideLoadingState();
            
            // Clear status - updateRoleTipsState will handle messaging and container visibility
            setRoleStatus(''); 
            
            // Load cached score to check if ATS score exists (to show helpful message)
            let cachedScore = null;
            if (window.JobHackAIStatePersistence) {
              cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
            }
            const hasAtsScore = !!(scoreResult?.success || cachedScore?.score);
            
            updateRoleTipsState({
              hasAtsScore,
              roleSpecificFeedback: null,
              token: feedbackRunToken
            });
          }
        });
      }
      // Initial attachment of button listeners
      attachRewriteButtonListeners();
    });

    // Helper function to limit feedback to 1-2 sentences (accessible globally)
    function limitFeedbackToSentences(text, maxSentences = 2) {
      if (!text || typeof text !== 'string') return '';
      const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
      if (sentences.length === 0) return '';
      const result = sentences.slice(0, maxSentences).join('. ').trim();
      // Always ensure a period at the end if there's content
      return result + (result.endsWith('.') ? '' : '.');
    }
    
    // Map old field names to new labels
    function updateProgressRing(score) {
      // Update SVG ring and text
      const svg = document.querySelector('#rf-ats-score-tile .rf-progress-ring svg');
      if (!svg) {
        console.warn('[RESUME-FEEDBACK] SVG not found for progress ring');
        return;
      }
      
      // FIX: Default to 0% if score is undefined or null (for new users)
      const hasResumeData = score !== undefined && score !== null;
      let displayScore = hasResumeData ? score : 0;
      if (!Number.isFinite(displayScore) || displayScore < 0 || displayScore > 100) {
        console.warn('[ATS-DONUT] Invalid score for donut', { score: displayScore });
        displayScore = 0;
      }
      
      // Always show progress ring (even at 0% for new users)
      const progressRing = document.querySelector('#rf-ats-score-tile .rf-progress-ring');
      if (progressRing) {
        progressRing.style.display = 'inline-block';
      }
      
      const circle = svg.querySelectorAll('circle')[1];
      if (!circle) {
        console.warn('[RESUME-FEEDBACK] Progress circle not found');
        return;
      }
      // FIX: Use displayScore instead of score to ensure 0% default works correctly
      const percent = Math.max(0, Math.min(100, displayScore));
      const radius = 36;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - (percent / 100) * circumference;
      
      // Ensure circle is visible and green (use direct color value for SVG compatibility)
      circle.setAttribute('stroke', '#00E676');
      circle.setAttribute('stroke-width', '8');
      circle.setAttribute('stroke-dasharray', String(circumference));
      circle.setAttribute('stroke-dashoffset', offset);
      circle.setAttribute('stroke-linecap', 'round');
      circle.setAttribute('fill', 'none');
      
      // Update text
      let text = svg.querySelector('text');
      if (!text) {
        text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '40');
        text.setAttribute('y', '48');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '1.6rem');
        text.setAttribute('font-weight', '700');
        text.setAttribute('fill', '#1F2937');
        svg.appendChild(text);
      }
      text.textContent = percent + '%';
      
      console.log('[RESUME-FEEDBACK] Updated progress ring to', percent + '%');
    }

    function normalizeRoleValue(value) {
      return (value || '').toString().trim().toLowerCase();
    }

    function getAuthorityRoleValue(override) {
      if (override && override.trim()) {
        return override.trim();
      }
      const jobTitleInput = document.getElementById('rf-job-title');
      return jobTitleInput?.value?.trim() || currentJobTitle || '';
    }

    function getAuthorityContext(candidate = {}, override = {}) {
      // Prefer the current UI state (resume + role) so stale responses are rejected
      // even when a previous candidate still supplies matching values.
      const resumeId = currentResumeId || override.resumeId || candidate.resumeId || null;
      const role =
        getAuthorityRoleValue() || override.role || candidate.role || '';
      return { resumeId, role };
    }

    function attemptApplyScoreCandidate(candidate, applyFn, contextOverride = {}) {
      if (!candidate || typeof candidate !== 'object') return false;
      const context = getAuthorityContext(candidate, contextOverride);
      const applied = tryApplyScore ? tryApplyScore(candidate, context) : true;
      if (!applied) return false;
      if (typeof applyFn === 'function') {
        applyFn();
      }
      return true;
    }

    // Feedback run authority token lifecycle:
    // - Set at the start of a generate/regenerate run
    // - Used to prevent stale or parallel async responses from mutating the UI
    // - Cleared when the run finishes (success or non-retryable error)
    // - Also cleared when score/role authority is reset (new resume, role change, reset)
    // IMPORTANT: Token must not persist after a run completes, or cached/legacy
    // feedback may be suppressed and duplicate renders may occur.
    // Feedback render authority token (prevents stale renders from overwriting the UI)
    let activeFeedbackRunToken = null;

    function setActiveFeedbackToken(token) {
      activeFeedbackRunToken = token;
      window.__rfActiveFeedbackToken = token;
    }

    function clearActiveFeedbackToken() {
      activeFeedbackRunToken = null;
      window.__rfActiveFeedbackToken = null;
    }

    function isActiveFeedbackToken(token) {
      if (!token) return false;
      return window.__rfActiveFeedbackToken && token === window.__rfActiveFeedbackToken;
    }

    // ROLE TIPS LOCK GUARD: Prevents mutations during in-flight generation
    function isRoleTipsLocked(token) {
      if (!token) token = window.__rfActiveFeedbackToken;
      return window.roleTipsInFlight === true &&
             window.roleTipsInFlightToken === token &&
             token === window.__rfActiveFeedbackToken &&
             Boolean(window.__rfActiveFeedbackToken);
    }

    function clearScoreAuthority(reason) {
      if (typeof clearRunAuthority === 'function') {
        clearRunAuthority();
      }
      updateProgressRing(0);
      const headerDesc = document.getElementById('rf-header-desc');
      const isHistoricalView = window.JobHackAIHistory?.isHistoricalView?.();
      if (headerDesc && !isHistoricalView) {
        headerDesc.textContent = 'Get your basic ATS compatibility score.';
      }
      resetAtsAndRoleUIToDefaults();
      setRoleStatus('');
      clearActiveFeedbackToken();
      if (reason && reason !== '' && runAuthorityDebug) {
        console.debug('[RUN-AUTHORITY] Cleared authority due to', reason);
      }
    }

    function createRunKey(prefix = 'run') {
      if (window.crypto && typeof window.crypto.randomUUID === 'function') {
        return window.crypto.randomUUID();
      }
      return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    }

    lastNormalizedRoleValue = normalizeRoleValue(getAuthorityRoleValue());

    function markRoleValueChange(newValue, reason = 'role-change') {
      const normalized = normalizeRoleValue(newValue);
      if (normalized === lastNormalizedRoleValue) return;
      lastNormalizedRoleValue = normalized;
      clearScoreAuthority(reason);
    }

    // Helper function to escape HTML to prevent XSS (shared across functions)
    function escapeHtml(text) {
      if (typeof text !== 'string') return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Escape for use inside double-quoted HTML attribute values.
    // escapeHtml() does not escape double quotes, so we must.
    function escapeHtmlAttr(text) {
      return escapeHtml(text).replace(/"/g, '&quot;');
    }

    function formatRewriteChangeSummary(summary) {
      if (!summary) return '';
      if (typeof summary === 'string') return summary;
      if (Array.isArray(summary)) return summary.join('\n');
      if (typeof summary === 'object') {
        const lines = [];
        if (Array.isArray(summary.atsFixes) && summary.atsFixes.length > 0) {
          lines.push('ATS fixes:');
          summary.atsFixes.forEach(item => lines.push(`- ${item}`));
        }
        if (Array.isArray(summary.roleFixes) && summary.roleFixes.length > 0) {
          lines.push('Role fixes:');
          summary.roleFixes.forEach(item => lines.push(`- ${item}`));
        }
        return lines.join('\n');
      }
      return String(summary);
    }

    function isFeedbackNotReadyError(error) {
      if (!error) return false;
      if (error.status === 409) return true;
      const msg = String(error.message || '');
      // Match only exact phrases that explicitly indicate server-side processing,
      // avoid overly broad terms that could match unrelated failures.
      return /\b(?:not ready|still running|processing)\b/i.test(msg);
    }

    function updateRubricGrid(rubric) {
      const grid = document.getElementById('rf-rubric-grid');
      if (!grid) return;
      grid.innerHTML = '';
      if (grid.dataset) {
        delete grid.dataset.placeholder;
      }

      const formatTip = (item) => {
        const baseTip = item.tip || item.feedback || '';
        const flaggedTerms = Array.isArray(item.flaggedTerms)
          ? item.flaggedTerms.filter(Boolean)
          : [];
        if (!flaggedTerms.length) return baseTip;

        const displayTerms = flaggedTerms.slice(0, 6).join(', ');
        const note = `Flagged terms likely OK: ${displayTerms}.`;
        return baseTip ? `${baseTip} ${note}` : note;
      };

      rubric.forEach(item => {
        const div = document.createElement('div');
        div.className = 'rf-rubric-item';
        const normalizedLabel = (item.label || '').trim().toLowerCase();
        if (normalizedLabel) {
          div.dataset.category = normalizedLabel;
        }
        // Use â€” / â€” for empty scores
        const scoreDisplay = (item.score === undefined || item.score === null) ? 'â€” / â€”' : `${item.score} / ${item.max}`;
        const formattedTip = formatTip(item);
        const safeTip = escapeHtml(formattedTip);
        const safeTipAttr = escapeHtmlAttr(formattedTip);
        div.innerHTML = `
          <div class="rf-rubric-label">${escapeHtml(item.label)}</div>
          <div class="rf-rubric-score">${escapeHtml(scoreDisplay)}</div>
          <div class="rf-rubric-tip" data-rubric-tip data-base-tip="${safeTipAttr}" style="color:var(--color-text-secondary);font-size:0.98rem;">${safeTip}</div>
        `;
        grid.appendChild(div);
      });
    }

    // ATS numeric scoring is single-source; feedback only augments the textual tips.
    // PHASE 4: Render rubric only when structured AI feedback is ready (prevents raw text flash)
    function applyFeedbackTipsToRubric(atsRubric) {
      if (!atsRubric || !Array.isArray(atsRubric)) return;
      const grid = document.getElementById('rf-rubric-grid');
      if (!grid) return;
      
      // PHASE 4: If grid is empty, render full rubric with structured AI feedback
      // This ensures we never show rule-based raw text first
      const isGridEmpty = grid.innerHTML.trim() === '';
      
      if (isGridEmpty) {
        // Render rubric for the first time with structured AI feedback
        // Helper to get canonical max value from category label
        const getCanonicalMax = (categoryLabel) => {
          const label = (categoryLabel || '').toLowerCase();
          if (label.includes('keyword')) return ATS_RUBRIC_MAX.KEYWORD_RELEVANCE;
          if (label.includes('format')) return ATS_RUBRIC_MAX.FORMATTING_COMPLIANCE;
          if (label.includes('structure') || label.includes('section') || label.includes('organization')) return ATS_RUBRIC_MAX.STRUCTURE_COMPLETENESS;
          if (label.includes('tone') || label.includes('clarity')) return ATS_RUBRIC_MAX.TONE_CLARITY;
          if (label.includes('grammar') || label.includes('spelling')) return ATS_RUBRIC_MAX.GRAMMAR_SPELLING;
          return ATS_RUBRIC_MAX.GRAMMAR_SPELLING; // Default fallback
        };
        atsRubric.forEach(item => {
          const div = document.createElement('div');
          div.className = 'rf-rubric-item';
          const normalizedLabel = (item.category || item.label || '').trim().toLowerCase();
          if (normalizedLabel) {
            div.dataset.category = normalizedLabel;
          }
          const canonicalMax = getCanonicalMax(item.category || item.label);
          const scoreDisplay = (item.score === undefined || item.score === null) ? 'â€” / â€”' : `${item.score} / ${canonicalMax}`;
          const formattedTip = limitFeedbackToSentences(item.feedback || '');
          const safeTip = escapeHtml(formattedTip);
          const safeTipAttr = escapeHtmlAttr(formattedTip);
          const suggestions = Array.isArray(item.suggestions) ? item.suggestions.filter(Boolean) : [];
          const suggestionsHtml = suggestions.length > 0 
            ? `<ul style="margin-top:0.5rem;padding-left:1.25rem;color:var(--color-text-muted);font-size:0.9rem;">${suggestions.map(s => `<li>${escapeHtml(s)}</li>`).join('')}</ul>`
            : '';
          div.innerHTML = `
            <div class="rf-rubric-label">${escapeHtml(item.category || item.label || '')}</div>
            <div class="rf-rubric-score">${escapeHtml(scoreDisplay)}</div>
            <div class="rf-rubric-tip" data-rubric-tip data-base-tip="${safeTipAttr}" style="color:var(--color-text-secondary);font-size:0.98rem;">${safeTip}</div>
            ${suggestionsHtml}
          `;
          grid.appendChild(div);
        });
        // PHASE 4: Hide rubric skeleton now that structured content is rendered
        const skeletonRubric = document.getElementById('rf-skeleton-rubric');
        if (skeletonRubric) skeletonRubric.style.display = 'none';
        grid.style.display = 'grid';
        return; // Done - rubric rendered with structured data
      }
      
      // Grid already exists - update tips only (existing behavior)
      const normalizeLabel = (value) => (value || '').toLowerCase().trim();
      const pickRubricCard = (key) => {
        if (!key) return null;
        // First try exact match against the label-normalized data-category
        const escapedKey =
          (window.CSS && typeof window.CSS.escape === 'function')
            ? window.CSS.escape(key)
            : String(key).replace(/["\\\]\[]/g, '\\$&');
        let card = grid.querySelector(`.rf-rubric-item[data-category="${escapedKey}"]`);
        if (card) return card;

        // Fallback: fuzzy mapping between API category names and the rubric grid categories.
        const k = key;
        const tokens = [];
        if (k.includes('keyword')) tokens.push('keyword');
        if (k.includes('format')) tokens.push('format');
        if (k.includes('ats')) tokens.push('format'); // e.g., "ATS Formatting"
        if (k.includes('structure') || k.includes('section') || k.includes('organization') || k.includes('organis')) tokens.push('structure');
        if (k.includes('tone') || k.includes('clarity')) tokens.push('tone');
        if (k.includes('grammar') || k.includes('spelling')) tokens.push('grammar');

        const cards = Array.from(grid.querySelectorAll('.rf-rubric-item[data-category]'));
        for (const t of tokens) {
          const hit = cards.find((c) => {
            const cat = normalizeLabel(c.dataset.category);
            if (!cat) return false;
            if (t === 'structure') return cat.includes('structure') || cat.includes('section');
            if (t === 'tone') return cat.includes('tone') || cat.includes('clarity');
            if (t === 'grammar') return cat.includes('grammar') || cat.includes('spelling');
            return cat.includes(t);
          });
          if (hit) return hit;
        }
        return null;
      };
      atsRubric.forEach(item => {
        const key = normalizeLabel(item.category || item.label);
        if (!key) return;
        const card = pickRubricCard(key);
        if (!card) return;
        const tipEl = card.querySelector('[data-rubric-tip]');
        if (!tipEl) return;
        const baseTip = tipEl.dataset.baseTip || tipEl.textContent || '';
        const newTip = limitFeedbackToSentences(item.feedback || item.tip || '');
        const suggestions = Array.isArray(item.suggestions) ? item.suggestions.filter(Boolean) : [];
        const flaggedTerms = Array.isArray(item.flaggedTerms) ? item.flaggedTerms.filter(Boolean) : [];
        const extras = [];
        if (newTip) extras.push(newTip);
        if (suggestions.length) extras.push(`Suggestions: ${suggestions.join(', ')}`);
        if (flaggedTerms.length) extras.push(`Flagged terms likely OK: ${flaggedTerms.slice(0, 6).join(', ')}.`);
        const combined = [baseTip, ...extras].filter(Boolean).join(' ');
        tipEl.textContent = combined || baseTip;
      });
    }

    // Role-specific helpers (shared across generate, retry, regenerate, cached restore)
    function isValidRoleTips(roleSpecificFeedback) {
      if (!roleSpecificFeedback || typeof roleSpecificFeedback !== 'object') return false;
      // Legacy array format: treat non-empty array as valid
      if (Array.isArray(roleSpecificFeedback)) return roleSpecificFeedback.length > 0;
      // New format: object with sections array
      if (!Array.isArray(roleSpecificFeedback.sections)) return false;
      return roleSpecificFeedback.sections.length > 0;
    }

    function calculateAtsTipsToastStatus({ atsOk, tips }) {
      const validTips = isValidRoleTips(tips);
      if (validTips && atsOk) return 'tips_ok';
      if (validTips && !atsOk) return 'tips_only';
      if (!validTips && atsOk) return 'ats_only';
      return 'missing';
    }

    function toastForAtsAndTips({ atsOk, tips, suppressSuccess = false, token = null }) {
      const status = calculateAtsTipsToastStatus({ atsOk, tips });
      // If a token is provided, only show UI toasts when the token is still the active run.
      if (token && !isActiveFeedbackToken(token)) {
        return status;
      }
      if (!window.JobHackAIToast) return status;
      if (suppressSuccess) return status;
      if (status === 'tips_ok') {
        window.JobHackAIToast.success('ATS score and role-specific tips updated.');
      } else if (status === 'tips_only') {
        window.JobHackAIToast.success('Role-specific tips updated.');
      } else if (status === 'ats_only') {
        // Don't show toast - description area will show helpful message
        // Toast is redundant and confusing when tips are missing
      }
      return status;
    }

    // Trust-first: show a warning toast (once per short window) when extraction quality is low.
    // Uses existing JobHackAIToast (design system-consistent), and auto-dismisses after 8 seconds.
    let _rfLowExtractionWarnShownAt = 0;
    let _rfLastUploadedFileType = null; // Track file type for conditional messaging

    function maybeWarnLowExtractionQuality(extractionQuality) {
      if (!window.JobHackAIToast || !extractionQuality || typeof extractionQuality !== 'object') return false;
      const confidence = typeof extractionQuality.confidence === 'number' ? extractionQuality.confidence : 1.0;
      const tokenCount = typeof extractionQuality.tokenCount === 'number' ? extractionQuality.tokenCount : 0;
      const status = extractionQuality.extractionStatus || 'ok';
      // Keep frontend warning logic aligned with backend quality gating:
      // backend treats "high confidence" as: status === 'ok' AND confidence >= 0.65 AND tokenCount >= 80
      const isLow = status !== 'ok' || confidence < 0.65 || tokenCount < 80;
      if (!isLow) return false;

      // Avoid accidental duplicate toasts from overlapping async flows.
      const now = Date.now();
      if (now - _rfLowExtractionWarnShownAt < 1500) return true;
      _rfLowExtractionWarnShownAt = now;

      // Determine if uploaded file was PDF (only suggest DOCX/TXT for PDFs)
      const isPDF = _rfLastUploadedFileType === 'application/pdf' || 
                    (typeof _rfLastUploadedFileType === 'string' && _rfLastUploadedFileType.toLowerCase().includes('pdf'));

      // Build message conditionally based on file type
      let msg;
      if (status !== 'ok') {
        msg = isPDF
          ? 'We may not have read your resume perfectly. Some structure checks are less certainâ€”try uploading a DOCX or TXT for best results.'
          : 'We may not have read your resume perfectly. Some structure checks are less certain.';
      } else if (tokenCount > 0 && tokenCount < 80) {
        msg = isPDF
          ? 'We didn\'t get enough readable text from your resume to be fully confident. Some structure checks are less certainâ€”try uploading a DOCX or TXT for best results.'
          : 'We didn\'t get enough readable text from your resume to be fully confident. Some structure checks are less certain.';
      } else {
        msg = isPDF
          ? 'We may not have read your resume perfectly. Some structure checks are less certainâ€”try uploading a DOCX or TXT for best results.'
          : 'We may not have read your resume perfectly. Some structure checks are less certain.';
      }

      window.JobHackAIToast.warning(msg, 8000);
      return true;
    }

    function updateExtractionQualityIndicator(extractionQuality) {
      const indicator = document.getElementById('rf-extraction-quality-indicator');
      const iconEl = indicator?.querySelector('.rf-status-icon');
      const textEl = indicator?.querySelector('.rf-status-text');
      
      if (!indicator || !iconEl || !textEl) return;

      if (!extractionQuality || typeof extractionQuality !== 'object') {
        indicator.style.display = 'none';
        return;
      }

      const confidence = typeof extractionQuality.confidence === 'number' ? extractionQuality.confidence : 1.0;
      const tokenCount = typeof extractionQuality.tokenCount === 'number' ? extractionQuality.tokenCount : 0;
      const status = extractionQuality.extractionStatus || 'ok';
      
      // High confidence: status === 'ok' AND confidence >= 0.65 AND tokenCount >= 80
      const isHigh = status === 'ok' && confidence >= 0.65 && tokenCount >= 80;
      
      if (isHigh) {
        indicator.style.display = 'none';
        return;
      }

      // Determine variant and message
      let variant = 'warning';
      let message = '';
      
      if (status !== 'ok') {
        variant = 'error';
        message = 'Low Confidence';
      } else if (tokenCount < 80) {
        variant = 'warning';
        message = 'Limited Text';
      } else if (confidence < 0.65) {
        variant = 'warning';
        message = 'Low Confidence';
      }

      // Apply status pill styling (matches existing design system)
      indicator.className = `rf-status-pill rf-status-pill--${variant}`;
      indicator.style.display = 'inline-flex';
      indicator.style.width = '100%';
      indicator.style.justifyContent = 'center';
      indicator.style.marginTop = '0.5rem';
      indicator.style.flexShrink = '0';
      
      // Use SVG icon from existing system (not emoji)
      iconEl.innerHTML = getStatusIcon(variant);
      textEl.textContent = message;
    }

    function setRoleStatus(text) {
      const el = document.getElementById('rf-role-status');
      if (!el) return;
      if (text) {
        el.textContent = text;
        el.style.display = 'block';
      } else {
        el.textContent = '';
        el.style.display = 'none';
      }
    }

    function updateFeedbackGrid(roleSpecificFeedback, options = {}) {
      const { allowLegacy = false, token = null } = options;
      const grid = document.getElementById('rf-feedback-grid');
      if (!grid) return;
      if (token && !isActiveFeedbackToken(token)) return;

      const liveRunInProgress = Boolean(window.__rfActiveFeedbackToken);
      const isLegacyStringFormat =
        typeof roleSpecificFeedback === 'string' ||
        (Array.isArray(roleSpecificFeedback) && roleSpecificFeedback.every(item => typeof item === 'string'));

      if (isLegacyStringFormat && !allowLegacy && liveRunInProgress) {
        if (grid.dataset) {
          grid.dataset.placeholder = 'role-awaiting-structured';
        }
        grid.style.display = 'none';
        return;
      }

      // Distinguish new vs legacy formats to avoid crashing on arrays
      const isOldStructure = roleSpecificFeedback && Array.isArray(roleSpecificFeedback) && roleSpecificFeedback.length > 0;
      const isNewStructure = !Array.isArray(roleSpecificFeedback) && isValidRoleTips(roleSpecificFeedback);
      if (isOldStructure) {
        console.warn('[RESUME-FEEDBACK] Using legacy roleSpecificFeedback array format');
      }
      
      // Update section title and subtitle if new structure
      const roleTitleEl = document.getElementById('rf-role-title');
      const roleTitleTextEl = document.getElementById('rf-role-title-text');
      const roleDescEl = document.getElementById('rf-role-desc');
      
      if (isNewStructure && roleTitleTextEl) {
        roleTitleTextEl.textContent = 'Role-Specific Tailoring Tips';
        if (roleDescEl) {
          const targetRoleUsed = roleSpecificFeedback.targetRoleUsed || 'general';
          if (targetRoleUsed !== 'general') {
            roleDescEl.textContent = `How to tune your resume for ${targetRoleUsed} roles.`;
          } else {
            roleDescEl.textContent = 'Tell us your target role and weâ€™ll tailor the advice to what hiring managers expect.';
          }
        }
      }
      
      grid.innerHTML = '';
      
      if (!isNewStructure && !isOldStructure) {
        // Show placeholder cards
        const placeholderCards = [
          { section: 'Header & Contact', placeholder: 'Your rÃ©sumÃ© feedback will appear here once analyzed.' },
          { section: 'Professional Summary', placeholder: 'We\'ll review your summary and tone for keyword alignment.' },
          { section: 'Experience', placeholder: 'Experience feedback coming after your first analysis.' },
          { section: 'Skills', placeholder: 'We\'ll score your technical and soft skills once you upload.' },
          { section: 'Education', placeholder: 'Education section feedback appears here after analysis.' }
        ];
        
        placeholderCards.forEach(item => {
          const div = document.createElement('div');
          div.className = 'rf-feedback-card';
          div.innerHTML = `
            <div class="rf-feedback-label">${item.section}</div>
            <div class="rf-feedback-tip" style="color: var(--color-text-muted); font-style: italic;">${item.placeholder}</div>
          `;
          grid.appendChild(div);
        });
        // Ensure grid is visible after populating placeholder content
        grid.style.display = 'grid';
        return;
      }
      
      // Handle NEW structure with fitLevel, diagnosis, tips, rewritePreview
      if (isNewStructure) {
        // CRITICAL: Filter to only valid object sections to prevent blank "Tunable" cards
        const validSections = roleSpecificFeedback.sections.filter(section => {
          // Must be an object (not string, null, array, etc.)
          if (!section || typeof section !== 'object' || Array.isArray(section)) {
            return false;
          }
          
          // Must have at least one piece of meaningful content
          const hasDiagnosis = typeof section.diagnosis === 'string' && section.diagnosis.trim().length > 0;
          const hasTips = Array.isArray(section.tips) && section.tips.length > 0;
          const hasRewritePreview = typeof section.rewritePreview === 'string' && section.rewritePreview.trim().length > 0;
          
          return hasDiagnosis || hasTips || hasRewritePreview;
        });
        
        if (validSections.length === 0) {
          // Show helpful message instead of blank cards
          const messageDiv = document.createElement('div');
          messageDiv.className = 'rf-feedback-card';
          messageDiv.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 2rem;';
          messageDiv.innerHTML = `
            <div style="color: var(--color-text-muted); font-style: italic;">
              Role-specific tips couldn't be generated for this upload. Try uploading a PDF or re-running.
            </div>
          `;
          grid.appendChild(messageDiv);
          grid.style.display = 'grid';
          return;
        }
        
        validSections.forEach(section => {
          const div = document.createElement('div');
          div.className = 'rf-feedback-card';
          
          // Fit level chip styling
          let fitChipClass = 'rf-fit-chip-tunable';
          let fitChipText = 'Good but Tunable';
          if (section.fitLevel === 'big_impact') {
            fitChipClass = 'rf-fit-chip-big-impact';
            fitChipText = 'Big Impact Opportunity';
          } else if (section.fitLevel === 'strong') {
            fitChipClass = 'rf-fit-chip-strong';
            fitChipText = 'Strong Match';
          }
          
          // Build tips list (escape HTML to prevent XSS)
          const tipsHtml = section.tips && Array.isArray(section.tips) && section.tips.length > 0
            ? section.tips.map(tip => `<li>${escapeHtml(tip)}</li>`).join('')
            : '<li>No high-impact changes detected for this section.</li>';
          
          div.innerHTML = `
            <div class="rf-feedback-label" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
              <span>${escapeHtml(section.section || 'Section')}</span>
              <span class="${fitChipClass}" style="padding:0.25rem 0.75rem;border-radius:12px;font-size:0.75rem;font-weight:600;">${escapeHtml(fitChipText)}</span>
            </div>
            <div class="rf-feedback-diagnosis" style="color:var(--color-text-main);margin-bottom:0.75rem;font-weight:500;">${escapeHtml(section.diagnosis || '')}</div>
            <div class="rf-feedback-tips" style="margin-bottom:0.75rem;">
              <ul style="margin:0;padding-left:1.25rem;color:var(--color-text-secondary);">
                ${tipsHtml}
              </ul>
            </div>
            <div class="rf-rewrite-preview" style="margin-top:0.75rem;padding-top:0.75rem;border-top:1px solid var(--color-divider);">
              <div style="font-size:0.75rem;font-weight:600;color:var(--color-text-muted);margin-bottom:0.5rem;text-transform:uppercase;letter-spacing:0.5px;">AI Rewrite Preview</div>
              <div style="color:var(--color-text-secondary);font-style:italic;font-size:0.9rem;line-height:1.5;">${escapeHtml(section.rewritePreview || 'Preview not available')}</div>
            </div>
          `;
          grid.appendChild(div);
        });
        // Ensure grid is visible after populating (updateRoleTipsState will also set this, but ensure it's set here too)
        grid.style.display = 'grid';
        return;
      }
      
      // Handle OLD structure (backwards compatibility)
      if (isOldStructure) {
        // Filter to only valid objects (prevent rendering strings/nulls/etc.)
        const validItems = roleSpecificFeedback.filter(
          item => item && typeof item === 'object' && !Array.isArray(item)
        );
        
        if (validItems.length === 0) {
          // Show helpful message instead of blank cards
          const messageDiv = document.createElement('div');
          messageDiv.className = 'rf-feedback-card';
          messageDiv.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 2rem;';
          messageDiv.innerHTML = `
            <div style="color: var(--color-text-muted); font-style: italic;">
              Role-specific tips couldn't be generated for this upload. Try uploading a PDF or re-running.
            </div>
          `;
          grid.appendChild(messageDiv);
          grid.style.display = 'grid';
          return;
        }
        
        validItems.forEach(item => {
          const div = document.createElement('div');
          div.className = 'rf-feedback-card';
          const scoreDisplay = (item.score === undefined || item.score === null) ? 'â€” / â€”' : escapeHtml(item.score);
          div.innerHTML = `
            <div class="rf-feedback-label">${escapeHtml(item.section || item.label || 'Section')} <span class="rf-feedback-score">${scoreDisplay}</span></div>
            <div class="rf-feedback-tip">${escapeHtml(item.feedback || item.tip || '')}</div>
          `;
          grid.appendChild(div);
        });
        // Ensure grid is visible after populating (updateRoleTipsState will also set this, but ensure it's set here too)
        grid.style.display = 'grid';
        return;
      }
    }
    
    // Track consecutive role-tip failures to adjust messaging
    // Helper: control Role-Specific Tips state and retry button visibility
    function updateRoleTipsState({ hasAtsScore, roleSpecificFeedback, allowPlaceholder = false, token = null }) {
      // FIX: Use token matching instead of isActiveFeedbackToken() to avoid null/undefined issues
      // If token is provided, only proceed if status token matches (or no status exists)
      const roleTipsStatus = getRoleTipsStatus();
      // FIX: Allow proceeding when no status exists (or token matches)
      const tokenMatches = !token || !roleTipsStatus || roleTipsStatus.token === token;
      
      // FIX: No-role runs must clean up UI even with stale status
      // If roleSpecificFeedback is null and we have a token but status doesn't match, this is a no-role run
      // We should clean up stale UI from previous runs
      // ROLE TIPS LOCK: Don't clean up if role tips are in-flight for active token
      if (roleSpecificFeedback === null && token && roleTipsStatus && roleTipsStatus.token !== token) {
        // No-role run with stale status - clean up and exit ONLY if not in-flight
        if (!isRoleTipsLocked(token)) {
          const roleContainer = document.getElementById('role-feedback-container');
          const feedbackGrid = document.getElementById('rf-feedback-grid');
          const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
          const skeletonContainer = document.getElementById('rf-skeleton-container');
          if (skeletonContainer) skeletonContainer.style.display = 'none';
          if (skeletonFeedback) skeletonFeedback.style.display = 'none';
          if (feedbackGrid) feedbackGrid.style.display = 'none';
          if (roleContainer) roleContainer.style.display = 'none';
          setRoleStatus('');
        }
        return;
      }
      
      if (token && !tokenMatches) {
        // Stale run - don't mutate UI
        return;
      }
      
      const roleContainer = document.getElementById('role-feedback-container');
      const feedbackGrid = document.getElementById('rf-feedback-grid');
      const regenBtn = document.getElementById('rf-regenerate-btn');
      const roleDescEl = document.getElementById('rf-role-desc');
      const roleInfoBar = document.getElementById('rf-role-info');
      let roleBadge = document.getElementById('rf-role-badge');
      let roleHelper = document.getElementById('rf-role-helper');
      const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
      const skeletonContainer = document.getElementById('rf-skeleton-container');

      if (roleDescEl && !roleDescEl.dataset.baseText) {
        roleDescEl.dataset.baseText = roleDescEl.textContent || '';
      }

      // ROLE TIPS SKELETON FIX: Skeleton visibility based ONLY on in-flight flag, not cached status
      // INVARIANT: Skeleton may ONLY be visible during an active role-tips generation tied to the current feedback token.
      // Persisted or restored state must NEVER show a skeleton.
      // 
      // Skeleton visibility MUST require ALL of these:
      // 1. window.__rfActiveFeedbackToken to be truthy
      // 2. window.roleTipsInFlight === true
      // 3. window.roleTipsInFlightToken === window.__rfActiveFeedbackToken
      // 4. token passed to updateRoleTipsState === window.__rfActiveFeedbackToken
      //
      // If ANY of these are false â†’ skeleton MUST be hidden.
      const activeToken = window.__rfActiveFeedbackToken;
      
      // Explicitly check all 4 conditions - if token is null OR token !== activeToken, force isGenerating = false
      const hasActiveToken = Boolean(activeToken);
      const hasInFlightFlag = window.roleTipsInFlight === true;
      const inFlightTokenMatches = window.roleTipsInFlightToken === activeToken;
      const passedTokenMatches = token === activeToken;
      const hasValidToken = Boolean(token);
      
      // isGenerating is ONLY true when ALL conditions are met
      const isGenerating = hasActiveToken && 
                           hasInFlightFlag && 
                           inFlightTokenMatches && 
                           passedTokenMatches && 
                           hasValidToken;

      const rsf = roleSpecificFeedback;
      const isOldStructure = rsf && Array.isArray(rsf) && rsf.length > 0;
      const isNewStructure = !Array.isArray(rsf) && isValidRoleTips(rsf);
      if (isOldStructure) {
        console.warn('[RESUME-FEEDBACK] Using legacy roleSpecificFeedback array format');
      }
      const hasRoleSpecific = !!(isNewStructure || isOldStructure);
      const sectionCount = isNewStructure
        ? (rsf.sections || []).length
        : (isOldStructure ? rsf.length : 0);

      if (!roleContainer) return;

      // Manage skeleton visibility based on in-flight state
      // Show skeleton when request is in-flight, hide when role tips are ready or missing
      if (isGenerating) {
        // Entering loading state: show skeleton, hide grid (regardless of ATS score)
        if (skeletonContainer) skeletonContainer.style.display = 'block';
        if (skeletonFeedback) skeletonFeedback.style.display = 'grid';
        if (feedbackGrid) feedbackGrid.style.display = 'none';
        showRoleFeedback();
        setRoleStatus('Generating tipsâ€¦');
        // Store state on roleDescEl for restoration later
        if (roleDescEl) {
          roleDescEl.dataset.lastRoleState = 'generating';
        }
        return; // Early return during loading - don't process other states yet
      } else {
        // Exiting loading state: hide skeleton
        if (skeletonFeedback) skeletonFeedback.style.display = 'none';
        // Hide container only if all skeletons are hidden (checked by hideFeedbackSkeleton logic)
        if (skeletonContainer) {
          const skeletonRubric = document.getElementById('rf-skeleton-rubric');
          if (!skeletonRubric || skeletonRubric.style.display === 'none') {
            skeletonContainer.style.display = 'none';
          }
        }
      }

      // Clean success: role-specific tips present (regardless of ATS score)
      if (hasRoleSpecific) {
        if (feedbackGrid) feedbackGrid.style.display = 'grid';
        showRoleFeedback();
        if (roleBadge) roleBadge.style.display = 'none';
        if (roleHelper) roleHelper.style.display = 'none';
        // Show info bar only when we have partial role tips (some sections but not all)
        if (roleInfoBar) {
          if (sectionCount > 0 && sectionCount < 5) {
            roleInfoBar.style.display = 'block';
            roleInfoBar.textContent = 'We generated tips for these sections. Add a few impact bullets to see the rest.';
          } else {
            roleInfoBar.style.display = 'none';
          }
        }
        // Hide badge/helper on success
        if (roleBadge) roleBadge.style.display = 'none';
        if (roleHelper) roleHelper.style.display = 'none';
        if (regenBtn) {
          regenBtn.style.display = 'none';
          regenBtn.textContent = 'Regenerate Feedback';
        }
        // Only restore baseText if current text matches baseText (no plan-specific text was set)
        // This prevents overwriting plan-specific descriptions set by updateRfTileForPlan
        if (roleDescEl && roleDescEl.dataset.baseText) {
          const currentText = roleDescEl.textContent || '';
          const baseText = roleDescEl.dataset.baseText || '';
          const lastState = roleDescEl.dataset.lastRoleState || '';
          const isInfoState = lastState === 'info' || lastState === 'partial-error';
          // Restore baseText if:
          // - we are recovering from a previous info/error state, or
          // - current text matches baseText (no plan-specific text was set), or
          // - the element is effectively empty
          if (isInfoState || currentText === baseText || !currentText.trim()) {
            roleDescEl.textContent = baseText;
          }
          if (isInfoState) {
            delete roleDescEl.dataset.lastRoleState;
          }
        }
        setRoleStatus('Showing last saved tips.');
        return;
      }

      // Partial success: ATS present but role-specific tips missing/invalid
      const hasPlaceholder =
        allowPlaceholder &&
        feedbackGrid &&
        feedbackGrid.dataset &&
        feedbackGrid.dataset.placeholder === 'role-none';

      if (hasPlaceholder) {
        // Keep placeholder visible instead of hiding the grid
        if (feedbackGrid) feedbackGrid.style.display = 'grid';
        roleContainer.style.display = 'block';
        if (roleInfoBar) roleInfoBar.style.display = 'none';
        if (roleDescEl && roleDescEl.dataset.baseText) {
          roleDescEl.textContent = roleDescEl.dataset.baseText;
          delete roleDescEl.dataset.lastRoleState;
        }
        if (roleBadge) roleBadge.style.display = 'none';
        if (roleHelper) roleHelper.style.display = 'none';
        if (regenBtn) {
          regenBtn.style.display = 'none';
          regenBtn.textContent = 'Regenerate Feedback';
        }
        // Clear status - message is already shown in the feedback grid
        setRoleStatus('');
        return;
      }

      // Simplified: Show helpful informational message, no button
      // This state should rarely occur since backend always provides fallback tips when job title exists
      // ROLE TIPS SKELETON FIX: Don't hide grid if role tips are still in-flight
      if (feedbackGrid && !isGenerating) feedbackGrid.style.display = 'none';
      roleContainer.style.display = 'block';
      if (roleInfoBar) roleInfoBar.style.display = 'none';

      // Check if job title exists to provide contextual message
      const jobTitleInput = document.getElementById('rf-job-title');
      const hasJobTitle = jobTitleInput?.value?.trim();

      if (roleDescEl) {
        if (!hasJobTitle) {
          // No job title: Encourage user to add one
          roleDescEl.textContent = 'Add a target role above to get tailored tips for your resume. This helps us provide role-specific keyword suggestions and optimized feedback.';
        } else {
          // Job title exists but tips missing (edge case - old cache)
          roleDescEl.textContent = 'Role-specific tips will appear here after you run your next analysis with a target role.';
        }
        roleDescEl.dataset.lastRoleState = 'info';
      }

      // Always hide button in this state - never show "Try again for tailored tips"
      if (regenBtn) {
        regenBtn.style.display = 'none';
        regenBtn.textContent = 'Regenerate Feedback';
      }

      // Hide badge and helper (not needed with simplified message)
      if (roleBadge) roleBadge.style.display = 'none';
      if (roleHelper) roleHelper.style.display = 'none';
      setRoleStatus(''); // Clear status - no error state needed
    }

    // Fade transition helpers
    function hidePlaceholder() {
      const ph = document.getElementById('ats-placeholder');
      if (ph) {
        ph.classList.add('fade-exit');
        setTimeout(() => ph.remove(), 250);
      }
    }
    
    function showATSFeedback() {
      const el = document.getElementById('ats-feedback-container');
      if (!el) return;
      // Clear animation classes first to ensure animation triggers on repeat runs
      el.classList.remove('fade-enter', 'fade-enter-active');
      // Force reflow to reset animation state
      void el.offsetWidth;
      // Re-apply animation classes
      el.style.display = 'block';
      el.classList.add('fade-enter');
      requestAnimationFrame(() => el.classList.add('fade-enter-active'));
    }
    
    function showRoleFeedback() {
      const el = document.getElementById('role-feedback-container');
      if (!el) return;
      // Clear animation classes first to ensure animation triggers on repeat runs
      el.classList.remove('fade-enter', 'fade-enter-active');
      // Force reflow to reset animation state
      void el.offsetWidth;
      // Re-apply animation classes
      el.style.display = 'block';
      el.classList.add('fade-enter');
      requestAnimationFrame(() => el.classList.add('fade-enter-active'));
    }

    function applyFadeIn(el) {
      if (!el) return;
      el.classList.remove('rf-fade-in');
      // Force reflow to restart animation if applied multiple times
      void el.offsetWidth;
      el.classList.add('rf-fade-in');
    }

    function hideRoleFeedback() {
      const el = document.getElementById('role-feedback-container');
      if (!el) return;
      el.style.display = 'none';
      el.classList.remove('fade-enter', 'fade-enter-active');
    }
    
    // Helper: Populate original snippet textarea for Pro/Premium users after analysis completes
    function populateOriginalSnippetAfterAnalysis(uploadResult) {
      const userPlan = getCurrentUserPlan();
      if ((userPlan === 'pro' || userPlan === 'premium') && uploadResult) {
        const origBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[0];
        if (origBox) {
          const resumeText = sessionStorage.getItem('currentResumeText') || uploadResult.resumeText;
          if (resumeText && resumeText.length > 0) {
            let cleanText = resumeText.replace(/\s+/g, ' ').trim();
            if (cleanText.length > 0) {
              let snippet = cleanText.length > 500 ? cleanText.substring(0, 500) : cleanText;
              const lastSpace = snippet.lastIndexOf(' ');
              if (cleanText.length > 500 && lastSpace > 400) {
                snippet = snippet.substring(0, lastSpace) + '...';
              } else if (cleanText.length > 500) {
                snippet = snippet + '...';
              }
              origBox.value = snippet;
            }
          }
        }
      }
    }

    // Skeleton loading state management (performance-optimized, non-blocking)
    // Track timeout ID and pending Promise resolvers to handle concurrent calls
    let skeletonHideTimeout = null;
    let skeletonHideResolvers = []; // Array of pending Promise resolvers with generation IDs
    let skeletonOperationGeneration = 0; // Generation counter to invalidate stale operations
    
    function showSkeletons(willGetFeedback = true, hasRole = false) {
      const skeletonContainer = document.getElementById('rf-skeleton-container');
      if (skeletonContainer) {
        // CRITICAL: Increment generation to invalidate any pending hide operations
        // This prevents stale Promise callbacks from executing when a new upload starts
        skeletonOperationGeneration++;
        
        // Cancel any pending hide timeout and resolve all pending Promises as cancelled
        if (skeletonHideTimeout !== null) {
          clearTimeout(skeletonHideTimeout);
          skeletonHideTimeout = null;
        }
        // Resolve all pending hide Promises with cancelled flag (operations are now stale)
        // This ensures Promises complete but callbacks will check and exit early
        skeletonHideResolvers.forEach(({ resolve, generation }) => {
          resolve({ generation, cancelled: true });
        });
        skeletonHideResolvers = [];
        
        skeletonContainer.style.display = 'block';
        
        // Remove hidden class from all skeletons (in case they were hidden previously)
        const skeletons = skeletonContainer.querySelectorAll('.rf-skeleton');
        skeletons.forEach(skeleton => {
          skeleton.classList.remove('hidden');
        });
        
        // Reset display properties of all skeleton elements for subsequent uses
        const skeletonHeader = document.getElementById('rf-skeleton-header');
        if (skeletonHeader) {
          skeletonHeader.style.display = 'block';
        }
        const skeletonRubric = document.getElementById('rf-skeleton-rubric');
        if (skeletonRubric) {
          skeletonRubric.style.display = 'grid';
        }
        const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
        if (skeletonFeedback) {
          // ROLE TIPS SKELETON FIX: Only show if actually in-flight
          const activeToken = window.__rfActiveFeedbackToken;
          const isRoleTipsInFlight =
            window.roleTipsInFlight === true &&
            window.roleTipsInFlightToken === activeToken &&
            Boolean(activeToken);
          skeletonFeedback.style.display =
            (willGetFeedback && hasRole && isRoleTipsInFlight) ? 'grid' : 'none';
        }
        // Ensure feedback content is visible so skeletons render; hide real grids
        const feedbackContent = document.getElementById('rf-feedback-content');
        if (feedbackContent) {
          feedbackContent.style.display = 'block';
          const rubricGrid = document.getElementById('rf-rubric-grid');
          const feedbackGrid = document.getElementById('rf-feedback-grid');
          if (rubricGrid) rubricGrid.style.display = 'none';
          if (feedbackGrid) feedbackGrid.style.display = 'none';
        }
      }
    }

    function hideSkeletons() {
      return new Promise((resolve) => {
        const skeletonContainer = document.getElementById('rf-skeleton-container');
        if (!skeletonContainer) {
          resolve({ generation: skeletonOperationGeneration, cancelled: false });
          return;
        }
        
        // Capture the current generation when this hide operation starts
        const operationGeneration = skeletonOperationGeneration;
        const preserveRoleTipsSkeleton = isRoleTipsLocked();
        if (preserveRoleTipsSkeleton) {
          if (skeletonHideTimeout !== null) {
            clearTimeout(skeletonHideTimeout);
            skeletonHideTimeout = null;
          }
          if (skeletonHideResolvers.length > 0) {
            skeletonHideResolvers.forEach(({ resolve: resolver, generation }) => {
              resolver({ generation, cancelled: true });
            });
            skeletonHideResolvers = [];
          }
          const skeletonHeader = document.getElementById('rf-skeleton-header');
          if (skeletonHeader) skeletonHeader.style.display = 'none';
          const skeletonRubric = document.getElementById('rf-skeleton-rubric');
          if (skeletonRubric) skeletonRubric.style.display = 'none';
          const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
          if (skeletonFeedback) {
            skeletonFeedback.style.display = 'grid';
            const feedbackSkeletons = skeletonFeedback.querySelectorAll('.rf-skeleton');
            feedbackSkeletons.forEach((skeleton) => {
              skeleton.classList.remove('hidden');
            });
          }
          skeletonContainer.style.display = 'block';
          resolve({ generation: operationGeneration, cancelled: false });
          return;
        }
        
        // If a hide operation is already in progress, queue this resolver
        // This prevents race conditions where concurrent calls cancel each other's timeouts
        if (skeletonHideTimeout !== null) {
          // Add this resolver to the queue with its generation ID
          skeletonHideResolvers.push({ resolve, generation: operationGeneration });
          return;
        }
        
        // Start new hide operation - initialize resolver array with this one
        skeletonHideResolvers = [{ resolve, generation: operationGeneration }];
        
        // Fade out skeletons smoothly
        const skeletons = skeletonContainer.querySelectorAll('.rf-skeleton');
        skeletons.forEach(skeleton => {
          skeleton.classList.add('hidden');
        });
        
        // Remove container after fade completes, then resolve all pending Promises
        skeletonHideTimeout = setTimeout(() => {
          skeletonContainer.style.display = 'none';
          // Remove hidden class for next use
          skeletons.forEach(skeleton => {
            skeleton.classList.remove('hidden');
          });
          
          // Resolve ALL pending Promises with their generation IDs
          // Callbacks will check if generation matches current before executing
          skeletonHideResolvers.forEach(({ resolve: resolver, generation }) => {
            resolver({ generation, cancelled: generation !== skeletonOperationGeneration });
          });
          skeletonHideResolvers = [];
          skeletonHideTimeout = null;
        }, 300);
      });
    }

    function hideHeaderSkeleton() {
      const skeletonHeader = document.getElementById('rf-skeleton-header');
      if (skeletonHeader) {
        skeletonHeader.style.display = 'none';
      }
    }

    function hideATSSkeleton() {
      const skeletonRubric = document.getElementById('rf-skeleton-rubric');
      if (skeletonRubric) {
        skeletonRubric.style.display = 'none';
      }
      const skeletonContainer = document.getElementById('rf-skeleton-container');
      const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
      if (skeletonContainer && skeletonFeedback && skeletonFeedback.style.display === 'none') {
        skeletonContainer.style.display = 'none';
      }
    }

    function hideFeedbackSkeleton() {
      const DEBUG_ROLE_TIPS = localStorage.getItem('debugRoleTips') === '1';
      const activeToken = window.__rfActiveFeedbackToken;
      const isActuallyInFlight = window.roleTipsInFlight === true &&
        window.roleTipsInFlightToken === activeToken &&
        Boolean(activeToken);
      if (DEBUG_ROLE_TIPS) console.debug('[SKELETON-DEBUG] hideFeedbackSkeleton() called', {
        skeletonFound: !!document.getElementById('rf-skeleton-feedback'),
        currentDisplay: document.getElementById('rf-skeleton-feedback')?.style.display || 'N/A',
        roleTipsInFlight: window.roleTipsInFlight,
        roleTipsInFlightToken: window.roleTipsInFlightToken,
        activeToken: window.__rfActiveFeedbackToken,
        status: getRoleTipsStatus()?.status,
        isActuallyInFlight
      });
      if (isActuallyInFlight) {
        return;
      }
      const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
      if (skeletonFeedback) {
        skeletonFeedback.style.display = 'none';
      }
      const skeletonContainer = document.getElementById('rf-skeleton-container');
      const skeletonRubric = document.getElementById('rf-skeleton-rubric');
      if (skeletonContainer && skeletonRubric && skeletonRubric.style.display === 'none') {
        skeletonContainer.style.display = 'none';
      }
    }

    // --- Priority Review Tooltip (modular) ---
    function createPriorityReviewTooltip(text = 'Priority Review') {
      const wrapper = document.createElement('span');
      wrapper.className = 'priority-review-tooltip';
      wrapper.innerHTML = `${text} <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-left:4px;vertical-align:middle;color:var(--color-text-muted);"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg> <span class="tooltip-text">Premium users get their resume analyzed firstâ€”faster results, prioritized AI review, and VIP support.</span>`;
      return wrapper;
    }
    
    // --- Priority Review CTA (modular) ---
    function renderPriorityReviewCTA() {
      const cta = document.createElement('div');
      cta.className = 'priority-review-cta premium-cta';
      cta.innerHTML = `<strong>Want your resume reviewed first?</strong> <span id="priority-review-inline"></span> <button class="priority-btn" onclick="startCheckout('premium')">Upgrade to Premium</button>`;
      // Insert tooltip
      setTimeout(() => {
        const inline = cta.querySelector('#priority-review-inline');
        if (inline) inline.appendChild(createPriorityReviewTooltip('Upgrade to Premium for Priority Review'));
      }, 0);
      return cta;
    }
    
    // --- Premium Priority Review CTA (white background) ---
    function renderPremiumPriorityReviewCTA() {
      const cta = document.createElement('div');
      cta.className = 'priority-review-cta premium-cta';
      cta.innerHTML = `<strong>You're on Premium!</strong> <span id="priority-review-inline-premium"></span>`;
      // Insert tooltip
      setTimeout(() => {
        const inline = cta.querySelector('#priority-review-inline-premium');
        if (inline) inline.appendChild(createPriorityReviewTooltip('Priority Review included'));
      }, 0);
      return cta;
    }
    
    // --- Premium Priority Review note (no CTA) ---
    function renderPremiumPriorityReviewNote() {
      // Premium should not show any Priority Review messaging
      const existing = document.getElementById('priority-review-premium-note');
      if (existing) existing.remove();
      return;
    }
    
    // --- Insert Priority Review CTA / note below Resume Rewriting ---
    function updatePriorityReviewCTA() {
      // Remove any existing CTA (only show one Premium banner per page)
      const oldCta = document.getElementById('priority-review-cta-main');
      if (oldCta) oldCta.remove();
      
      const plan = getCurrentUserPlan();
      if (plan === 'essential' || plan === 'pro') {
        // Insert Priority Review CTA after Resume Rewriting tile
        const rewriteTile = document.getElementById('rf-rewrite-tile');
        if (rewriteTile && rewriteTile.parentNode) {
          const cta = renderPriorityReviewCTA();
          cta.id = 'priority-review-cta-main';
          rewriteTile.parentNode.insertBefore(cta, rewriteTile.nextSibling);
        }
      } else if (plan === 'premium') {
        // Insert Premium CTA with white background
        const rewriteTile = document.getElementById('rf-rewrite-tile');
        if (rewriteTile && rewriteTile.parentNode) {
          const cta = renderPremiumPriorityReviewCTA();
          cta.id = 'priority-review-cta-main';
          rewriteTile.parentNode.insertBefore(cta, rewriteTile.nextSibling);
        }
      }
    }

    // Display change summary from rewrite result
    function displayChangeSummary(changeSummary) {
      const summaryContainer = document.getElementById('rf-change-summary');
      if (!summaryContainer || !changeSummary) return;
      
      const atsFixes = changeSummary.atsFixes || [];
      const roleFixes = changeSummary.roleFixes || [];
      
      if (atsFixes.length === 0 && roleFixes.length === 0) {
        summaryContainer.style.display = 'none';
        return;
      }
      
      // Add the class to the container element itself (not a nested div)
      summaryContainer.className = 'rf-change-summary';
      
      // Only create the inner grid structure without redundant wrapper
      let summaryHtml = '<div class="rf-change-summary-grid">';
      
      
      if (atsFixes.length > 0) {
        summaryHtml += `
          <div>
            <h4>ATS Fixes</h4>
            <ul>
              ${atsFixes.map(fix => `<li>${escapeHtml(fix)}</li>`).join('')}
            </ul>
          </div>
        `;
      }
      
      if (roleFixes.length > 0) {
        summaryHtml += `
          <div>
            <h4>Role Tailoring</h4>
            <ul>
              ${roleFixes.map(fix => `<li>${escapeHtml(fix)}</li>`).join('')}
            </ul>
          </div>
        `;
      }
      
      summaryHtml += '</div>';
      summaryContainer.innerHTML = summaryHtml;
      summaryContainer.style.display = 'block';
    }

    // Hide details for Free plan
    function updateRfTileForPlan() {
      const atsScoreTile = document.getElementById('rf-ats-score-tile');
      const feedbackTile = document.getElementById('rf-feedback-tile');
      const rewriteTile = document.getElementById('rf-rewrite-tile');
      const feedbackContent = document.getElementById('rf-feedback-content');
      const rewriteContent = document.getElementById('rf-rewrite-content');
      const plan = getCurrentUserPlan();
      const roleDescEl = document.getElementById('rf-role-desc');
      const headerBadge = document.getElementById('rf-header-plan-badge');
      const headerDesc = document.getElementById('rf-header-desc');
      
      function setHeaderBadgePending(isPending) {
        if (!headerBadge) return;
        if (isPending) {
          headerBadge.classList.add('rf-plan-badge--pending');
          headerBadge.setAttribute('aria-hidden', 'true');
          headerBadge.textContent = '';
          headerBadge.style.background = 'transparent';
          return;
        }
        headerBadge.classList.remove('rf-plan-badge--pending');
        headerBadge.removeAttribute('aria-hidden');
      }
      
      // Hide the header badge while plan is unknown or free to prevent blue flash.
      setHeaderBadgePending(plan === 'free' || plan === 'visitor' || !plan || plan === 'undefined');
      
      // Check if we're viewing historical feedback - don't overwrite score description
      const isHistoricalView = typeof window.JobHackAIHistory?.isHistoricalView === 'function' 
        ? window.JobHackAIHistory.isHistoricalView() 
        : false;
      
      // Helper function to safely set text content
      function safeSetText(element, text) {
        if (element) element.textContent = text;
      }
      
      // Helper function to safely set innerHTML
      function safeSetHTML(element, html) {
        if (element) element.innerHTML = html;
      }
      
      // Helper function to safely set style property
      function safeSetStyle(element, prop, value) {
        if (element && element.style) element.style[prop] = value;
      }
      
      // Helper function to safely query and set text
      function safeQueryText(parent, selector, text) {
        if (!parent) return null;
        const el = parent.querySelector(selector);
        if (el) el.textContent = text;
        return el;
      }
      
      // Helper function to safely query and set style
      function safeQueryStyle(parent, selector, prop, value) {
        if (!parent) return null;
        const el = parent.querySelector(selector);
        if (el && el.style) el.style[prop] = value;
        return el;
      }
      
      // Helper function to safely query and set HTML
      function safeQueryHTML(parent, selector, html) {
        if (!parent) return null;
        const el = parent.querySelector(selector);
        if (el) el.innerHTML = html;
        return el;
      }
      
      // Helper function to safely query an element (for passing to other functions)
      function safeQuerySelector(parent, selector) {
        if (!parent) return null;
        return parent.querySelector(selector);
      }
      
      // Cache base role description for later restores
      if (roleDescEl && !roleDescEl.dataset.baseText) {
        roleDescEl.dataset.baseText = roleDescEl.textContent || '';
      }

      // Clean up old upgrade banners
      const cleanupOldBanners = () => {
        const oldBanners = document.querySelectorAll('#rf-feedback-upgrade-banner, #rf-rewrite-upgrade-banner');
        oldBanners.forEach(banner => banner.remove());
      };

      // Reset all tiles to default state
      const resetTiles = () => {
        if (atsScoreTile) atsScoreTile.style.display = 'block';
        if (feedbackTile) feedbackTile.style.display = 'block';
        if (rewriteTile) rewriteTile.style.display = 'block';
        if (feedbackContent) feedbackContent.style.display = 'none';
        if (rewriteContent) rewriteContent.style.display = 'none';
        cleanupOldBanners();
      };

      resetTiles();

      // Helper function to update description with tooltip preserved
      function updateDescriptionWithTooltip(element, text, tooltipText) {
        if (!element) return;
        const tooltipHtml = `<span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.4em;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="8"/>
            <line x1="12" y1="12" x2="12" y2="16"/>
          </svg>
          <span class="rf-tooltip-text">${tooltipText}</span>
        </span>`;
        element.innerHTML = text + tooltipHtml;
      }

      // Free Plan Logic
      if (plan === 'free') {
        // Badge stays hidden via setHeaderBadgePending(true) above; no pill for free.
        if (headerDesc && !isHistoricalView) {
          headerDesc.textContent = 'Get your basic ATS compatibility score.';
        }

        if (feedbackTile) {
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Locked');
          safeSetStyle(badge, 'background', '#E11D48');
          safeQueryText(feedbackTile, '.rf-upgrade-text strong', 'Start Free Trial');
          safeQueryHTML(feedbackTile, '.rf-upgrade-text', '<strong>Start Free Trial</strong> to unlock detailed ATS and role-specific feedback instantly.');
          // Add trial CTA button
          const upgradeButton = feedbackTile.querySelector('.rf-upgrade-prompt a');
          if (upgradeButton) {
            upgradeButton.textContent = 'Start Free Trial';
            upgradeButton.style.background = 'var(--color-accent-blue)';
            upgradeButton.style.color = '#fff';
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Pro Feature');
          safeSetStyle(badge, 'background', '#6B7280');
          safeQueryText(rewriteTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
          safeQueryHTML(rewriteTile, '.rf-upgrade-text', '<strong>Upgrade to Pro</strong> to unlock AI-powered resume rewriting with unlimited revisions');
        }
      }

      // Trial Plan Logic
      else if (plan === 'trial') {
        setHeaderBadgePending(false);
        if (headerBadge) {
          headerBadge.textContent = 'Trial Plan';
          headerBadge.style.setProperty('background', '#FF9100', 'important');
        }
        if (headerDesc && !isHistoricalView) {
          headerDesc.textContent = 'Your trial includes 3 full ATS score & feedback runs. Each run combines ATS scoring with detailed feedback, so you know exactly what to fix before you apply.';
        }

        // Trial feedback: 3 full runs total during trial
        if (feedbackTile) {
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Trial Plan');
          if (badge) {
            badge.style.setProperty('background', '#FF9100', 'important');
          }
          safeQueryStyle(feedbackTile, '.rf-upgrade-text', 'display', 'none');
          if (feedbackContent) {
            feedbackContent.style.display = 'block';
          }
          if (roleDescEl) {
            const planSpecificText = 'Basic feedback on your resume\'s content and presentation for your target role. Upgrade to Pro for deeper analysis and richer AI suggestions.';
            roleDescEl.textContent = planSpecificText;
            // Update baseText to plan-specific text so updateRoleTipsState restores the correct text
            roleDescEl.dataset.baseText = planSpecificText;
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Pro Feature');
          safeSetStyle(badge, 'background', '#6B7280');
          safeQueryText(rewriteTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
          safeQueryHTML(rewriteTile, '.rf-upgrade-text', '<strong>Trial shows you what to fix. Pro fixes it now (rewrites unlocked).</strong> Upgrade to Pro to complete your resume optimization.');
          const upgradePrompt = rewriteTile.querySelector('.rf-upgrade-prompt');
          if (upgradePrompt) {
            upgradePrompt.style.display = 'flex';
          }
          // Add special upgrade CTA for trial users
          const upgradeButton = rewriteTile.querySelector('.rf-upgrade-prompt a');
          if (upgradeButton && upgradeButton.parentNode) {
            upgradeButton.textContent = 'Upgrade to Pro';
            upgradeButton.className = 'btn btn-secondary';
            const freshButton = upgradeButton.cloneNode(true);
            upgradeButton.parentNode.replaceChild(freshButton, upgradeButton);
            freshButton.style.setProperty('background', '#1976D2', 'important');
            freshButton.style.setProperty('color', '#fff', 'important');
            freshButton.style.setProperty('border', 'none', 'important');
            freshButton.style.setProperty('display', 'inline-block', 'important');
            freshButton.addEventListener('mouseenter', function() {
              this.style.setProperty('background', '#125bb5', 'important');
            });
            freshButton.addEventListener('mouseleave', function() {
              this.style.setProperty('background', '#1976D2', 'important');
            });
          }
        }
      }

      // Essential Plan Logic
      else if (plan === 'essential') {
        setHeaderBadgePending(false);
        if (headerBadge) {
          headerBadge.textContent = 'Essential Plan';
          headerBadge.style.background = '#0077B5';
        }
        if (headerDesc && !isHistoricalView) {
          headerDesc.textContent = 'Get comprehensive ATS scoring and role-specific feedback. Your Essential plan includes 3 detailed feedback runs per month.';
        }

        // Essential: 3 feedbacks/month
        if (feedbackTile) {
          // Check monthly usage (will be updated dynamically via API)
          const monthlyUsage = 0; // Will be fetched from /api/usage
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          if (monthlyUsage >= 3) {
            safeSetText(badge, 'Monthly Limit Reached');
            safeSetStyle(badge, 'background', '#6B7280');
            safeQueryText(feedbackTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
            safeQueryHTML(feedbackTile, '.rf-upgrade-text', '<strong>Upgrade to Pro</strong> for AI resume rewriting and higher feedback limits.');
          } else {
            safeSetText(badge, 'Essential Plan');
            safeSetStyle(badge, 'background', '#0077B5');
            safeQueryStyle(feedbackTile, '.rf-upgrade-text', 'display', 'none');
            if (feedbackContent) {
              feedbackContent.style.display = 'block';
            }
            // Ensure Essential feedback limit is clearly communicated
            let essentialNote = document.getElementById('rf-essential-feedback-note');
            if (!essentialNote) {
              essentialNote = document.createElement('div');
              essentialNote.id = 'rf-essential-feedback-note';
              essentialNote.style.marginTop = '0.5rem';
              essentialNote.style.color = 'var(--color-text-secondary)';
              essentialNote.style.fontSize = '0.9rem';
              essentialNote.textContent = 'Your Essential plan includes 3 feedback runs per month.';
              feedbackTile.insertBefore(essentialNote, feedbackContent);
            }
            if (roleDescEl) {
              const planSpecificText = 'Basic feedback on your resume\'s content and presentation for your target role. Upgrade to Pro for deeper analysis and richer AI suggestions.';
              roleDescEl.textContent = planSpecificText;
              // Update baseText to plan-specific text so updateRoleTipsState restores the correct text
              roleDescEl.dataset.baseText = planSpecificText;
            }
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Pro Feature');
          safeSetStyle(badge, 'background', '#6B7280');
          safeQueryText(rewriteTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
          safeQueryHTML(rewriteTile, '.rf-upgrade-text', '<strong>Trial shows you what to fix. Pro fixes it now (rewrites unlocked).</strong> Upgrade to Pro to complete your resume optimization.');
          const upgradePrompt = rewriteTile.querySelector('.rf-upgrade-prompt');
          if (upgradePrompt) {
            upgradePrompt.style.display = 'flex';
          }
          // Add special upgrade CTA for essential users
          const upgradeButton = rewriteTile.querySelector('.rf-upgrade-prompt a');
          if (upgradeButton && upgradeButton.parentNode) {
            upgradeButton.textContent = 'Upgrade to Pro';
            upgradeButton.className = 'btn btn-secondary';
            const freshButton = upgradeButton.cloneNode(true);
            upgradeButton.parentNode.replaceChild(freshButton, upgradeButton);
            freshButton.style.setProperty('background', '#1976D2', 'important');
            freshButton.style.setProperty('color', '#fff', 'important');
            freshButton.style.setProperty('border', 'none', 'important');
            freshButton.style.setProperty('display', 'inline-block', 'important');
            freshButton.addEventListener('mouseenter', function() {
              this.style.setProperty('background', '#125bb5', 'important');
            });
            freshButton.addEventListener('mouseleave', function() {
              this.style.setProperty('background', '#1976D2', 'important');
            });
          }
        }
      }

      // Pro & Premium Plan Logic
      else if (plan === 'pro' || plan === 'premium') {
        const isProPlan = plan === 'pro';
        const isPremiumPlan = plan === 'premium';
        const planLabel = plan.charAt(0).toUpperCase() + plan.slice(1) + ' Plan';
        const planColor = isProPlan ? '#388E3C' : '#C62828';
        
        setHeaderBadgePending(false);
        if (headerBadge) {
          headerBadge.textContent = planLabel;
          headerBadge.style.background = planColor;
        }
        if (headerDesc && !isHistoricalView) {
          if (isPremiumPlan) {
            headerDesc.textContent = 'Upload your resume once. Improve it step-by-step with ATS insights, role-specific feedback, and AI-powered rewrites! All your AI-generated content gets priority review.';
          } else {
            headerDesc.textContent = 'Upload your resume once. Improve it step-by-step with ATS insights, role-specific feedback, and AI-powered rewrites!';
          }
        }

        if (feedbackTile) {
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, planLabel);
          safeSetStyle(badge, 'background', planColor);
          safeQueryStyle(feedbackTile, '.rf-upgrade-text', 'display', 'none');
          if (feedbackContent) {
            feedbackContent.style.display = 'block';
            // Premium CTA removed - already exists at bottom of page
          }
          if (roleDescEl) {
            const planSpecificText = 'See how your resume aligns with what hiring managers expect for your target role.';
            roleDescEl.textContent = planSpecificText;
            // Update baseText to plan-specific text so updateRoleTipsState restores the correct text
            roleDescEl.dataset.baseText = planSpecificText;
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, planLabel);
          safeSetStyle(badge, 'background', planColor);
          // Update description text for Pro/Premium users
          const rewriteDesc = rewriteTile.querySelector('#rf-rewrite-desc');
          if (rewriteDesc) {
            const planName = isPremiumPlan ? 'Premium' : 'Pro';
            rewriteDesc.innerHTML = 'AI rewrites your resume line-by-line using this ATS feedback and your target role. <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.4em;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="8"/><line x1="12" y1="12" x2="12" y2="16"/></svg><span class="rf-tooltip-text">See a rewritten version of your resume tailored to your target job - ready to copy and paste. Unlimited with your ' + planName + ' plan.</span></span>';
          }
          // Hide upgrade prompt and show content
          const upgradePrompt = rewriteTile.querySelector('.rf-upgrade-prompt');
          if (upgradePrompt) upgradePrompt.style.display = 'none';
          if (rewriteContent) {
            rewriteContent.style.display = 'block';
            // Re-attach button listeners when content is shown
            setTimeout(attachRewriteButtonListeners, 100);
            // Remove any Premium upgrade banner from rewrite tile (only show in feedback tile)
            const oldBanner = document.getElementById('rf-rewrite-upgrade-banner');
            if (oldBanner) oldBanner.remove();
          }
        }
      }
      // Always update Priority Review CTA
      updatePriorityReviewCTA();
    }

    // Add usage indicator using shared component
    async function refreshUsageIndicator() {
      const headerCard = document.getElementById('rf-header-card');
      const usageContainer = document.getElementById('rf-usage-container');
      
      // Fetch usage for all plans to show limits (trial/essential) or total runs (pro/premium)
      if (headerCard && usageContainer) {
        try {
          // Fetch usage data from API
          const token = await getAuthToken().catch(() => null);
          if (!token) {
            console.warn('[RESUME-FEEDBACK] No auth token available for usage fetch');
            usageContainer.innerHTML = `<div class="usage-indicator">Sign in to see your usage limits.</div>`;
            return;
          }

          const usageResponse = await fetch('/api/usage', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            }
          });

          if (!usageResponse.ok) {
            console.warn('[RESUME-FEEDBACK] Failed to fetch usage data');
            usageContainer.innerHTML = `<div class="usage-indicator">Usage information unavailable. Please refresh and try again.</div>`;
            return;
          }

          const usageData = await usageResponse.json();
          
          if (usageData.success && usageData.usage && usageData.usage.resumeFeedback) {
            const usage = usageData.usage.resumeFeedback;
            const plan = usageData.plan;
            
            // Note: Usage reset on plan upgrade (trialâ†’essential) is handled by backend via plan_updated_at.
            // This function always fetches fresh data from the API, so the reset is automatically reflected.

            // Clear container first
            usageContainer.innerHTML = '';
            
            // Create a child div for the resume feedback indicator
            const indicatorDiv = document.createElement('div');
            usageContainer.appendChild(indicatorDiv);

            // Render usage indicator using the shared component
            if (window.renderUsageIndicator) {
              window.renderUsageIndicator({
                feature: 'resumeFeedback',
                usage: usage,
                plan: plan,
                container: indicatorDiv,
                customText: null // Let component use default text
              });

            } else {
              console.warn('[RESUME-FEEDBACK] Usage indicator component not loaded');
              indicatorDiv.innerHTML = `<div class="usage-indicator">Usage information unavailable. Please refresh and try again.</div>`;
            }
          } else {
            usageContainer.innerHTML = `<div class="usage-indicator">Usage information unavailable.</div>`;
          }
        } catch (error) {
          console.error('[RESUME-FEEDBACK] Error loading usage indicator:', error);
          if (usageContainer) {
            usageContainer.innerHTML = `<div class="usage-indicator">Usage information unavailable. Please refresh and try again.</div>`;
          }
        }
      }
    }

    // Initialize usage indicator when DOM is ready (fires earlier than 'load')
    document.addEventListener('DOMContentLoaded', refreshUsageIndicator);

    // --- PLAN UI ---
    // Plan badge + gating are handled by the navigation-driven plan system via `updateRfTileForPlan()`.
    // Do NOT re-implement a second plan UI updater here (it caused Trial badge color regressions by overwriting state).

    // =======================================================
    // RESUME FEEDBACK HISTORY (D1-backed)
    // Fetches and displays persistent feedback history from the server
    // =======================================================
    
    // In-memory history cache (source of truth is always the server)
    let _historyItems = [];
    // HistoryPanel v1 state
    let _historyManageMode = false;
    let _historySelectedIds = new Set();
    let _historyPendingDeleteIds = [];
    let _historyMenuOpenForSessionId = null;
    let _historyHasError = false;

    function getVisibleHistoryItems(items) {
      // UI spec: show last 10
      return (items || []).slice(0, 10);
    }

    function getVisibleHistoryIds() {
      return getVisibleHistoryItems(_historyItems)
        .map((x) => String(x?.sessionId || ''))
        .filter(Boolean);
    }

    function setHistoryManageMode(next) {
      const panel = document.getElementById('rf-history-panel');
      const titleEl = document.getElementById('rf-history-header-title');
      _historyManageMode = !!next;
      if (panel) {
        panel.classList.toggle('rf-history-panel--manage', _historyManageMode);
      }
      if (titleEl) {
        titleEl.textContent = _historyManageMode ? 'Select items' : 'History';
      }
      if (!_historyManageMode) {
        _historySelectedIds.clear();
        _historyMenuOpenForSessionId = null;
      }
      syncBulkDeleteState();
      // Re-render list so checkboxes/menus match mode
      renderHistoryItems(_historyItems);
    }

    function syncBulkDeleteState() {
      const btn = document.getElementById('rf-history-delete-selected');
      if (!btn) return;
      btn.disabled = _historySelectedIds.size < 1;
    }

    function setHistoryLoading(isLoading) {
      const loadingEl = document.getElementById('rf-history-loading');
      if (!loadingEl) return;
      loadingEl.classList.toggle('is-visible', !!isLoading);
    }

    function setHistoryErrorVisible(isVisible, message) {
      const errEl = document.getElementById('rf-history-error');
      if (!errEl) return;
      const textEl = errEl.querySelector('span[data-default-message]') || errEl.querySelector('span');
      if (textEl) {
        if (message) {
          textEl.textContent = message;
        } else if (textEl.dataset.defaultMessage) {
          textEl.textContent = textEl.dataset.defaultMessage;
        }
      }
      errEl.hidden = !isVisible;
      _historyHasError = isVisible;
    }

    function closeAllHistoryMenus() {
      const listEl = document.getElementById('rf-history-list');
      if (!listEl) return;
      listEl.querySelectorAll('.rf-history-menu').forEach((menu) => {
        menu.hidden = true;
      });
      _historyMenuOpenForSessionId = null;
    }

    function openDeleteModalFor(ids) {
      const unique = Array.from(new Set((ids || []).map(String).filter(Boolean)));
      if (!unique.length) {
        _historyPendingDeleteIds = [];
        return;
      }
      _historyPendingDeleteIds = unique;

      const backdrop = document.getElementById('rf-history-modal-backdrop');
      const modal = document.getElementById('rf-history-delete-modal');
      const cancelBtn = document.getElementById('rf-history-modal-cancel');
      if (backdrop) backdrop.hidden = false;
      if (modal) modal.hidden = false;
      // Default focus: Cancel
      setTimeout(() => cancelBtn?.focus?.(), 0);
    }

    function closeDeleteModal() {
      const backdrop = document.getElementById('rf-history-modal-backdrop');
      const modal = document.getElementById('rf-history-delete-modal');
      if (backdrop) backdrop.hidden = true;
      if (modal) modal.hidden = true;
      _historyPendingDeleteIds = [];
    }

    async function deleteResumeFeedbackHistoryItem(sessionId) {
      // NOTE: backend may not support DELETE yet; we fail gracefully if it doesn't.
      const token = await getAuthToken().catch(() => null);
      if (!token) throw new Error('Unauthorized');

      const res = await fetch(`/api/resume-feedback/history/${encodeURIComponent(String(sessionId))}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });

      if (!res.ok) {
        const msg = `Delete failed (${res.status})`;
        throw new Error(msg);
      }
      return true;
    }

    async function deleteResumeFeedbackHistoryItems(sessionIds) {
      const ids = Array.from(new Set((sessionIds || []).map(String).filter(Boolean)));
      if (!ids.length) return { success: [], failures: [] };
      const results = await Promise.allSettled(ids.map((id) => deleteResumeFeedbackHistoryItem(id)));
      const successIds = results
        .filter((r) => r.status === 'fulfilled')
        .map((r, index) => ids[index]);
      const failures = results
        .map((result, index) => ({ result, id: ids[index] }))
        .filter(({ result }) => result.status === 'rejected');

      if (successIds.length) {
        _historyItems = _historyItems.filter(item => !successIds.includes(String(item.sessionId)));
        renderHistoryItems(_historyItems);
      }

      return { success: successIds, failures };
    }
    
    /**
     * Normalize SQLite datetime format to ISO 8601 for Safari compatibility
     * SQLite returns dates as 'YYYY-MM-DD HH:MM:SS' (space-separated)
     * Safari requires ISO 8601 format 'YYYY-MM-DDTHH:MM:SSZ'
     */
    function normalizeDateForSafari(dateStr) {
      if (!dateStr || typeof dateStr !== 'string') return dateStr;
      
      // Check if it's SQLite format (YYYY-MM-DD HH:MM:SS)
      if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/.test(dateStr)) {
        // Replace space with 'T' to make it ISO 8601 compliant
        let normalized = dateStr.replace(' ', 'T');
        // Add 'Z' if no timezone info is present (assume UTC)
        if (!normalized.includes('Z') && !normalized.includes('+') && !normalized.includes('-', 10)) {
          normalized += 'Z';
        }
        return normalized;
      }
      
      return dateStr; // Already in correct format or unrecognized
    }
    
    /**
     * Parse a date string with Safari compatibility
     * Returns a Date object or null if parsing fails
     */
    function parseDateSafely(dateStr) {
      if (!dateStr) return null;
      
      const normalized = normalizeDateForSafari(dateStr);
      const date = new Date(normalized);
      
      // Validate date is valid (Safari returns Invalid Date as NaN, not an error)
      if (isNaN(date.getTime())) {
        console.warn('[RESUME-FEEDBACK] Invalid date string:', dateStr);
        return null;
      }
      
      return date;
    }
    
    /**
     * Format a date string for display
     * Handles SQLite datetime format (YYYY-MM-DD HH:MM:SS) which Safari rejects
     * by normalizing to ISO 8601 format (YYYY-MM-DDTHH:MM:SS) before parsing
     */
    function formatHistoryDate(dateStr) {
      if (!dateStr) return '';
      
      const date = parseDateSafely(dateStr);
      if (!date) return dateStr; // Return original string if parsing fails
      
      try {
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins} min ago`;
        if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric',
          year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
        });
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Date formatting error:', e, 'for date:', dateStr);
        return dateStr;
      }
    }
    
    /**
     * Generate a display title for a history item
     */
    function getHistoryItemTitle(item) {
      if (item.title && item.title.trim()) {
        return item.title;
      }
      if (item.role && item.role.trim()) {
        return `${item.role} Resume`;
      }
      // Fallback to date-based title
      const date = parseDateSafely(item.createdAt);
      if (date) {
        return `Resume from ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
      }
      return 'Resume Analysis';
    }
    
    /**
     * Render history items to the DOM
     */
    function renderHistoryItems(items) {
    const listEl = document.getElementById('rf-history-list');
      const emptyEl = document.getElementById('rf-history-empty');
      
      if (!listEl) return;
      
      // Always hide loading when rendering
      setHistoryLoading(false);
      
      if (!items || items.length === 0) {
        listEl.innerHTML = '';
        if (emptyEl) {
          emptyEl.hidden = _historyHasError ? true : false;
        }
        return;
      }
      
      if (emptyEl) emptyEl.hidden = true;
      
      const visibleItems = getVisibleHistoryItems(items);

    listEl.innerHTML = visibleItems.map(item => {
        const sessionId = String(item?.sessionId || '');
        const roleName = String(item?.role || '').trim() || 'Untitled role';
        const when = formatHistoryDate(item?.createdAt) || 'â€”';

      // Prevent null from being coerced into a valid 0 score.
        const normalizedScore = item?.atsScore != null && Number.isFinite(Number(item.atsScore))
        ? Number(item.atsScore)
        : null;

        const isCurrent = !_historyManageMode && _currentHistoricalSessionId && String(_currentHistoricalSessionId) === sessionId;
        const isSelected = isCurrent ? 'is-selected' : '';
        const isChecked = _historySelectedIds.has(sessionId);

      const scoreHtml = normalizedScore !== null
          ? `<div class="rf-history-score" aria-label="Score ${Math.round(normalizedScore)}">${Math.round(normalizedScore)}</div>`
        : '';

        const menuHidden = _historyMenuOpenForSessionId !== sessionId;

      return `
          <div class="rf-history-item ${isSelected}" data-session-id="${escapeHtml(sessionId)}" tabindex="0" data-history-row>
            <span class="rf-history-checkbox-wrap" aria-hidden="${_historyManageMode ? 'false' : 'true'}">
              <input
                class="rf-history-checkbox"
                type="checkbox"
                data-action="toggle-select"
                data-session-id="${escapeHtml(sessionId)}"
                aria-label="Select ${escapeHtml(roleName)}"
                ${isChecked ? 'checked' : ''}
              />
            </span>

            <div class="rf-history-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
              </svg>
            </div>

            <div class="rf-history-text">
              <div class="rf-history-line1">${escapeHtml(roleName)}</div>
              <div class="rf-history-line2">${escapeHtml(when)}</div>
            </div>

          ${scoreHtml}

            <div class="rf-history-row-actions" aria-label="Row actions">
              <button
                class="rf-history-kebab"
                type="button"
                aria-label="Row actions"
                data-action="menu-toggle"
                data-session-id="${escapeHtml(sessionId)}"
              >
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                  <circle cx="5" cy="12" r="2"></circle>
                  <circle cx="12" cy="12" r="2"></circle>
                  <circle cx="19" cy="12" r="2"></circle>
                </svg>
              </button>
              <div class="rf-history-menu" role="menu" ${menuHidden ? 'hidden' : ''}>
                <button class="rf-history-menu-item" type="button" data-action="open" data-session-id="${escapeHtml(sessionId)}">Open / Restore</button>
                <button class="rf-history-menu-item rf-history-menu-item--danger" type="button" data-action="delete" data-session-id="${escapeHtml(sessionId)}">Delete</button>
              </div>
            </div>
        </div>
      `;
    }).join('');
    }
    
    /**
     * Track if we're viewing historical feedback (D1-only view)
     */
    let _isHistoricalView = false;
    let _currentHistoricalSessionId = null;
    let _mode = 'new';
    let _selectedHistoryItem = null;

    function setMode(mode) {
      _mode = mode === 'saved' ? 'saved' : 'new';
      updateModeUI();
    }

    function updateModeUI() {
      const generateLabel = document.getElementById('rf-generate-label');
      const generateBtn = document.getElementById('rf-generate-btn');
      const fileInput = document.getElementById('rf-upload');
      const savedLine = document.getElementById('rf-saved-file-line');
      
      if (generateLabel) {
        generateLabel.textContent = _mode === 'saved'
          ? 'Re-run with new file'
          : 'Generate ATS Score & Feedback';
      }
      
      // Keep generate button clickable; click guard handles missing file case
      // if (generateBtn) {
      //   const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
      //   if (_mode === 'saved' && !hasFile) {
      //     generateBtn.disabled = true;
      //   }
      // }
      
      if (savedLine) {
        savedLine.style.display = _mode === 'saved' ? 'block' : 'none';
      }
    }

    function updateSavedFileLine(fileName) {
      const savedLine = document.getElementById('rf-saved-file-line');
      const savedName = document.getElementById('rf-saved-file-name');
      if (!savedLine || !savedName) return;
      savedName.textContent = fileName || '(file not stored)';
    }

    // Initialize mode UI on load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', updateModeUI);
    } else {
      updateModeUI();
    }
    
    /**
     * Load full feedback detail from D1 (NO OpenAI calls)
     * Restores the entire page state from saved data
     */
    async function loadHistoryDetail(sessionId) {
      console.log('[RESUME-FEEDBACK-HISTORY] Loading history detail:', sessionId);
      
      // Suppress toasts when loading a history item
      if (window._rfToast) {
        window._rfToast.activeRunId = null;
        window._rfToast.suppress = true;
        // Immediately dismiss any existing toast (consistent with Start Fresh behavior)
        if (window._rfToast.currentToast && typeof window._rfToast.currentToast.dismiss === 'function') {
          try { window._rfToast.currentToast.dismiss(); } catch (e) { /* ignore */ }
        }
        window._rfToast.currentId = null;
        window._rfToast.currentToast = null;
      }
      
      // Show loading state
      const loadingOverlay = document.getElementById('loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
        const loadingText = loadingOverlay.querySelector('.loading-text');
        if (loadingText) loadingText.textContent = 'Loading saved feedback...';
      }
      
      try {
        // Validate sessionId is a valid number before making the request
        const sessionIdNum = parseInt(String(sessionId), 10);
        if (isNaN(sessionIdNum) || sessionIdNum <= 0) {
          throw new Error('Invalid session ID');
        }
        
        const token = await getAuthToken().catch(() => null);
        if (!token) {
          console.warn('[RESUME-FEEDBACK-HISTORY] No auth token for history detail');
          if (window.showToast) window.showToast('Please log in to view history', 'error');
          return;
        }
        
        // Ensure sessionId is URL-encoded for safety (use validated numeric value)
        const encodedSessionId = encodeURIComponent(String(sessionIdNum));
        const response = await fetch(`/api/resume-feedback/history/${encodedSessionId}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          
          // Handle 404 - session not found - refresh history list and show clear message
          if (response.status === 404) {
            console.warn('[RESUME-FEEDBACK-HISTORY] Session not found, refreshing history list');
            // Refresh history list to remove stale/deleted items
            if (window.JobHackAIHistory && typeof window.JobHackAIHistory.refresh === 'function') {
              window.JobHackAIHistory.refresh();
            }
            throw new Error('This session no longer exists. The history list has been refreshed.');
          }
          
          throw new Error(errorData.error || `Failed to load history (${response.status})`);
        }
        
        const data = await response.json();
        console.log('[RESUME-FEEDBACK-HISTORY] Loaded detail:', data);
      
        // Clear role state only after we have successfully loaded history data
        const clearFn = window.clearTargetRoleState || clearTargetRoleState;
        if (typeof clearFn === 'function') {
          clearFn();
        }

        // Clear UI state before repainting with history data to avoid stale content
        resetRewriteUIToDefaults();
        resetAtsAndRoleUIToDefaults();
        
        // Mark as historical view
        _isHistoricalView = true;
        _currentHistoricalSessionId = sessionId;
        
        // Show historical banner
        showHistoricalBanner(data);
        
        // Restore page state from D1 data
        restorePageStateFromHistory(data);
        
        // Update mode/state for saved view
        _selectedHistoryItem = {
          sessionId,
          role: data.role || null,
          fileName: data.fileName || data.file_name || null,
          resumeId: data.resumeId || data.resume_id || null
        };
        updateSavedFileLine(_selectedHistoryItem.fileName);
        setMode('saved');
        
        // Clear file input; user must choose a new file to re-run
        const fileInput = document.getElementById('rf-upload');
        const fileNameSpan = document.getElementById('rf-file-name');
        const statusDiv = document.getElementById('rf-generate-status');
        const fileStatus = document.getElementById('rf-file-status');
        const pdfHelper = document.getElementById('rf-pdf-helper');
        if (fileInput) {
          fileInput.value = '';
        }
        if (fileNameSpan) {
          fileNameSpan.textContent = 'No file selected';
          fileNameSpan.style.color = 'var(--color-text-muted)';
          fileNameSpan.style.fontWeight = 'normal';
        }
        if (statusDiv) statusDiv.style.display = 'none';
        if (fileStatus) fileStatus.style.display = 'none';
        if (pdfHelper) pdfHelper.style.display = 'none';
        
        // Populate target role input for clarity
        const jobTitleInput = document.getElementById('rf-job-title');
        if (jobTitleInput) {
          if (data.role && data.role.trim()) {
            jobTitleInput.value = data.role;
          } else {
            jobTitleInput.value = '';
          }
        }
        
        // Require a new file before re-running (enforced by click guard instead of disabling button)
        const generateBtn = document.getElementById('rf-generate-btn');
        if (generateBtn) {
          // Keep button clickable; generateATSAndFeedback will show a modal if no file is selected
          // generateBtn.disabled = true;
        }
        
        // Mark active history item
        markActiveHistoryItem(sessionId);
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
      } catch (error) {
        console.error('[RESUME-FEEDBACK-HISTORY] Error loading detail:', error);
        if (window.JobHackAIToast) {
          window.JobHackAIToast.error(error.message || 'Failed to load history');
        } else if (window.showToast) {
          window.showToast(error.message || 'Failed to load history', 'error');
        }
      } finally {
        if (loadingOverlay) loadingOverlay.style.display = 'none';
        forceHideOverlays();
      }
    }
    
    /**
     * Show the historical view banner
     */
    function showHistoricalBanner(data) {
      const banner = document.getElementById('rf-historical-banner');
      const bannerText = document.getElementById('rf-historical-banner-text');
      
      if (banner && bannerText) {
        // Format the date
        const date = parseDateSafely(data.createdAt);
        const dateStr = date ? date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric', 
          year: 'numeric' 
        }) : 'saved feedback';
        
        bannerText.textContent = `Viewing saved feedback from ${dateStr}${data.role ? ` for ${data.role}` : ''} â€“ run a new analysis to update.`;
        banner.style.display = 'flex';
      }
    }
    
    /**
     * Hide the historical view banner and clear state
     */
    function resetSession(showBanner = false) {
      let storageCleared = false;
      // Reset high-level state flags (UI only; never touches usage counters)
      _isHistoricalView = false;
      _currentHistoricalSessionId = null;
      _selectedHistoryItem = null;
      setMode('new');

      clearScoreAuthority('reset-session');
      
      // Hide banner
      const banner = document.getElementById('rf-historical-banner');
      if (banner) banner.style.display = 'none';
      
      // Clear selected history item outline
      document.querySelectorAll('.rf-history-item.is-selected').forEach(el => el.classList.remove('is-selected'));
      
      // Reset form and results
      resetFormToDefault();
      updateModeUI();
      
      // Reset saved filename line
      updateSavedFileLine('(file not stored)');
      
      // Clear rewrite UI to defaults
      resetRewriteUIToDefaults();
      // Clear any rewrite cooldown timers/labels when leaving history view
      resetRewriteCooldownState();
      
      // Clear in-memory resume state
      try {
        sessionStorage.removeItem('currentResumeText');
        sessionStorage.removeItem('currentResumeId');
        localStorage.removeItem('jh_last_resume_id');
        storageCleared = true;
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to clear session state', e);
      }
      currentResumeId = null;
      window.latestAtsIssues = null;
      window.latestRoleSpecific = null;
      window.latestRoleSpecificToken = null;
      
      // Show persistent banner to explain destructive reset (BFCache or explicit)
      try {
        if (showBanner && typeof showSessionRestartBanner === 'function') {
          showSessionRestartBanner();
        }
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to show session restart banner', e);
      }
    }
    
    function clearHistoricalView() {
      resetSession();
      
      // Scroll to upload section
      const uploadSection = document.getElementById('rf-ats-score-tile');
      if (uploadSection) uploadSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    
    /**
     * Mark the active history item in the sidebar
     */
    function markActiveHistoryItem(sessionId) {
      // Remove selected from all items
      document.querySelectorAll('.rf-history-item.is-selected').forEach(el => el.classList.remove('is-selected'));
      
      // Add selected outline to current (normal mode)
      const activeItem = document.querySelector(`.rf-history-item[data-session-id="${sessionId}"]`);
      if (activeItem) activeItem.classList.add('is-selected');
    }
    
    /**
     * Reset form to default state
     */
    function resetFormToDefault() {
      clearScoreAuthority('reset-form');
      // Reset file input
      const fileInput = document.getElementById('rf-upload');
      const fileName = document.getElementById('rf-file-name');
      const generateBtn = document.getElementById('rf-generate-btn');
      const statusDiv = document.getElementById('rf-generate-status');
      const fileStatus = document.getElementById('rf-file-status');
      const pdfHelper = document.getElementById('rf-pdf-helper');
      if (fileInput) fileInput.value = '';
      if (fileName) fileName.textContent = 'No file selected';
      
      // Enable button - click guard will handle missing file
      if (generateBtn) generateBtn.disabled = false;
      
      if (statusDiv) statusDiv.style.display = 'none';
      if (fileStatus) fileStatus.style.display = 'none';
      if (pdfHelper) pdfHelper.style.display = 'none';
      clearTargetRoleState();
      const changeSummary = document.getElementById('rf-change-summary');
      if (changeSummary) {
        changeSummary.innerHTML = '';
        changeSummary.style.display = 'none';
      }
      
      // Reset score ring
      const svg = document.querySelector('#rf-ats-score-tile .rf-progress-ring svg');
      const scoreRing = svg ? svg.querySelectorAll('circle')[1] : null;
      const scoreText = svg ? svg.querySelector('text') : null;
      if (scoreRing) {
        scoreRing.style.strokeDashoffset = '';
        scoreRing.setAttribute('stroke-dashoffset', '226.2');
        scoreRing.setAttribute('stroke', '#00E676');
      }
      if (scoreText) scoreText.textContent = '0%';
      
      // Hide extraction quality indicator
      updateExtractionQualityIndicator(null);
      
      // Hide feedback sections and role info
      const feedbackContent = document.getElementById('rf-feedback-content');
      const rubricGrid = document.getElementById('rf-rubric-grid');
      const feedbackGrid = document.getElementById('rf-feedback-grid');
      const roleInfoBar = document.getElementById('rf-role-info');
      if (feedbackContent) feedbackContent.style.display = 'none';
      if (rubricGrid) rubricGrid.style.display = 'none';
      if (feedbackGrid) feedbackGrid.style.display = 'none';
      if (roleInfoBar) {
        roleInfoBar.style.display = 'none';
        roleInfoBar.textContent = '';
      }
      // Clear role-specific status but keep the tile visible for the next run
      setRoleStatus('');
      // ROLE TIPS LOCK: Don't mutate role container if role tips are in-flight
      if (!isRoleTipsLocked()) {
        const roleContainer = document.getElementById('role-feedback-container');
        if (roleContainer) roleContainer.style.display = 'block';
        const roleBadge = document.getElementById('rf-role-badge');
        if (roleBadge) roleBadge.style.display = 'none';
        const roleHelper = document.getElementById('rf-role-helper');
        if (roleHelper) roleHelper.style.display = 'none';
        const regenBtn = document.getElementById('rf-regenerate-btn');
        if (regenBtn) {
          regenBtn.style.display = 'none';
          regenBtn.textContent = 'Regenerate Feedback';
          regenBtn.disabled = false;
        }
        const roleDescEl = document.getElementById('rf-role-desc');
        if (roleDescEl && roleDescEl.dataset.baseText) {
          roleDescEl.textContent = roleDescEl.dataset.baseText;
          delete roleDescEl.dataset.lastRoleState;
        }
      }

      // Restore default score description and badge when exiting history
      if (typeof updateRfTileForPlan === 'function') {
        updateRfTileForPlan();
      } else {
        // Fallback: minimally reset score description while preserving tooltip
        const scoreDesc = document.getElementById('rf-header-desc');
        if (scoreDesc) {
          scoreDesc.innerHTML = 'Get your basic ATS compatibility score.';
        }
      }
    }
    
    /**
     * Restore full page state from history data (D1-only, NO OpenAI)
     */
    function restorePageStateFromHistory(data) {
      const atsRubric = data.atsRubric || data.feedback?.atsRubric || null;
      const atsIssues = data.atsIssues || data.feedback?.atsIssues || null;
      const roleSpecificFeedback = data.roleSpecificFeedback || data.feedback?.roleSpecificFeedback || null;
      const rewritten = data.rewrittenResume || data.feedback?.rewrittenResume || null;
      const rewriteSummary = data.rewriteChangeSummary || data.changeSummary || data.feedback?.rewriteChangeSummary || data.feedback?.changeSummary || null;
      const original = data.originalResume || data.feedback?.originalResume || null;

      // Historical views are fully loaded; hide any in-progress UI elements
      hideRewriteSkeleton();
      hideSkeletons();
      // Reset cooldown/timers and button labels for history view
      resetRewriteCooldownState();

      // Sync rewrite context to match the historical record (D1 as source of truth)
      window.latestAtsIssues = atsIssues || null;
      window.latestRoleSpecific = roleSpecificFeedback || null;
      // History/restored content is not associated with a live run token.
      window.latestRoleSpecificToken = null;
      // Ensure rewrite actions reference the historical resume, not the last uploaded one
      currentResumeId = data.resumeId || data.resume_id || currentResumeId;

      // Update ATS score ring using shared logic (clamps/guards inside)
      if (data.atsScore !== null && data.atsScore !== undefined) {
        const candidate = {
          runKey: data.sessionId || `history-${data.resumeId || currentResumeId || 'unknown'}-${Date.now()}`,
          resumeId: data.resumeId || currentResumeId,
          role: data.role || data.feedback?.role || '',
          score: data.atsScore,
          breakdown: data.atsRubric || data.breakdown || null,
          source: 'history_user',
          timestamp: data.createdAt ? new Date(data.createdAt).getTime() : Date.now()
        };
        const applied = attemptApplyScoreCandidate(
          candidate,
          () => {
            updateProgressRing(data.atsScore);
            const scoreDesc = document.getElementById('rf-header-desc');
            if (scoreDesc) {
              if (data.role && data.role.trim()) {
                scoreDesc.innerHTML = `Your resume scored <strong>${data.atsScore}%</strong> for ${escapeHtml(data.role)} roles.`;
              } else {
                scoreDesc.innerHTML = `Your resume scored <strong>${data.atsScore}%</strong>.`;
              }
            }
          },
          {
            resumeId: candidate.resumeId,
            role: candidate.role
          }
        );
        if (!applied) {
          console.log('[RESUME-FEEDBACK] History score blocked by authority', candidate);
        }
      }
      
      // Show and populate feedback content
      const feedbackContent = document.getElementById('rf-feedback-content');
      if (feedbackContent) feedbackContent.style.display = 'block';
      
      // Populate ATS rubric
      if (atsRubric && Array.isArray(atsRubric)) {
        populateAtsRubric(atsRubric);
        hideATSSkeleton();
      } else {
        const rubricGrid = document.getElementById('rf-rubric-grid');
        if (rubricGrid) {
          rubricGrid.innerHTML = '<div style="color:var(--color-text-secondary);font-size:0.95rem;">No ATS fixes saved for this run.</div>';
          rubricGrid.style.display = 'grid';
        }
      }
      
      // Populate role-specific feedback
      // ROLE TIPS LOCK: Don't mutate role tips UI if role tips are in-flight
      if (!isRoleTipsLocked()) {
        if (roleSpecificFeedback) {
          const feedbackGrid = document.getElementById('rf-feedback-grid');
          if (feedbackGrid && feedbackGrid.dataset) {
            delete feedbackGrid.dataset.placeholder;
          }
          populateRoleSpecificFeedback(roleSpecificFeedback, data.role);
        } else {
          const roleContainer = document.getElementById('role-feedback-container');
          const feedbackGrid = document.getElementById('rf-feedback-grid');
          if (feedbackGrid) {
            feedbackGrid.innerHTML = '<div style="color:var(--color-text-secondary);font-size:0.95rem;">No role tips saved for this run.</div>';
            feedbackGrid.style.display = 'grid';
            if (feedbackGrid.dataset) {
              feedbackGrid.dataset.placeholder = 'role-none';
            }
          }
          if (roleContainer) roleContainer.style.display = 'block';
        }
      }
      
      // ROLE TIPS LOCK: Don't restore if role tips are in-flight
      if (!isRoleTipsLocked()) {
        updateRoleTipsState({
          hasAtsScore: typeof data.atsScore === 'number',
          roleSpecificFeedback: roleSpecificFeedback || null,
          allowPlaceholder: !roleSpecificFeedback
        });
      }
      
      // Update plan limit text based on current plan
      updatePlanLimitText();
      
      // Handle rewrite data based on plan gating
      const rewriteContent = document.getElementById('rf-rewrite-content');
      const rewritePrompt = document.querySelector('#rf-rewrite-tile .rf-upgrade-prompt');
      const rewrittenTextarea = rewriteContent ? rewriteContent.querySelectorAll('.rf-snippet-box')[1] : null;
      const originalTextarea = rewriteContent ? rewriteContent.querySelectorAll('.rf-snippet-box')[0] : null;
      const rewriteDescInline = document.getElementById('rf-rewrite-desc-inline');

      if (data.rewriteLocked) {
        if (rewriteContent) rewriteContent.style.display = 'none';
        if (rewritePrompt) {
          rewritePrompt.style.display = 'block';
          const promptText = rewritePrompt.querySelector('.rf-upgrade-text');
          if (promptText) {
            promptText.innerHTML = 'AI resume rewrites are a Pro/Premium feature. Upgrade to unlock your detailed rewrites for this resume.';
          }
        }
        if (rewrittenTextarea) rewrittenTextarea.value = '';
        if (rewriteDescInline) rewriteDescInline.style.display = 'none';
        setCopyRewriteVisibility(false);
        if (originalTextarea && originalTextarea.value) {
          // keep original text if present
        }
      } else {
        if (rewritePrompt) rewritePrompt.style.display = 'none';
        if (rewriteContent) rewriteContent.style.display = 'block';

        const resolvedRewrite = rewritten || data.rewrittenResume || data.rewritten || data.feedback?.rewrittenResume || '';
        const hasRewriteContent = typeof resolvedRewrite === 'string' && resolvedRewrite.trim().length > 0;

        if (rewrittenTextarea) {
          if (rewritten) {
            rewrittenTextarea.value = rewritten;
          } else if (rewriteSummary) {
            const formattedSummary = formatRewriteChangeSummary(rewriteSummary);
            rewrittenTextarea.value = formattedSummary
              ? `Summary of changes:\n${formattedSummary}`
              : 'No rewrite available for this run yet.';
          } else {
            rewrittenTextarea.value = 'No rewrite available for this run yet.';
          }
        }
        if (rewriteDescInline) {
          rewriteDescInline.style.display = hasRewriteContent ? 'block' : 'none';
        }
        setCopyRewriteVisibility(hasRewriteContent);
        
        // Also populate original snippet if available
        if (originalTextarea && original) {
          originalTextarea.value = original;
        }
      }

      // Always display change summary (ATS Fixes / Role Tailoring) when present
      displayChangeSummary(rewriteSummary || data.changeSummary || data.feedback?.rewriteChangeSummary || null);
    }
    
    /**
     * Populate ATS rubric grid from saved data
     */
    function populateAtsRubric(atsRubric) {
      const rubricGrid = document.getElementById('rf-rubric-grid');
      if (!rubricGrid) return;
      
      // Helper to get canonical max value from category label
      const getCanonicalMax = (categoryLabel) => {
        const label = (categoryLabel || '').toLowerCase();
        if (label.includes('keyword')) return ATS_RUBRIC_MAX.KEYWORD_RELEVANCE;
        if (label.includes('format')) return ATS_RUBRIC_MAX.FORMATTING_COMPLIANCE;
        if (label.includes('structure') || label.includes('section') || label.includes('organization')) return ATS_RUBRIC_MAX.STRUCTURE_COMPLETENESS;
        if (label.includes('tone') || label.includes('clarity')) return ATS_RUBRIC_MAX.TONE_CLARITY;
        if (label.includes('grammar') || label.includes('spelling')) return ATS_RUBRIC_MAX.GRAMMAR_SPELLING;
        return ATS_RUBRIC_MAX.GRAMMAR_SPELLING; // Default fallback
      };
      
      rubricGrid.innerHTML = atsRubric.map(item => {
        const canonicalMax = getCanonicalMax(item.category || item.label);
        return `
        <div class="rf-rubric-item">
          <div class="rf-rubric-label">${escapeHtml(item.category || '')}</div>
          <div class="rf-rubric-score">${item.score || 0} / ${canonicalMax}</div>
          <div style="color:var(--color-text-secondary);font-size:0.95rem;margin-top:0.5rem;">${escapeHtml(item.feedback || '')}</div>
          ${item.suggestions && item.suggestions.length > 0 ? `
            <ul style="margin-top:0.5rem;padding-left:1.25rem;color:var(--color-text-muted);font-size:0.9rem;">
              ${item.suggestions.map(s => `<li>${escapeHtml(s)}</li>`).join('')}
            </ul>
          ` : ''}
        </div>
      `;
      }).join('');
      
      rubricGrid.style.display = 'grid';
      applyFadeIn(rubricGrid);
    }
    
    /**
     * Populate role-specific feedback from saved data
     */
    function populateRoleSpecificFeedback(roleSpecificFeedback, targetRole) {
      const feedbackGrid = document.getElementById('rf-feedback-grid');
      const roleTitle = document.getElementById('rf-role-title');
      const roleTitleText = document.getElementById('rf-role-title-text');
      const roleDesc = document.getElementById('rf-role-desc');
      
      if (!feedbackGrid) return;
      
      // Update title text without removing tooltip
      if (roleTitleText) {
        roleTitleText.textContent = 'Role-Specific Tailoring Tips';
      }
      if (roleDesc && targetRole) {
        roleDesc.textContent = `How to tune your resume for ${targetRole} roles.`;
      }
      
      // Handle both old array format and new object format
      const sections = roleSpecificFeedback.sections || (Array.isArray(roleSpecificFeedback) ? roleSpecificFeedback : []);
      
      // CRITICAL: Filter to only valid object sections to prevent blank "Tunable" cards
      // Keep only entries that are objects with meaningful content
      // Must handle both NEW format (diagnosis, tips, rewritePreview) and OLD format (feedback, tip)
      const validSections = sections.filter(section => {
        // Must be an object (not string, null, array, etc.)
        if (!section || typeof section !== 'object' || Array.isArray(section)) {
          return false;
        }
        
        // NEW format: check for new format fields
        const hasDiagnosis = typeof section.diagnosis === 'string' && section.diagnosis.trim().length > 0;
        const hasTips = Array.isArray(section.tips) && section.tips.length > 0;
        const hasRewritePreview = typeof section.rewritePreview === 'string' && section.rewritePreview.trim().length > 0;
        const hasNewFormat = hasDiagnosis || hasTips || hasRewritePreview;
        
        // OLD format: check for old format fields (feedback or tip)
        const hasFeedback = typeof section.feedback === 'string' && section.feedback.trim().length > 0;
        const hasTip = typeof section.tip === 'string' && section.tip.trim().length > 0;
        const hasOldFormat = hasFeedback || hasTip;
        
        return hasNewFormat || hasOldFormat;
      });
      
      if (validSections.length === 0) {
        // Show helpful message instead of blank cards
        feedbackGrid.innerHTML = `
          <div class="rf-feedback-card" style="grid-column: 1 / -1; text-align: center; padding: 2rem;">
            <div style="color: var(--color-text-muted); font-style: italic;">
              Role-specific tips couldn't be generated for this upload. Try uploading a PDF or re-running.
            </div>
          </div>
        `;
        feedbackGrid.style.display = 'grid';
        applyFadeIn(feedbackGrid);
        return;
      }
      
      feedbackGrid.innerHTML = validSections.map(section => {
        // Detect format: old format has feedback/tip but not diagnosis/tips/rewritePreview
        const isOldFormat = (typeof section.feedback === 'string' || typeof section.tip === 'string') && 
                           !section.diagnosis && !Array.isArray(section.tips) && !section.rewritePreview;
        
        if (isOldFormat) {
          // Render OLD format
          const scoreDisplay = (section.score === undefined || section.score === null) ? 'â€” / â€”' : escapeHtml(section.score);
          return `
            <div class="rf-feedback-card">
              <div class="rf-feedback-label">
                ${escapeHtml(section.section || section.label || 'Section')} <span class="rf-feedback-score">${scoreDisplay}</span>
              </div>
              <div class="rf-feedback-tip">${escapeHtml(section.feedback || section.tip || '')}</div>
            </div>
          `;
        }
        
        // Render NEW format
        const fitChipClass = {
          'big_impact': 'rf-fit-chip-big-impact',
          'tunable': 'rf-fit-chip-tunable',
          'strong': 'rf-fit-chip-strong'
        }[section.fitLevel] || 'rf-fit-chip-tunable';
        
        const fitLabel = {
          'big_impact': 'Big Impact Opportunity',
          'tunable': 'Good but Tunable',
          'strong': 'Strong Match'
        }[section.fitLevel] || 'Tunable';
        
        return `
          <div class="rf-feedback-card">
            <div class="rf-feedback-label" style="display:flex;justify-content:space-between;align-items:center;">
              <span>${escapeHtml(section.section || '')}</span>
              <span class="${fitChipClass}" style="padding:0.25rem 0.75rem;border-radius:12px;font-size:0.75rem;font-weight:600;">${fitLabel}</span>
            </div>
            <div style="color:var(--color-text-main);margin-bottom:0.75rem;font-weight:500;line-height:1.5;">
              ${escapeHtml(section.diagnosis || '')}
            </div>
            ${section.tips && section.tips.length > 0 ? `
              <ul style="margin:0 0 0.75rem 0;padding-left:1.25rem;color:var(--color-text-secondary);line-height:1.6;">
                ${section.tips.map(tip => `<li style="margin-bottom:0.5rem;">${escapeHtml(tip)}</li>`).join('')}
              </ul>
            ` : ''}
            ${section.rewritePreview ? `
              <div style="margin-top:0.75rem;padding-top:0.75rem;border-top:1px solid var(--color-divider);">
                <div style="font-size:0.75rem;font-weight:600;color:var(--color-text-muted);margin-bottom:0.5rem;text-transform:uppercase;letter-spacing:0.5px;">AI Rewrite Preview</div>
                <div style="color:var(--color-text-secondary);font-style:italic;font-size:0.9rem;line-height:1.5;">${escapeHtml(section.rewritePreview)}</div>
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
      
      feedbackGrid.style.display = 'grid';
      applyFadeIn(feedbackGrid);
    }
    
    /**
     * Update plan limit text based on current plan
     */
    function updatePlanLimitText() {
      const planLimit = document.getElementById('rf-plan-limit');
      const userPlan = getCurrentUserPlan();
      
      if (!planLimit) return;
      
      const planMessages = {
        'trial': 'Your trial includes <strong>3 total detailed feedback runs</strong>. ATS scoring is always unlimited.',
        'essential': 'Your Essential plan includes <strong>3 detailed feedback runs per month</strong>. ATS scoring is always unlimited.',
        'pro': 'Your Pro plan includes <strong>unlimited detailed feedback runs</strong>.',
        'premium': 'Your Premium plan includes <strong>unlimited detailed feedback runs</strong> with priority processing.'
      };
      
      planLimit.innerHTML = `<span>${planMessages[userPlan] || planMessages['trial']}</span>`;
    }
    
    /**
     * Simple HTML escape helper
     */
    function escapeHtml(str) {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    /**
     * Fetch history from the D1-backed API
     */
    async function fetchResumeFeedbackHistory() {
      const emptyEl = document.getElementById('rf-history-empty');
      const listEl = document.getElementById('rf-history-list');
      // Show loading skeleton, hide error + empty
      setHistoryErrorVisible(false);
      setHistoryLoading(true);
      if (emptyEl) emptyEl.hidden = true;
      if (listEl) listEl.innerHTML = '';
      
      try {
        const token = await getAuthToken().catch(() => null);
        if (!token) {
          console.warn('[RESUME-FEEDBACK-HISTORY] No auth token available');
          _historyItems = [];
          setHistoryLoading(false);
          renderHistoryItems([]);
          return;
        }
        
        const response = await fetch('/api/resume-feedback/history?limit=10', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          console.warn('[RESUME-FEEDBACK-HISTORY] API returned error:', response.status);
          _historyItems = [];
          setHistoryLoading(false);
          setHistoryErrorVisible(true, 'Couldnâ€™t load history.');
          renderHistoryItems([]);
          return;
        }
        
        const data = await response.json();
        _historyItems = data.items || [];
        setHistoryLoading(false);
        console.log('[RESUME-FEEDBACK-HISTORY] Loaded history:', _historyItems.length, 'items');
        renderHistoryItems(_historyItems);
        
      } catch (error) {
        console.error('[RESUME-FEEDBACK-HISTORY] Error fetching history:', error);
        _historyItems = [];
        setHistoryLoading(false);
        setHistoryErrorVisible(true, 'Couldnâ€™t load history.');
        renderHistoryItems([]);
      }
    }
    
    /**
     * Add a new item to the top of the history list (optimistic update)
     * Called after a successful feedback run
     */
    function addHistoryItem(sessionId, meta) {
      if (!sessionId) return;
      
      // Skip if this session already exists in the current list
      const alreadyExists = _historyItems.some(item => item.sessionId === sessionId);
      if (alreadyExists) {
        console.log('[RESUME-FEEDBACK-HISTORY] Skipping duplicate history item:', sessionId);
        return;
      }
      
      const newItem = {
        sessionId: sessionId,
        title: meta?.title || null,
        role: meta?.role || null,
        createdAt: meta?.createdAt || new Date().toISOString(),
        hasFeedback: true
      };
      
      // Add to the front of the list
      _historyItems = [newItem, ..._historyItems];
      
      // Re-render
      renderHistoryItems(_historyItems);
      
      console.log('[RESUME-FEEDBACK-HISTORY] Added new item to history:', sessionId);
    }
    
    /**
     * Initialize history on page load
     */
    function initializeHistory() {
      // Only load history if user is authenticated
      // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
      // FirebaseAuthManager.getCurrentUser() returns null until onAuthStateChanged fires
      // Use same pattern as checkAuthentication() for consistency
      function hasFirebaseAuthKeys() {
        try {
          return Object.keys(localStorage).some(k => 
            k.startsWith('firebase:authUser:') && 
            localStorage.getItem(k) && 
            localStorage.getItem(k) !== 'null' &&
            localStorage.getItem(k).length > 10
          );
        } catch (e) {
          return false;
        }
      }
      const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
      const hasFirebaseKeys = hasFirebaseAuthKeys();
      const isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
      if (!isAuthenticated) {
        console.log('[RESUME-FEEDBACK-HISTORY] Skipping history load - not authenticated');
        const emptyEl = document.getElementById('rf-history-empty');
        setHistoryLoading(false);
        setHistoryErrorVisible(false);
        if (emptyEl) emptyEl.hidden = false;
        return;
      }
      
      // Load history from server
      fetchResumeFeedbackHistory();
      
      // Set up refresh button
      const refreshBtn = document.getElementById('rf-history-refresh');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', function(e) {
          e.preventDefault();
          if (_historyManageMode) return;
          fetchResumeFeedbackHistory();
        });
      }

      // Retry link
      const retryBtn = document.getElementById('rf-history-retry');
      if (retryBtn) {
        retryBtn.addEventListener('click', function(e) {
          e.preventDefault();
          fetchResumeFeedbackHistory();
        });
      }

      // Manage mode controls
      const manageBtn = document.getElementById('rf-history-manage');
      if (manageBtn) {
        manageBtn.addEventListener('click', function(e) {
          e.preventDefault();
          setHistoryManageMode(true);
        });
      }

      const cancelManageBtn = document.getElementById('rf-history-cancel-manage');
      if (cancelManageBtn) {
        cancelManageBtn.addEventListener('click', function(e) {
          e.preventDefault();
          setHistoryManageMode(false);
        });
      }

      const deleteSelectedBtn = document.getElementById('rf-history-delete-selected');
      if (deleteSelectedBtn) {
        deleteSelectedBtn.addEventListener('click', function(e) {
          e.preventDefault();
          if (_historySelectedIds.size < 1) return;
          openDeleteModalFor(Array.from(_historySelectedIds));
        });
      }

      // Retention footer: Clear history
      const clearBtn = document.getElementById('rf-history-clear');
      if (clearBtn) {
        clearBtn.addEventListener('click', function(e) {
          e.preventDefault();
          const ids = getVisibleHistoryIds();
          if (!ids.length) {
            return;
          }
          if (!_historyManageMode) setHistoryManageMode(true);
          _historySelectedIds = new Set(ids);
          syncBulkDeleteState();
          renderHistoryItems(_historyItems);
          openDeleteModalFor(ids);
        });
      }

      // Modal actions
      const modalCancel = document.getElementById('rf-history-modal-cancel');
      const modalConfirm = document.getElementById('rf-history-modal-confirm');
      const modal = document.getElementById('rf-history-delete-modal');
      const backdrop = document.getElementById('rf-history-modal-backdrop');

      if (modalCancel) {
        modalCancel.addEventListener('click', function(e) {
          e.preventDefault();
          closeDeleteModal();
        });
      }
      if (backdrop) {
        backdrop.addEventListener('click', function() {
          closeDeleteModal();
        });
      }
      if (modalConfirm) {
        modalConfirm.addEventListener('click', async function(e) {
          e.preventDefault();
          const ids = Array.from(new Set(_historyPendingDeleteIds));
          if (!ids.length) return;
          modalConfirm.disabled = true;
          try {
            const { failures } = await deleteResumeFeedbackHistoryItems(ids);
            ids.forEach((id) => _historySelectedIds.delete(id));
            syncBulkDeleteState();
            closeDeleteModal();
            await fetchResumeFeedbackHistory();
            if (failures.length) {
              const failureReason = failures[0].result?.reason;
              const failureMessage = failureReason?.message
                || 'Some selected entries could not be deleted. History refreshed to reflect the current state.';
              setHistoryErrorVisible(true, failureMessage);
            } else {
              setHistoryErrorVisible(false);
            }
          } catch (err) {
            console.warn('[RESUME-FEEDBACK-HISTORY] Delete failed:', err);
            closeDeleteModal();
            const failureMessage = err?.message || 'Failed to delete selected history.';
            setHistoryErrorVisible(true, failureMessage);
            await fetchResumeFeedbackHistory().catch(() => {});
            _historySelectedIds.clear();
            syncBulkDeleteState();
          } finally {
            modalConfirm.disabled = false;
          }
        });
      }

      // Focus trap + ESC close for modal
      if (modal && !modal.dataset.bound) {
        modal.dataset.bound = '1';
        modal.addEventListener('keydown', function(e) {
          if (e.key === 'Escape') {
            e.preventDefault();
            closeDeleteModal();
            return;
          }
          if (e.key !== 'Tab') return;
          const focusables = modal.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])');
          const list = Array.from(focusables).filter((el) => !el.disabled && el.offsetParent !== null);
          if (!list.length) return;
          const first = list[0];
          const last = list[list.length - 1];
          const active = document.activeElement;
          if (e.shiftKey && active === first) {
            e.preventDefault();
            last.focus();
          } else if (!e.shiftKey && active === last) {
            e.preventDefault();
            first.focus();
          }
        });
      }

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          const backdropEl = document.getElementById('rf-history-modal-backdrop');
          if (backdropEl && !backdropEl.hidden) {
            closeDeleteModal();
          }
          closeAllHistoryMenus();
        }
      });

      // Row interactions (delegated)
      const listEl = document.getElementById('rf-history-list');
      if (listEl && !listEl.dataset.bound) {
        listEl.dataset.bound = '1';

        listEl.addEventListener('click', function(e) {
          const actionEl = e.target.closest('[data-action]');
          const rowEl = e.target.closest('.rf-history-item');
          const sessionId = actionEl?.dataset?.sessionId || rowEl?.dataset?.sessionId || '';
          if (!rowEl || !sessionId) return;

          const action = actionEl?.dataset?.action || null;
          if (action === 'menu-toggle') {
            e.preventDefault();
            e.stopPropagation();
            // toggle this menu, close others
            const menu = rowEl.querySelector('.rf-history-menu');
            if (!menu) return;
            const willOpen = menu.hidden;
            closeAllHistoryMenus();
            menu.hidden = !willOpen;
            _historyMenuOpenForSessionId = willOpen ? String(sessionId) : null;
            return;
          }

          if (action === 'open') {
            e.preventDefault();
            e.stopPropagation();
            closeAllHistoryMenus();
            loadHistoryDetail(sessionId);
            return;
          }

          if (action === 'delete') {
            e.preventDefault();
            e.stopPropagation();
            closeAllHistoryMenus();
            openDeleteModalFor([sessionId]);
            return;
          }

          if (action === 'toggle-select') {
            e.preventDefault();
            e.stopPropagation();
            if (_historySelectedIds.has(String(sessionId))) _historySelectedIds.delete(String(sessionId));
            else _historySelectedIds.add(String(sessionId));
            syncBulkDeleteState();
            renderHistoryItems(_historyItems);
            return;
          }

          // Row click default
          if (_historyManageMode) {
            if (_historySelectedIds.has(String(sessionId))) _historySelectedIds.delete(String(sessionId));
            else _historySelectedIds.add(String(sessionId));
            syncBulkDeleteState();
            renderHistoryItems(_historyItems);
            return;
          }

          loadHistoryDetail(sessionId);
        });

        function isInteractiveKeyTarget(element) {
          if (!element) return false;
          const interactiveSelector = 'button, input, textarea, select, a, [role="button"], [role="link"], [contenteditable="true"]';
          return Boolean(element.closest && element.closest(interactiveSelector));
        }

        listEl.addEventListener('keydown', function(e) {
          const rowEl = e.target.closest('.rf-history-item');
          if (!rowEl) return;
          if (e.key !== 'Enter' && e.key !== ' ') return;
          if (isInteractiveKeyTarget(e.target)) return;
          e.preventDefault();
          const sessionId = rowEl.dataset.sessionId;
          if (!sessionId) return;
          if (_historyManageMode) {
            if (_historySelectedIds.has(String(sessionId))) _historySelectedIds.delete(String(sessionId));
            else _historySelectedIds.add(String(sessionId));
            syncBulkDeleteState();
            renderHistoryItems(_historyItems);
          } else {
            loadHistoryDetail(sessionId);
          }
        });
      }

      // Close menus on outside click
      document.addEventListener('click', function(e) {
        const withinMenu = e.target.closest('.rf-history-row-actions');
        if (!withinMenu) closeAllHistoryMenus();
      });
    }
    
    // Initialize history when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeHistory);
    } else {
      // DOM already loaded, init after a short delay to allow other scripts
      setTimeout(initializeHistory, 200);
    }
    
    // Expose history functions globally
    window.JobHackAIHistory = {
      addItem: addHistoryItem,
      refresh: fetchResumeFeedbackHistory,
      loadDetail: loadHistoryDetail,
      clearHistoricalView: clearHistoricalView,
      isHistoricalView: () => _isHistoricalView,
      getCurrentSessionId: () => _currentHistoricalSessionId
    };
  </script>
  <script src="js/main.js" type="module"></script>

  <!-- page content -->
  <main style="margin:2rem auto 4rem auto;padding:0 var(--space-md);">
    <div class="rf-layout-container">
      <!-- Main Column -->
      <div class="rf-main-column">
        <!-- Historical View Banner (hidden by default, shown when viewing history) -->
        <div class="rf-historical-banner" id="rf-historical-banner" style="display:none;">
          <div class="rf-historical-banner-text">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <polyline points="12 6 12 12 16 14"/>
            </svg>
            <span id="rf-historical-banner-text">Viewing saved feedback from Jan 15, 2025</span>
          </div>
          <button class="btn-primary" id="rf-run-new-analysis-btn" onclick="window.JobHackAIHistory.clearHistoricalView()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
            </svg>
            Run New Analysis
          </button>
        </div>
        
        <!-- Header Card (New) -->
        <section class="rf-card" id="rf-header-card">
          <div class="rf-title" id="rf-header-title" style="margin-bottom:0.2rem;">
            Smart Resume Tools
            <span class="rf-plan-badge rf-plan-badge--pending" id="rf-header-plan-badge" aria-hidden="true"></span>
          </div>
          
          <div style="color:var(--color-text-secondary);margin:0.35rem 0 0.7rem;" id="rf-header-desc">
            Upload your resume once. Improve it step-by-step with ATS insights, role-specific feedback, and AI-powered rewrites!
          </div>
          
          <!-- Divider (matching interview questions style) -->
          <div style="margin-top: 1.25rem; padding-top: 1rem; border-top: 1px solid var(--color-divider);"></div>
          
          <!-- Usage Indicator Container -->
          <div class="rf-plan-limit" style="margin-top: 1rem;">
            <div id="rf-usage-container"></div>
          </div>
        </section>

        <!-- ATS Score Tile -->
    <section class="rf-card" id="rf-ats-score-tile">
      <div style="display:flex;align-items:center;gap:2.5rem;flex-wrap:wrap;">
        <div class="rf-progress-ring">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="36" stroke="#E5E7EB" stroke-width="8" fill="none"/>
            <circle cx="40" cy="40" r="36" stroke="#00E676" stroke-width="8" fill="none" stroke-dasharray="226.2" stroke-dashoffset="226.2" stroke-linecap="round"/>
            <text x="40" y="48" text-anchor="middle" font-size="1.6rem" font-weight="700" fill="#1F2937">0%</text>
           </svg>
           <div id="rf-extraction-quality-indicator" class="rf-status-pill" style="display:none;margin-top:0.5rem;width:100%;justify-content:center;flex-shrink:0;">
             <span class="rf-status-icon"></span>
             <span class="rf-status-text"></span>
           </div>
        </div>
        <div style="flex:1;min-width:220px;">
          <form id="rf-upload-form" style="margin:1rem 0 0.7rem 0;">
            <label for="rf-job-title" style="font-weight:600;display:block;margin-bottom:0.5rem;">Target Role <span style="font-weight:400;color:var(--color-text-muted);font-size:0.9em;">(Recommended for better results)</span></label>
            <div style="position:relative;max-width:400px;margin-bottom:1rem;">
              <input 
                id="rf-job-title" 
                type="text" 
                placeholder="Start typing your target role (e.g., Software Engineer, Product Manager)" 
                class="rf-role-input"
                style="width:100%;padding:0.85rem 1.1rem;border:2px solid #E5E7EB;border-radius:10px;font-size:1.08rem;margin-bottom:0;transition:border 0.18s;background:#fff;color:#232B36;box-sizing:border-box;"
                role="combobox" 
                aria-autocomplete="list" 
                aria-expanded="false" 
                aria-controls="rf-role-list"
                autocomplete="off"
                value="">
              <div id="rf-role-list" class="rf-role-dropdown" role="listbox" style="display:none;position:absolute;left:0;right:0;background:#fff;border:1.5px solid #E5E7EB;border-top:none;border-radius:0 0 10px 10px;box-shadow:0 2px 8px rgba(31,41,55,0.07);z-index:10;max-height:220px;overflow-y:auto;margin-top:-2px;top:100%;"></div>
            </div>
            <div style="font-size:0.85rem;color:var(--color-text-muted);margin-bottom:1rem;line-height:1.4;">Adding a role helps us provide role-specific keyword suggestions, tailored feedback, and optimized resume rewriting.</div>
            <label for="rf-upload" style="font-weight:600;display:block;margin-bottom:0.5rem;">Resume File</label>
            <div id="rf-saved-file-line" style="display:none;font-size:0.9rem;color:var(--color-text-muted);margin-bottom:0.35rem;">
              Resume used in this run: <span id="rf-saved-file-name">(file not stored)</span>
            </div>
            <div style="display:flex;align-items:center;gap:0.75rem;flex-wrap:wrap;margin-bottom:0.5rem;">
              <label for="rf-upload" style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.5rem 1rem;background:var(--color-card-bg);border:1px solid var(--color-divider);border-radius:var(--radius-md);font-size:0.875rem;font-weight:600;color:var(--color-text-main);cursor:pointer;transition:all 0.2s;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                  <polyline points="17 8 12 3 7 8"></polyline>
                  <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
                Choose File
              </label>
              <span id="rf-file-name" style="font-size:0.875rem;color:var(--color-text-muted);">No file selected</span>
            </div>
            <div id="rf-file-status" class="rf-status-pill" style="display: none;">
              <span class="rf-status-icon"></span>
              <span class="rf-status-text"></span>
            </div>
            <div style="font-size:0.85rem;color:var(--color-text-muted);margin-bottom:0.75rem;line-height:1.4;">Supported formats: PDF, DOCX, or TXT. Maximum file size: 2 MB.</div>
            <div id="rf-pdf-helper" style="font-size: 0.85rem; color: var(--color-text-muted); margin-top: 0.5rem; line-height: 1.4; display: none;">
              PDF resumes may take around 10â€“15 seconds to fully analyze.
            </div>
            <input id="rf-upload" type="file" accept=".pdf,.docx,.txt,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document,text/plain" style="position:absolute;opacity:0;width:0;height:0;pointer-events:none;">
            <div id="rf-button-row" style="display:flex;align-items:center;gap:0.65rem;flex-wrap:wrap;margin-top:0.5rem;">
              <button
                type="button"
                id="rf-generate-btn"
                class="btn-primary"
                disabled
                tabindex="0"
                aria-label="Generate ATS Score and Feedback"
                style="min-height:44px;"
              >
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:0.35rem;">
                  <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                </svg>
                <span id="rf-generate-label">Generate ATS Score &amp; Feedback</span>
              </button>
              <button type="button" id="rf-start-fresh-btn" class="rf-btn-ghost" style="min-height:44px;">
                Start Fresh
              </button>
            </div>
          </form>
        </div>
      </div>
    </section>

    <!-- ATS Score & Feedback Tile -->
    <section class="rf-card" id="rf-feedback-tile">
      <div class="rf-title">
        ATS Score & Feedback
        <span class="rf-plan-badge" style="background:#6B7280;">Locked</span>
      </div>
      <div style="color:var(--color-text-secondary);margin:0.25rem 0 1.2rem;">
        Run ATS Score &amp; Feedback to see your detailed breakdown here.
        <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.35em; vertical-align:middle;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false" style="width:18px; height:18px;">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="8"/>
            <line x1="12" y1="12" x2="12" y2="16"/>
          </svg>
          <span class="rf-tooltip-text">Get comprehensive feedback on keyword matching, formatting, structure, tone, and grammar to improve your resume's ATS compatibility.</span>
        </span>
      </div>
      <div class="rf-upgrade-prompt" style="display:none !important;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12h14"/>
        </svg>
        <div class="rf-upgrade-text">
          <strong>Upgrade to Pro</strong> to unlock detailed ATS and role-specific feedback.
        </div>
        <a href="#" class="btn btn-secondary" onclick="startCheckout('pro'); return false;">Upgrade Now</a>
      </div>
      <!-- Phase 4.3: Locked feature data notice -->
      <div id="rf-locked-data-notice" style="display:none;background:#F3F4F6;border-left:3px solid #6B7280;padding:0.75rem 1rem;border-radius:8px;margin-top:1rem;font-size:0.875rem;color:#374151;line-height:1.5;">
        <strong>Data Notice:</strong> Your uploaded resume stays available in your history for 90 days (last 10 runs), even if this tool is locked.
      </div>
      <div id="rf-feedback-content" style="display:none;">
        <!-- Empty state placeholder -->
        <div id="ats-placeholder" class="ats-placeholder-note" style="display:none;">
        </div>
        <!-- ATS Rubric -->
        <div id="ats-feedback-container">
          <!-- ATS Rubric skeleton - 5 cards matching grid layout -->
          <div class="rf-skeleton-rubric-grid" id="rf-skeleton-rubric" style="display:none;">
            <div class="rf-skeleton rf-skeleton-rubric-card"></div>
            <div class="rf-skeleton rf-skeleton-rubric-card"></div>
            <div class="rf-skeleton rf-skeleton-rubric-card"></div>
            <div class="rf-skeleton rf-skeleton-rubric-card"></div>
            <div class="rf-skeleton rf-skeleton-rubric-card"></div>
          </div>
          <div class="rf-rubric-grid" id="rf-rubric-grid" style="display:none;">
          </div>
        </div>
        <!-- Role-Specific Feedback -->
        <div id="role-feedback-container">
          <div class="rf-section-title" id="rf-role-title" style="margin-top:3rem; display:flex; align-items:center; gap:0.5rem;">
            <span id="rf-role-title-text">Role-Specific Tailoring Tips</span>
            <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="8"/>
                <line x1="12" y1="12" x2="12" y2="16"/>
              </svg>
              <span class="rf-tooltip-text">Add projects, tools, and metrics to unlock all tailored sections.</span>
            </span>
          </div>
          <div style="color:var(--color-text-muted);margin-bottom:0.75rem;" id="rf-role-desc">
            Based on current expectations for your target role.
          </div>
          <div id="rf-role-status" style="color:var(--color-text-secondary);font-size:0.95rem;margin-bottom:0.75rem;display:none;"></div>
          <div id="rf-role-info" style="display:none; margin-bottom:1.2rem; padding:0.85rem 1rem; border:1px solid var(--color-divider); border-radius: var(--radius-button); background: rgba(0,123,255,0.06); color: var(--color-text-secondary);">
            We generated tips for these sections. Add a few impact bullets to see the rest.
          </div>
          <!-- Skeleton Loading States (shown during Step 2) -->
          <div id="rf-skeleton-container" style="display:none;">
            <!-- Progress header skeleton -->
            <div class="rf-skeleton rf-skeleton-header" id="rf-skeleton-header"></div>
            
            <!-- Role-Specific Feedback skeleton - 3 cards -->
            <div class="rf-skeleton-feedback-grid" id="rf-skeleton-feedback" style="margin-top: 3rem;">
              <div class="rf-skeleton rf-skeleton-feedback-card"></div>
              <div class="rf-skeleton rf-skeleton-feedback-card"></div>
              <div class="rf-skeleton rf-skeleton-feedback-card"></div>
            </div>
          </div>
          <div class="rf-feedback-grid" id="rf-feedback-grid" style="display:none;">
          </div>
        <button class="btn btn-primary" id="rf-regenerate-btn" style="margin-top:1.7rem;display:none;">Regenerate Feedback</button>
        </div>
      </div>
    </section>

    <!-- Resume Rewriting Tile -->
    <a id="rewrite"></a>
    <section class="rf-card" id="rf-rewrite-tile">
      <div class="rf-title">
        Resume Rewriting
        <span class="rf-plan-badge" style="background:#6B7280;">Pro Only</span>
      </div>
      <div id="rf-rewrite-desc" style="color:var(--color-text-secondary);margin-bottom:1.2rem;">
        AI rewrites your resume line-by-line using this ATS feedback and your target role. Upgrade to Pro to unlock resume rewriting.
        <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.4em;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="8"/>
            <line x1="12" y1="12" x2="12" y2="16"/>
          </svg>
          <span class="rf-tooltip-text">See a rewritten version of your resume tailored to your target job - ready to copy and paste. Unlimited with your Pro plan.</span>
        </span>
      </div>
      <div class="rf-upgrade-prompt">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12h14"/>
        </svg>
        <div class="rf-upgrade-text">
          <strong>Upgrade to Pro</strong> to unlock resume rewriting powered by this ATS feedback and your target role.
        </div>
        <a href="#" class="btn btn-secondary" onclick="startCheckout('pro'); return false;">Upgrade Now</a>
      </div>
      <!-- Hidden content that will be shown for Pro/Premium plans -->
      <div id="rf-rewrite-content" style="display:none; padding: 0 1.5rem;">
        <div style="font-weight:600;margin-bottom:0.5rem;">Your Original Snippet</div>
        <textarea class="rf-snippet-box" readonly>Original resume excerpt will appear here after upload.</textarea>
        <div style="font-weight:600;margin-bottom:0.5rem;">Rewritten Snippet</div>
        <div id="rf-rewrite-desc-inline" class="rf-rewrite-desc-inline" style="display:none;">
          Below is your fully optimized resume draft. We used ATS best-practice language, injected relevant keywords, and tightened formatting so it's ready to paste into your next application.
        </div>
        <textarea class="rf-snippet-box" readonly>AI-optimized resume excerpt.</textarea>
        <div id="rf-change-summary" style="display:none;"></div>
        <style>
        /* Print container for Resume Rewriting (matches other product print rules) */
        #rf-print { display: none; }
        @media print {
          header.site-header,
          nav.mobile-nav,
          .mobile-nav-backdrop,
          footer.site-footer,
          .rf-sidebar-column,
          .rf-section-actions,
          .rf-actions,
          .rf-loading,
          /* Hide main content and cards so only the print container is shown */
          .rf-main-column,
          .rf-card { display: none !important; }

          body { background: #fff !important; }
          #rf-print { display: block !important; }
          /* Ensure print container card styles are neutral for multi-page output
             and explicitly make print cards visible even though .rf-card is hidden above. */
          #rf-print .rf-card { display: block !important; box-shadow: none !important; border-radius: 0 !important; padding: 0 !important; margin: 0 0 1rem 0 !important; }
        }
        </style>

        <div style="margin-top:1.2rem;">
          <button class="btn btn-primary" style="display:none;">Copy Rewritten Resume</button>
          <button id="rf-download" class="btn-outline" style="display:none;" disabled aria-disabled="true" type="button">Download PDF</button>
          <button id="rf-generate" class="btn-outline" type="button">Generate Rewrite</button>
          <div id="rf-rewrite-cooldown" style="margin-top:0.5rem;"></div>
        </div>

        <!-- Print container used by window.print() -->
        <div id="rf-print" aria-hidden="true"></div>
      </div>
    </section>
        
      </div><!-- /.rf-main-column -->

      <!-- Sidebar Column - Sticky History -->
      <aside class="rf-sidebar-column">
        <section
          class="rf-card history-card"
          id="rf-history-panel"
          data-history-panel="v1"
        >
          <div class="rf-history-header" data-history-header>
            <div class="rf-history-title-wrap">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <circle cx="12" cy="12" r="10"/>
                <polyline points="12 6 12 12 16 14"/>
              </svg>
              <span class="rf-history-title-text" id="rf-history-header-title">History</span>
            </div>

            <div class="rf-history-header-actions" data-history-header-actions>
              <button id="rf-history-refresh" class="rf-history-icon-btn" title="Refresh history" aria-label="Refresh history" type="button">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M23 4v6h-6"/>
                <path d="M1 20v-6h6"/>
                <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
              </svg>
            </button>
              <button id="rf-history-manage" class="rf-history-manage-btn" type="button">Manage</button>
          </div>

            <div class="rf-history-manage-actions" id="rf-history-manage-actions" data-history-manage-controls>
              <div class="rf-history-manage-actions__actions">
                <button id="rf-history-delete-selected" class="rf-history-danger-btn" type="button" disabled>Delete selected</button>
                <button id="rf-history-cancel-manage" class="rf-history-neutral-btn" type="button">Cancel</button>
              </div>
            </div>
            </div>

          <div class="rf-history-subtitle" data-history-subtitle>
            Last 10 feedback runs â€¢ Auto-saved
              </div>

          <div class="rf-history-body" data-history-body>
            <div class="rf-history-loading" id="rf-history-loading" data-history-loading>
              <div class="rf-history-skeleton-row">
                <div class="rf-skeleton" style="width:40px;height:40px;border-radius:var(--radius-md);"></div>
                <div style="flex:1;min-width:0;">
                  <div class="rf-skeleton rf-history-skeleton-pill"></div>
                  <div class="rf-skeleton rf-history-skeleton-pill sm" style="margin-top:8px;"></div>
            </div>
                <div class="rf-skeleton rf-history-skeleton-score"></div>
              </div>
              <div class="rf-history-skeleton-row">
                <div class="rf-skeleton" style="width:40px;height:40px;border-radius:var(--radius-md);"></div>
                <div style="flex:1;min-width:0;">
                  <div class="rf-skeleton rf-history-skeleton-pill"></div>
                  <div class="rf-skeleton rf-history-skeleton-pill sm" style="margin-top:8px;"></div>
                </div>
                <div class="rf-skeleton rf-history-skeleton-score"></div>
              </div>
              <div class="rf-history-skeleton-row">
                <div class="rf-skeleton" style="width:40px;height:40px;border-radius:var(--radius-md);"></div>
                <div style="flex:1;min-width:0;">
                  <div class="rf-skeleton rf-history-skeleton-pill"></div>
                  <div class="rf-skeleton rf-history-skeleton-pill sm" style="margin-top:8px;"></div>
                </div>
                <div class="rf-skeleton rf-history-skeleton-score"></div>
              </div>
              <div class="rf-history-skeleton-row">
                <div class="rf-skeleton" style="width:40px;height:40px;border-radius:var(--radius-md);"></div>
                <div style="flex:1;min-width:0;">
                  <div class="rf-skeleton rf-history-skeleton-pill"></div>
                  <div class="rf-skeleton rf-history-skeleton-pill sm" style="margin-top:8px;"></div>
                </div>
                <div class="rf-skeleton rf-history-skeleton-score"></div>
              </div>
            </div>

            <div class="rf-history-error" id="rf-history-error" data-history-error hidden>
            <span data-default-message="Couldnâ€™t load history.">Couldnâ€™t load history. </span>
              <button id="rf-history-retry" class="rf-history-link-btn" type="button">Retry.</button>
            </div>

            <div class="rf-history-list" id="rf-history-list" data-history-list></div>

            <div class="rf-history-empty" id="rf-history-empty" data-history-empty hidden>
              <div style="font-weight:800;margin-bottom:0.25rem;color:var(--color-text-main);">No history yet</div>
              <div>Your last 10 feedback runs will appear here automatically.</div>
            </div>
          </div>

          <div class="rf-history-footer" data-history-footer>
            <span>Data retention: JobHackAI shows your last 10 resume feedback runs. Runs are automatically deleted after 90 days.</span>
            <div class="rf-history-footer-links">
              <a class="rf-history-footer-link" href="privacy.html" data-history-learn-more>Learn more</a>
              <span class="rf-history-footer-separator" aria-hidden="true">Â·</span>
              <button id="rf-history-clear" class="rf-history-footer-link rf-history-footer-link--danger" type="button">Clear history</button>
            </div>
          </div>
        </section>

        <!-- Delete confirmation modal -->
        <div class="rf-history-modal-backdrop" id="rf-history-modal-backdrop" hidden></div>
        <div
          class="rf-history-modal"
          id="rf-history-delete-modal"
          role="dialog"
          aria-modal="true"
          aria-labelledby="rf-history-modal-title"
          hidden
          data-history-modal
        >
          <h3 id="rf-history-modal-title">Permanently delete history?</h3>
          <p>This will remove the selected items from your account.</p>
          <p>This cannot be undone.</p>
          <div class="rf-history-modal-actions">
            <button id="rf-history-modal-cancel" class="rf-history-neutral-btn" type="button">Cancel</button>
            <button id="rf-history-modal-confirm" class="rf-history-danger-btn" type="button">Delete permanently</button>
          </div>
        </div>
      </aside><!-- /.rf-sidebar-column -->
    </div><!-- /.rf-layout-container -->
  </main>

  <!-- Footer -->
  <footer class="site-footer" style="position:sticky;bottom:0;width:100%;background:var(--color-card-bg);">
    <div class="footer-container">
      <div class="footer-brand">
        <svg class="footer-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="7" width="18" height="13" rx="2" stroke="#1F2937" stroke-width="2"/>
          <path d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2" stroke="#1F2937" stroke-width="2"/>
        </svg>
        <span class="footer-name">JOBHACKAI</span>
      </div>
      <div class="footer-legal">
        <p>Â© 2026 JobHackAI. All rights reserved.</p>
      </div>
      <div class="footer-links">
        <a href="index.html">Home</a>
        <a href="help.html">Help</a>
        <a href="privacy.html">Privacy</a>
      </div>
    </div>
  </footer>
</body>
</html>
