<!-- DO NOT EDIT HEADER OR FOOTER PER-PAGE. Use canonical snippet from docs/snippets.md. -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>html.auth-pending,html.plan-pending{visibility:hidden}</style>
  <script src="js/static-auth-guard.js?v=20251007-2"></script>
  <script>
    // --- IMMEDIATE PAGE ACCESS CONTROL ---
    // Run immediately to prevent content flash for unauthorized users
    (function enforceAccessImmediate() {
      const isAuthenticated = localStorage.getItem('user-authenticated') === 'true' && !!localStorage.getItem('user-email');
      const allowedPlans = ['trial', 'essential', 'pro', 'premium'];
      // Expose allowed plans so later scripts stay in sync
      window.__JOBHACKAI_RF_ALLOWED_PLANS__ = allowedPlans;
      const cachedPlan = localStorage.getItem('user-plan');
      
      // If not authenticated, redirect to login immediately
      if (!isAuthenticated) {
        console.log('üö´ [RESUME-FEEDBACK] Not authenticated, redirecting to login');
        window.location.href = 'login.html';
        return;
      }
      
      if (cachedPlan) {
        // Cached plan detected - enforce immediately
        if (!allowedPlans.includes(cachedPlan)) {
          console.log('üö´ [RESUME-FEEDBACK] Access denied for cached plan:', cachedPlan);
          window.location.href = 'pricing-a.html?plan=essential';
          return;
        }
        console.log('‚úÖ [RESUME-FEEDBACK] Access granted for cached plan:', cachedPlan);
      } else {
        // Plan not cached yet - allow page to load and defer enforcement
        console.log('‚è≥ [RESUME-FEEDBACK] Plan not cached yet. Deferring enforcement until server plan check completes.');
        window.__JOBHACKAI_PLAN_PENDING__ = true;
        document.documentElement.classList.add('plan-pending');
      }
    })();
  </script>
  <title>JobHackAI</title>
  <link rel="icon" type="image/png" href="assets/jobhackai_icon_only_128.png">
  <link rel="apple-touch-icon" href="assets/jobhackai_icon_only_128.png">
  <script src="js/dynamic-favicon.js?v=20250111-1"></script>

  <!-- Design tokens & global styles -->
  <link rel="stylesheet" href="css/tokens.css">
  <link rel="stylesheet" href="css/main.css">

  <!-- Component overrides -->
  <link rel="stylesheet" href="css/header.css">
  <link rel="stylesheet" href="css/footer.css">
  <style>
    html, body {
      height: 100%;
    }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    main {
      flex: 1 0 auto;
    }
    .site-footer {
      flex-shrink: 0;
      position: relative;
      bottom: 0;
      width: 100%;
      background: var(--color-card-bg);
    }
    /* Two-pane layout for main content + sticky history sidebar */
    .rf-layout-container {
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: var(--space-lg);
      align-items: start;
      max-width: 1200px;
      margin: 0 auto;
    }
    @media (max-width: 1024px) {
      .rf-layout-container {
        grid-template-columns: 1fr;
      }
    }
    .rf-main-column {
      min-width: 0;
    }
    .rf-sidebar-column {
      position: sticky;
      top: 100px;
    }
    @media (max-width: 1024px) {
      .rf-sidebar-column {
        position: static;
      }
    }
    /* Historical view banner */
    .rf-historical-banner {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      padding: 0.875rem 1.25rem;
      background: linear-gradient(135deg, #FEF3C7 0%, #FDE68A 100%);
      border: 1px solid #F59E0B;
      border-radius: var(--radius-lg);
      margin-bottom: var(--space-lg);
      flex-wrap: wrap;
    }
    .rf-historical-banner-text {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: #92400E;
      font-size: 0.95rem;
      font-weight: 500;
    }
    .rf-historical-banner-text svg {
      width: 18px;
      height: 18px;
      flex-shrink: 0;
    }
    .rf-historical-banner .btn-primary {
      white-space: nowrap;
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
    }
    .rf-card { background: var(--color-card-bg); border-radius: var(--radius-xl); box-shadow: var(--shadow-card); padding: var(--space-lg); margin-bottom: var(--space-lg); }
    .rf-title { font-size: var(--font-size-2xl); font-weight: var(--font-weight-extrabold); margin-bottom: var(--space-xs); color: var(--color-text-main); }
    .rf-section-title { font-size: var(--font-size-xl); font-weight: var(--font-weight-bold); margin-bottom: var(--space-xs); color: var(--color-text-main); }
    .rf-progress-ring { width: 80px; height: 80px; display: inline-block; vertical-align: middle; margin-right: 1.5rem; }
    .rf-score-badge { display: inline-block; background: #00E676; color: #fff; font-weight: 700; border-radius: 999px; padding: 0.3em 1em; font-size: 1.2rem; margin-left: 0.7rem; }
    /* Status pill component - matches existing .rf-score-badge pattern */
    .rf-status-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.55rem;
      border-radius: var(--radius-full);
      font-size: var(--font-size-xs);
      font-weight: var(--font-weight-medium);
      font-family: var(--font-family-base);
      border: 1px solid transparent;
      line-height: 1.2;
      margin-top: 0.5rem;
    }
    .rf-status-icon {
      display: inline-flex;
      align-items: center;
      flex-shrink: 0;
    }
    .rf-status-icon svg {
      width: 14px;
      height: 14px;
      stroke-width: 2;
    }
    .rf-status-pill--success {
      background-color: rgba(5, 150, 105, 0.06);
      border-color: rgba(5, 150, 105, 0.25);
      color: var(--color-success);
    }
    .rf-status-pill--warning {
      background-color: rgba(217, 119, 6, 0.08);
      border-color: rgba(217, 119, 6, 0.3);
      color: var(--color-warning);
    }
    .rf-status-pill--error {
      background-color: rgba(220, 38, 38, 0.06);
      border-color: rgba(220, 38, 38, 0.25);
      color: var(--color-error);
    }
    .rf-rubric-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1.2rem; margin-top: 1.5rem; }
    .rf-rubric-item { background: #F8FAFC; border-radius: var(--radius-lg); padding: 1rem 1.2rem; }
    .rf-rubric-label { font-weight: 600; color: var(--color-text-main); margin-bottom: 0.2rem; }
    .rf-rubric-score { font-size: 1.1rem; font-weight: 700; color: #1976D2; }
    .rf-feedback-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1.2rem; margin-top: 1.5rem; }
    .rf-feedback-card { background: #fff; border-radius: var(--radius-lg); box-shadow: 0 1px 3px rgba(0,0,0,0.07); padding: 1.2rem 1.2rem 1rem 1.2rem; }
    .rf-feedback-label { font-weight: 700; color: var(--color-text-main); margin-bottom: 0.2rem; }
    .rf-feedback-score { display: inline-block; background: #00E676; color: #fff; font-weight: 700; border-radius: 999px; padding: 0.2em 0.8em; font-size: 1rem; margin-left: 0.5rem; }
    .rf-feedback-tip { color: var(--color-text-secondary); font-size: 1.01rem; margin-top: 0.3rem; }
    .rf-snippet-box { width: 100%; min-height: 120px; border: 2px solid var(--color-divider); border-radius: var(--radius-lg); padding: 1rem; font-family: var(--font-family-base); font-size: var(--font-size-base); font-weight: var(--font-weight-regular); margin-bottom: 1.2rem; background: #F9FAFB; color: var(--color-text-main); resize: vertical; }
    /* Ensure rewrite buttons are same size */
    #rf-rewrite-content .btn-primary,
    #rf-rewrite-content .btn-secondary {
      padding: 0.7rem 2rem;
      font-size: 1rem;
    }
    @media (max-width: 700px) { .rf-rubric-grid, .rf-feedback-grid { grid-template-columns: 1fr; } }
    .rf-plan-badge {
      display: inline-block;
      background: var(--color-accent-blue);
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 0.2em 0.8em;
      font-size: 0.9rem;
      margin-left: 0.7rem;
    }
    .rf-plan-limit {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--color-text-secondary);
      font-size: 0.95rem;
      margin-top: 0.5rem;
    }
    .rf-upgrade-prompt {
      background: #F0F7FF;
      border-radius: var(--radius-lg);
      padding: 1rem;
      margin-top: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .rf-upgrade-prompt svg {
      width: 24px;
      height: 24px;
      color: var(--color-accent-blue);
      flex-shrink: 0;
    }
    .rf-upgrade-text {
      flex: 1;
      color: var(--color-text-main);
      font-size: 0.95rem;
    }
    .rf-upgrade-text strong {
      color: var(--color-accent-blue);
    }
    /* Standardized upgrade button styling - filled blue for all CTA buttons */
    .rf-upgrade-prompt .btn.btn-secondary,
    .rf-upgrade-prompt a.btn {
      background: #1976D2 !important;
      color: #fff !important;
      font-weight: 600;
      border: none !important;
      border-radius: var(--radius-md);
      padding: 0.6rem 1.3rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.18s;
      text-decoration: none;
      display: inline-block;
      white-space: nowrap;
    }
    .rf-upgrade-prompt .btn.btn-secondary:hover,
    .rf-upgrade-prompt a.btn:hover {
      background: #125bb5 !important;
    }
    /* ===== SKELETON LOADING STATES (Performance-Optimized) ===== */
    @keyframes rf-shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    .rf-skeleton {
      background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
      background-size: 200% 100%;
      animation: rf-shimmer 1.5s infinite;
      border-radius: var(--radius-lg);
      opacity: 1;
      transition: opacity 0.3s ease;
    }
    .rf-skeleton.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .rf-skeleton-header {
      height: 60px;
      margin-bottom: 1.5rem;
    }
    .rf-skeleton-rubric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.2rem;
      margin-top: 1.5rem;
    }
    .rf-skeleton-rubric-card {
      height: 150px;
    }
    .rf-skeleton-feedback-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1.2rem;
      margin-top: 1.5rem;
    }
    .rf-skeleton-feedback-card {
      height: 200px;
    }
    .rf-btn-secondary {
      background: transparent;
      color: var(--color-accent-blue);
      font-weight: 600;
      border: 1px solid var(--color-accent-blue);
      border-radius: var(--radius-md);
      padding: 0.5rem 1rem;
      font-size: 0.95rem;
      cursor: pointer;
      transition: all 0.18s;
    }
    .rf-btn-secondary:hover {
      background: rgba(25, 118, 210, 0.05);
    }
    .rf-btn-ghost {
      background: transparent;
      color: #4B5563;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      padding: 0.65rem 1.1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.18s ease;
    }
    .rf-btn-ghost:hover {
      background: #F9FAFB;
      color: #374151;
      border-color: #D1D5DB;
    }
    /* History Section Styles */
    .rf-history-list {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-top: 1rem;
    }
    .rf-history-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.875rem 1rem;
      background: #F9FAFB;
      border-radius: var(--radius-md);
      border: 1px solid var(--color-divider);
      transition: all 0.18s ease;
      cursor: pointer;
    }
    .rf-history-item:hover {
      background: #F3F4F6;
      border-color: var(--color-accent-blue);
    }
    .rf-history-item.active {
      background: #F0F7FF;
      border-color: var(--color-accent-blue);
    }
    .rf-history-item .rf-history-score {
      font-weight: 700;
      color: var(--color-cta-green);
      font-size: 1.1rem;
      min-width: 32px;
      text-align: right;
    }
    .rf-history-actions {
      display: none;
      margin-top: 0.75rem;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .rf-history-count {
      color: var(--color-text-muted);
      font-size: 0.9rem;
    }
    .rf-btn-link {
      background: none;
      border: none;
      color: var(--color-text-secondary);
      text-decoration: underline;
      padding: 0.25rem 0.15rem;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .rf-history-icon {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, #E0E7FF 0%, #C7D2FE 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .rf-history-icon svg {
      width: 20px;
      height: 20px;
      color: #4F46E5;
    }
    .rf-history-details {
      flex: 1;
      min-width: 0;
    }
    .rf-history-title {
      font-weight: 600;
      color: var(--color-text-main);
      font-size: 0.95rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .rf-history-meta {
      font-size: 0.8rem;
      color: var(--color-text-muted);
      margin-top: 0.15rem;
    }
    .rf-history-empty {
      text-align: center;
      padding: 2rem 1rem;
      color: var(--color-text-muted);
    }
    .rf-history-empty svg {
      width: 48px;
      height: 48px;
      margin-bottom: 0.75rem;
      opacity: 0.4;
    }
    .rf-history-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 1.5rem;
      color: var(--color-text-muted);
    }
    .rf-history-loading .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid var(--color-divider);
      border-top-color: var(--color-accent-blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .priority-review-cta {
      background: #F0F7FF;
      border-radius: var(--radius-lg);
      padding: 1rem 1.2rem;
      margin: 1.2rem 0 0.5rem 0;
      display: flex;
      align-items: center;
      gap: 1rem;
      font-size: 1.05rem;
      color: var(--color-text-main);
    }
    /* Premium CTA with white background to match card tiles */
    .priority-review-cta.premium-cta {
      background: var(--color-card-bg);
      box-shadow: var(--shadow-card);
    }
    /* Standardized upgrade button - matches all other upgrade CTAs */
    .priority-review-cta .priority-btn {
      background: #1976D2;
      color: #fff;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-md);
      padding: 0.7rem 2rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.18s;
      margin-left: 1.2rem;
      white-space: nowrap;
    }
    .priority-review-cta .priority-btn:hover {
      background: #125bb5;
    }
    .priority-review-tooltip {
      position: relative;
      display: inline-block;
      cursor: pointer;
    }
    .priority-review-tooltip .tooltip-text {
      visibility: hidden;
      width: 260px;
      background: #222;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 0.7rem 1rem;
      position: absolute;
      z-index: 10;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 0.98rem;
      pointer-events: none;
    }
    .priority-review-tooltip:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
      pointer-events: auto;
    }
    /* Tooltip style matching Resume Rewriting */
    .rf-tooltip-trigger {
      cursor: pointer;
      margin-left: 0.4em;
      vertical-align: middle;
      position: relative;
      display: inline-block;
    }
    .rf-tooltip-trigger svg {
      width: 16px;
      height: 16px;
      color: #9CA3AF;
      vertical-align: middle;
    }
    .rf-tooltip-text {
      display: none;
      position: absolute;
      z-index: 1070;
      padding: 0.5rem 0.8rem;
      background-color: #333;
      color: #fff;
      border-radius: 4px;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      min-width: 180px;
      max-width: 260px;
      white-space: normal;
      word-break: break-word;
      font-size: 0.9rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.12);
      pointer-events: none;
      text-align: left;
      margin-bottom: 0.5rem;
    }
    .rf-tooltip-trigger:hover .rf-tooltip-text,
    .rf-tooltip-trigger:focus .rf-tooltip-text {
      display: block;
      pointer-events: auto;
    }
    /* Fade Transitions */
    .fade-enter {
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.35s ease, transform 0.35s ease;
    }
    .fade-enter-active {
      opacity: 1;
      transform: translateY(0);
    }
    /* Subtle fade-in utility for restored content */
    .rf-fade-in {
      opacity: 0;
      animation: rfFadeIn 220ms ease-out forwards;
    }
    @keyframes rfFadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .fade-exit {
      opacity: 1;
      transform: translateY(0);
      transition: opacity 0.25s ease, transform 0.25s ease;
    }
    .fade-exit-active {
      opacity: 0;
      transform: translateY(8px);
    }
    /* Empty State Placeholders */
    .ats-placeholder-note {
      text-align: center;
      color: var(--color-text-muted);
      font-style: italic;
      margin-top: var(--space-sm);
      font-size: var(--font-size-base);
    }
    /* Standardized Role Input Styling (matching Interview Questions) */
    .rf-role-input {
      width: 100%;
      padding: 0.85rem 1.1rem;
      border: 2px solid #E5E7EB;
      border-radius: 10px;
      font-size: 1.08rem;
      margin-bottom: 0;
      transition: border 0.18s;
      background: #fff;
      color: #232B36;
      box-sizing: border-box;
    }
    .rf-role-input:focus {
      border-color: #1976D2;
      outline: none;
    }
    .rf-role-dropdown {
      position: absolute;
      left: 0;
      right: 0;
      background: #fff;
      border: 1.5px solid #E5E7EB;
      border-top: none;
      border-radius: 0 0 10px 10px;
      box-shadow: 0 2px 8px rgba(31,41,55,0.07);
      z-index: 10;
      max-height: 220px;
      overflow-y: auto;
      margin-top: -2px;
    }
    .rf-role-item {
      padding: 0.85rem 1.1rem;
      cursor: pointer;
      font-size: 1.08rem;
      color: #232B36;
      transition: background 0.15s;
    }
    .rf-role-item:hover,
    .rf-role-item.active {
      background: #F3F4F6;
    }
    /* Fit Level Chips for Role-Specific Tailoring Tips */
    .rf-fit-chip-big-impact {
      background: #FEF3C7;
      color: #92400E;
      border: 1px solid #F59E0B;
    }
    .rf-fit-chip-tunable {
      background: #DBEAFE;
      color: #1E40AF;
      border: 1px solid #3B82F6;
    }
    .rf-fit-chip-strong {
      background: #D1FAE5;
      color: #065F46;
      border: 1px solid #10B981;
    }
    /* Change Summary Styles for Rewrite UI */
    .rf-change-summary {
      margin-top: 1.5rem;
      padding: 1.2rem;
      background: #F9FAFB;
      border-radius: var(--radius-lg);
      border: 1px solid var(--color-divider);
    }
    .rf-change-summary h4 {
      font-size: 1rem;
      font-weight: 700;
      color: var(--color-text-main);
      margin: 0 0 0.75rem 0;
    }
    .rf-change-summary ul {
      margin: 0;
      padding-left: 1.25rem;
      color: var(--color-text-secondary);
    }
    .rf-change-summary li {
      margin-bottom: 0.5rem;
      line-height: 1.5;
    }
    .rf-change-summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="site-header">
    <div class="container">
      <a href="index.html" class="nav-logo" aria-label="Go to homepage">
        <svg width="24" height="24" fill="none" stroke="#1F2937" stroke-width="2" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="7" width="18" height="13" rx="2"/>
          <path d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2"/>
        </svg>
        <span>JOBHACKAI</span>
      </a>
      <div class="nav-group">
        <nav class="nav-links" role="navigation">
          <!-- Navigation will be dynamically populated by navigation.js -->
        </nav>
      </div>
      <button class="mobile-toggle" aria-label="Open navigation menu" aria-expanded="false" aria-controls="mobileNav">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
    </div>
  </header>
  
  <nav class="mobile-nav" id="mobileNav">
    <!-- Mobile navigation will be dynamically populated by navigation.js -->
  </nav>
  <div class="mobile-nav-backdrop" id="mobileNavBackdrop"></div>
  
  <!-- Centralized mobile menu handler -->
  <script src="js/mobile-menu.js?v=20250115-1"></script>
  
  <!-- Load Firebase auth as ES module (same pattern as dashboard.html) -->
  <script type="module" src="js/firebase-auth.js?v=20251011-1"></script>
  
  <!-- DEV-ONLY PLAN TOGGLE will be added by navigation.js -->
  <script src="js/navigation.js?v=20251007-2"></script>
  <script src="js/universal-logout.js?v=20251007-2"></script>
  
  <!-- UX Enhancement Components -->
  <script src="js/modals.js?v=20250115-1" type="module"></script>
  <script src="js/loading-overlay.js?v=20250115-1" type="module"></script>
  <script src="js/toast.js?v=20250115-1"></script>
  <script src="js/file-validation.js?v=20250115-1"></script>
  <script src="js/role-selector.js?v=20250115-1" type="module"></script>
  <script src="js/api-retry.js?v=20250115-1"></script>
  <script src="js/state-persistence.js?v=20250115-1"></script>
  <script src="js/free-account-manager.js?v=20250115-1"></script>
  <script>
    if (window.JobHackAINavigation && typeof window.JobHackAINavigation.initializeNavigation === 'function') {
      window.JobHackAINavigation.initializeNavigation();
    } else {
      window.addEventListener('DOMContentLoaded', function() {
        if (window.JobHackAINavigation && typeof window.JobHackAINavigation.initializeNavigation === 'function') {
          window.JobHackAINavigation.initializeNavigation();
        }
      });
    }
  </script>
  <script>
    // --- PAGE ACCESS CONTROL (Second check after navigation system) ---
    // Also run after navigation system initializes to double-check
    function enforceAccess() {
      let isAuthenticated, plan;
      
      if (window.JobHackAINavigation) {
        const authState = window.JobHackAINavigation.getAuthState();
        isAuthenticated = authState.isAuthenticated;
        plan = window.JobHackAINavigation.getEffectivePlan();
      } else {
        isAuthenticated = localStorage.getItem('user-authenticated') === 'true' && !!localStorage.getItem('user-email');
        plan = localStorage.getItem('user-plan') || 'free';
      }
      
      // FIX: Enhanced logging for plan detection debugging
      console.log('[RESUME-FEEDBACK] Plan detection debug:', {
        isAuthenticated,
        plan,
        navigationPlan: window.JobHackAINavigation?.getEffectivePlan?.(),
        localStoragePlan: localStorage.getItem('user-plan'),
        devPlan: localStorage.getItem('dev-plan'),
        authState: window.JobHackAINavigation?.getAuthState?.()
      });
      
      const allowedPlans = ['trial', 'essential', 'pro', 'premium'];
      
      if (!isAuthenticated || !allowedPlans.includes(plan)) {
        if (!isAuthenticated) {
        window.location.href = 'login.html';
        } else {
          window.location.href = 'pricing-a.html?plan=essential';
        }
      }
    }
    
    // Wait for DOM to be ready before enforcing access again
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', enforceAccess);
    } else {
      setTimeout(enforceAccess, 100); // Small delay to allow navigation system to initialize
    }
  </script>
  <script>
    // --- AUTHENTICATION CHECK ---
    function checkAuthentication() {
      const isAuthenticated = localStorage.getItem('user-authenticated') === 'true' && !!localStorage.getItem('user-email');
      const mainContent = document.querySelector('main');
      
      if (!isAuthenticated) {
        mainContent.innerHTML = `
          <div style="max-width: 600px; margin: 4rem auto; text-align: center; padding: 2rem;">
            <div style="font-size: 4rem; margin-bottom: 1rem;">üîí</div>
            <h1 style="font-size: 2rem; font-weight: 700; color: var(--color-text-main); margin-bottom: 1rem;">
              Login Required
            </h1>
            <p style="font-size: 1.1rem; color: var(--color-text-secondary); margin-bottom: 2rem; line-height: 1.6;">
              Resume Feedback Pro requires you to be logged in to access this tool. 
              Please sign in to get started.
            </p>
            <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
              <a href="login.html" class="btn-primary" style="text-decoration: none;">
                Sign In
              </a>
              <a href="pricing-a.html" class="btn-outline" style="text-decoration: none;">
                View Pricing
              </a>
            </div>
          </div>
        `;
        return false;
      }
      return true;
    }

    // --- PLAN-BASED ACCESS CONTROL ---
    function checkPlanAccess() {
      const currentPlan = window.JobHackAINavigation ? window.JobHackAINavigation.getEffectivePlan() : 'free';
      const lockedDiv = document.getElementById('rfp-locked');
      const formDiv = document.getElementById('rfp-form');
      const resultsDiv = document.getElementById('rfp-results');
      
      if (!lockedDiv || !formDiv || !resultsDiv) return;
      
      // Resume Feedback Pro is available for Trial, Essential, Pro, and Premium
      const locked = (currentPlan === 'free');
      lockedDiv.style.display = locked ? 'flex' : 'none';
      formDiv.style.display = locked ? 'none' : '';
      resultsDiv.style.display = 'none';
    }

    // --- Initialize on load ---
    document.addEventListener('DOMContentLoaded', function() {
      // Check authentication first
      if (!checkAuthentication()) {
        return; // Stop here if not authenticated
      }
      
      // Create demo user if needed for development
      const createDemoUserIfNeeded = () => {
        const userEmail = localStorage.getItem('user-email');
        if (!userEmail && localStorage.getItem('user-authenticated') === 'true') {
          // Create demo user
          localStorage.setItem('user-email', 'demo@jobhackai.com');
          const db = JSON.parse(localStorage.getItem('user-db') || '{}');
          if (!db['demo@jobhackai.com']) {
            db['demo@jobhackai.com'] = {
              plan: 'free',
              firstName: 'Demo',
              lastName: 'User',
              cards: [],
              created: new Date().toISOString()
            };
            localStorage.setItem('user-db', JSON.stringify(db));
          }
        }
      };
      
      createDemoUserIfNeeded();

      hydratePlanFromServerAndEnforceAccess();
      
      // Wait for navigation system to be ready
      setTimeout(checkPlanAccess, 100);
    });

    // --- UPDATED USER PLAN LOGIC ---
    function getCurrentUserPlan() {
      // Use navigation system's plan detection for consistency
      let plan = 'free';
      if (window.JobHackAINavigation) {
        plan = window.JobHackAINavigation.getEffectivePlan();
      } else {
        plan = localStorage.getItem('user-plan') || 'free';
      }
      
      // FIX: Validate plan value to prevent corrupted data (e.g., "central")
      const validPlans = ['visitor', 'free', 'trial', 'essential', 'pro', 'premium'];
      if (!validPlans.includes(plan)) {
        const oldPlan = plan; // Capture original invalid plan before reassignment
        console.warn('[RESUME-FEEDBACK] Invalid plan detected:', plan, '- resetting to free');
        plan = 'free';
        // Clean up corrupted plan values
        localStorage.setItem('user-plan', 'free');
        const devPlan = localStorage.getItem('dev-plan');
        if (devPlan && !validPlans.includes(devPlan)) {
          localStorage.setItem('dev-plan', 'free');
        }
        // Log for debugging
        console.log('[RESUME-FEEDBACK] Plan cleanup completed:', {
          oldPlan: oldPlan,
          newPlan: 'free',
          localStoragePlan: localStorage.getItem('user-plan'),
          devPlan: localStorage.getItem('dev-plan')
        });
      }
      
      return plan;
    }

    // Guard to prevent concurrent plan syncs
    let planSyncInProgress = false;
    
    async function hydratePlanFromServerAndEnforceAccess() {
      const allowedPlans = window.__JOBHACKAI_RF_ALLOWED_PLANS__ || ['trial', 'essential', 'pro', 'premium'];
      const cachedPlan = localStorage.getItem('user-plan');
      const planPending = window.__JOBHACKAI_PLAN_PENDING__;
      
      // Prevent concurrent syncs - if one is already in progress, wait for it
      if (planSyncInProgress) {
        console.log('‚è∏Ô∏è [RESUME-FEEDBACK] Plan sync already in progress, skipping duplicate call');
        return;
      }
      
      // Always sync from Stripe to ensure KV is up to date
      // This fixes plan mismatch issues between KV cache and actual Stripe subscription
      planSyncInProgress = true;
      try {
        const token = await getAuthToken().catch((err) => {
          console.warn('[RESUME-FEEDBACK] Unable to obtain auth token for plan hydration:', err);
          return null;
        });
        if (!token) {
          document.documentElement.classList.remove('plan-pending');
          planSyncInProgress = false;
          return;
        }
        
        // Use sync-stripe-plan to ensure KV is synced with Stripe (source of truth)
        console.log('üîÑ [RESUME-FEEDBACK] Syncing plan from Stripe...');
        const syncResponse = await fetch('/api/sync-stripe-plan', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (syncResponse.ok) {
          const syncData = await syncResponse.json().catch((err) => {
            console.error('‚ùå [RESUME-FEEDBACK] Failed to parse sync response JSON:', err);
            return {};
          });
          if (syncData.ok && syncData.plan) {
            const stripePlan = syncData.plan.toLowerCase();
            console.log('‚úÖ [RESUME-FEEDBACK] Plan synced from Stripe:', stripePlan);
            
            // Update localStorage with Stripe plan (only if changed to avoid unnecessary writes)
            if (localStorage.getItem('user-plan') !== stripePlan) {
              localStorage.setItem('user-plan', stripePlan);
              localStorage.setItem('dev-plan', stripePlan); // Also update dev-plan for consistency
            }
            
            // Dispatch plan change event
            window.dispatchEvent(new CustomEvent('planChanged', { detail: { newPlan: stripePlan, oldPlan: cachedPlan } }));
            window.__JOBHACKAI_PLAN_PENDING__ = false;
            document.documentElement.classList.remove('plan-pending');
            
            // Update UI immediately
            if (typeof updateRfTileForPlan === 'function') {
              updateRfTileForPlan();
            }
            
            if (!allowedPlans.includes(stripePlan)) {
              console.log('üö´ [RESUME-FEEDBACK] Stripe plan not allowed, redirecting:', stripePlan);
              planSyncInProgress = false;
              window.location.href = 'pricing-a.html?plan=essential';
              return;
            }
            planSyncInProgress = false;
            return;
          }
        }
        
        // Fallback to /api/plan/me if sync fails
        console.warn('[RESUME-FEEDBACK] Stripe sync failed, falling back to plan/me');
        const response = await fetch('/api/plan/me', {
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          console.warn('[RESUME-FEEDBACK] Plan API failed during hydration:', response.status, response.statusText);
          document.documentElement.classList.remove('plan-pending');
          planSyncInProgress = false;
          return;
        }
        
        const planData = await response.json().catch((err) => {
          console.error('‚ùå [RESUME-FEEDBACK] Failed to parse plan/me response JSON:', err);
          return {};
        });
        const serverPlan = (planData.plan || 'free').toLowerCase();
        // Only update localStorage if plan changed
        if (localStorage.getItem('user-plan') !== serverPlan) {
          localStorage.setItem('user-plan', serverPlan);
        }
        window.dispatchEvent(new CustomEvent('planChanged', { detail: { newPlan: serverPlan } }));
        window.__JOBHACKAI_PLAN_PENDING__ = false;
        document.documentElement.classList.remove('plan-pending');
        planSyncInProgress = false;
        
        if (!allowedPlans.includes(serverPlan)) {
          console.log('üö´ [RESUME-FEEDBACK] Server plan not allowed, redirecting:', serverPlan);
          window.location.href = 'pricing-a.html?plan=essential';
          return;
        }
        
        console.log('‚úÖ [RESUME-FEEDBACK] Server plan confirmed:', serverPlan);
      } catch (error) {
        window.__JOBHACKAI_PLAN_PENDING__ = false;
        document.documentElement.classList.remove('plan-pending');
        planSyncInProgress = false;
        console.warn('[RESUME-FEEDBACK] Failed to hydrate plan from server:', error);
      }
    }

    // --- UPDATED USER OBJECT ---
    let user = {
      get plan() {
        return getCurrentUserPlan();
      },
      atsChecksUsed: 0,
      lastAtsCheckTime: null
    };

    // --- GLOBAL STATE ---
    let currentResumeId = null;
    let currentJobTitle = null;

    // --- API CLIENT FUNCTIONS ---
    async function getAuthToken() {
      // Wait for Firebase auth to be ready
      if (window.FirebaseAuthManager && window.FirebaseAuthManager.waitForAuthReady) {
        await window.FirebaseAuthManager.waitForAuthReady(3000);
      }
      
      // Get Firebase ID token using FirebaseAuthManager
      if (window.FirebaseAuthManager && window.FirebaseAuthManager.getCurrentUser) {
        const user = window.FirebaseAuthManager.getCurrentUser();
        if (user) {
          return await user.getIdToken();
        }
      }
      
      // Fallback: try to get from localStorage
      const firebaseKeys = Object.keys(localStorage).filter(k => k.startsWith('firebase:authUser:'));
      if (firebaseKeys.length > 0) {
        const authData = JSON.parse(localStorage.getItem(firebaseKeys[0]) || '{}');
        if (authData.stsTokenManager?.accessToken) {
          return authData.stsTokenManager.accessToken;
        }
      }
      
      throw new Error('Not authenticated. Please log in.');
    }

    // --- SHARED STATE MANAGEMENT HELPERS ---
    function clearAtsState() {
      // Clear old localStorage keys (to avoid stale state)
      localStorage.removeItem('lastATSScore');
      localStorage.removeItem('lastATSSummary');
      localStorage.removeItem('lastUploadedResume');
      localStorage.removeItem('lastUploadedResumeName');
      
      // Clear shared cross-page state
      sessionStorage.removeItem('currentResumeId');
      sessionStorage.removeItem('currentResumeText');
      sessionStorage.removeItem('currentAtsScore');
      sessionStorage.removeItem('currentAtsBreakdown');
    }

    // Status icon definitions - defined once, reused
    const RF_STATUS_ICONS = {
      success: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"/>
      <polyline points="9 12 12 15 22 5"/>
    </svg>`,
      warning: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
      <line x1="12" y1="9" x2="12" y2="13"/>
      <line x1="12" y1="17" x2="12.01" y2="17"/>
    </svg>`,
      error: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="10"/>
      <line x1="12" y1="8" x2="12" y2="12"/>
      <line x1="12" y1="16" x2="12.01" y2="16"/>
    </svg>`
    };

    function getStatusIcon(type) {
      return RF_STATUS_ICONS[type] || '';
    }

    // Helper function to show file status pill
    function showFileStatus(variant, message) {
      const statusPill = document.getElementById('rf-file-status');
      const statusIcon = statusPill?.querySelector('.rf-status-icon');
      const statusText = statusPill?.querySelector('.rf-status-text');
      
      if (!statusPill || !statusIcon || !statusText) return;
      
      statusPill.className = `rf-status-pill rf-status-pill--${variant}`;
      statusIcon.innerHTML = getStatusIcon(variant);
      statusText.textContent = message;
      statusPill.style.display = 'inline-flex';
    }

    function hideFileStatus() {
      const statusPill = document.getElementById('rf-file-status');
      if (statusPill) {
        statusPill.style.display = 'none';
      }
    }

    async function uploadResume(file) {
      // Validate file before upload
      const validation = await window.JobHackAIFileValidation.validateFile(file);
      if (!validation.valid) {
        throw new Error(validation.error);
      }
      
      // Handle warnings (e.g., scanned PDF detection)
      // NOTE: Removed popup modal - users see inline helper text instead
      // Validation still runs, but no blocking modal is shown
      if (validation.warning) {
        console.log('[RESUME-FEEDBACK] File validation warning:', validation.warningMessage);
        // Inline helper text will inform users about PDF processing time
      }

      // Show progress indicator for text extraction (Step 1: Reading resume)
      const hideLoading = window.showLoadingOverlay 
        ? window.showLoadingOverlay(window.LoadingMessages?.READING_RESUME || 'Reading your resume...')
        : null;

      try {
        const token = await getAuthToken();
        const formData = new FormData();
        formData.append('file', file);

        // Use retry logic for upload
        const response = await window.JobHackAIRetry.fetchWithRetry('/api/resume-upload', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`
          },
          body: formData
        }, {
          maxRetries: 3,
          initialDelay: 1000
        });

        // Handle HTTP errors
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Upload failed');
        }

        const data = await response.json();
      
        // Handle extraction failures (success: false but HTTP 200)
        if (!data.success) {
          clearAtsState();
          
          // Map structured error codes to user-friendly messages
          const errorCode = data.errorCode || data.error;
          let errorMessage = data.message || 'Resume text could not be extracted.';
          
          // Handle specific error codes with tailored messages
          if (errorCode === 'ocr_required' || errorCode === 'OCR_REQUIRED') {
            // Scanned PDF detected - show helpful, actionable message
            errorMessage = 'This PDF appears to be image-based (scanned). Please upload a text-based PDF or Word document for best results. We\'re working on scan support for a future update.';
          } else if (errorCode === 'unreadable_scan' || errorCode === 'UNREADABLE_SCAN') {
            errorMessage = 'This scanned PDF is not readable. Please upload a higher-quality file or use our DOCX template.';
          } else if (errorCode === 'empty_text' || errorCode === 'EMPTY_TEXT') {
            errorMessage = 'Could not extract readable text from file. Please upload a text-based r√©sum√© or use our DOCX template.';
          } else if (errorCode === 'unsupported_file_type' || errorCode === 'UNSUPPORTED_TYPE') {
            errorMessage = `Unsupported file type. Please upload PDF, DOCX, or TXT.`;
          } else if (errorCode === 'file_too_large' || errorCode === 'FILE_TOO_LARGE') {
            errorMessage = 'File exceeds 2MB limit. Please compress or use a smaller file.';
          } else if (errorCode === 'text_too_long' || errorCode === 'TEXT_TOO_LONG') {
            errorMessage = 'Extracted text exceeds limit. Please use a shorter r√©sum√©.';
          } else if (errorCode === 'extraction_failed' || errorCode === 'invalid-text') {
            errorMessage = 'We couldn\'t read your resume. Please upload a text-based PDF, DOCX, or TXT file.';
          }
          
          // Preserve error code in Error object so catch block can check error.code
          const error = new Error(errorMessage);
          error.code = errorCode;
          throw error;
        }

        currentResumeId = data.resumeId;
        
        // Store in sessionStorage and localStorage for cross-page sync
        sessionStorage.setItem('currentResumeId', data.resumeId);
        if (data.resumeText) {
          sessionStorage.setItem('currentResumeText', data.resumeText);
        }
        
        // Persist resume data
        if (window.JobHackAIStatePersistence) {
          window.JobHackAIStatePersistence.saveResumeData({
            resumeId: data.resumeId,
            resumeText: data.resumeText,
            isMultiColumn: data.isMultiColumn
          });
        }
        
        // Hide loading overlay on success (only after confirming data.success)
        if (hideLoading) {
          hideLoading();
        }
        
        return data;
      } catch (error) {
        // Hide loading overlay on error
        if (hideLoading) {
          hideLoading();
        }
        
        // Show error status pill based on error code/message
        const message = (error && error.message) || '';
        const code = error && error.code;
        
        if (code === 'ocr_required' || code === 'OCR_REQUIRED' || /scanned/i.test(message)) {
          showFileStatus('error', 'Scanned PDF cannot be processed');
        } else if (code === 'parse_error' || code === 'PARSE_ERROR' || /could not be processed|corrupted|password|encrypted/i.test(message)) {
          showFileStatus('error', 'PDF could not be processed');
        } else if (code === 'unsupported_file_type' || code === 'UNSUPPORTED_TYPE' || /unsupported|file type/i.test(message)) {
          showFileStatus('error', 'File type not supported');
        } else if (code === 'file_too_large' || code === 'FILE_TOO_LARGE' || /too large|2MB/i.test(message)) {
          showFileStatus('error', 'File too large (max 2MB)');
        } else if (code === 'empty_text' || code === 'EMPTY_TEXT' || /empty/i.test(message)) {
          showFileStatus('error', 'File appears to be empty');
        } else if (code === 'text_too_long' || code === 'TEXT_TOO_LONG' || /text.*too long|exceeds.*limit/i.test(message)) {
          showFileStatus('error', 'Text too long');
        } else {
          showFileStatus('error', 'File upload failed');
        }
        
        // Re-throw to be handled by caller
        throw error;
      }
    }

    async function getAtsScore(resumeId, jobTitle) {
      const token = await getAuthToken();
      
      // Try to get resumeText from sessionStorage (fallback when KV unavailable)
      // Use nullish coalescing to only convert null to undefined, preserving empty strings
      const resumeText = sessionStorage.getItem('currentResumeText') ?? undefined;
      
      // Use retry logic for API call
      const response = await window.JobHackAIRetry.fetchWithRetry('/api/ats-score', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          resumeId, 
          jobTitle,
          resumeText // Pass text directly to bypass KV requirement
        })
      }, {
        maxRetries: 3,
        initialDelay: 1000
      });

      if (!response.ok) {
        const error = await response.json();
        // Map error codes to user-friendly messages
        let errorMessage = error.error || 'Failed to get ATS score';
        if (error.error === 'invalid-text') {
          errorMessage = 'We couldn\'t read your resume. Please upload a text-based PDF, DOCX, or TXT file.';
        } else if (error.error === 'Usage limit reached') {
          errorMessage = error.message || 'You have used your free ATS score. Upgrade to unlock more features.';
        } else if (error.error === 'Rate limit exceeded') {
          errorMessage = error.message || 'Please wait before running another ATS score.';
        }
        throw new Error(errorMessage);
      }

      const result = await response.json();
      
      // Persist score to localStorage
      if (result.success && window.JobHackAIStatePersistence) {
        window.JobHackAIStatePersistence.saveATSScore({
          score: result.score,
          breakdown: result.breakdown,
          resumeId,
          jobTitle
        });
      }
      
      return result;
    }

    async function getResumeFeedback(resumeId, jobTitle) {
      // Validate resumeId before making API call
      if (!resumeId || resumeId === null || resumeId === undefined) {
        throw new Error('Resume ID is required. Please upload a resume first.');
      }
      
      const token = await getAuthToken();
      
      // Try to get resumeText from sessionStorage (fallback when KV unavailable)
      // Use nullish coalescing to only convert null to undefined, preserving empty strings
      const resumeText = sessionStorage.getItem('currentResumeText') ?? undefined;
      
      // Build request body with optional resumeText for dev fallback
      // Prompt/output shape expectation (lightweight, not a hard contract):
      // { targetRoleUsed?: string, sections: [{ sectionId, label, priority, insights:[], rewritePreview? }] }
      // Accept 1‚Äì5 sections; partial sections are valid.
      const requestBody = { resumeId, jobTitle };
      if (resumeText) {
        requestBody.resumeText = resumeText;
        // Also get isMultiColumn if available from state persistence
        if (window.JobHackAIStatePersistence) {
          const resumeData = window.JobHackAIStatePersistence.loadResumeData();
          if (resumeData && resumeData.isMultiColumn !== undefined) {
            requestBody.isMultiColumn = resumeData.isMultiColumn;
          }
        }
      }
      
      // Use retry logic for API call
      const response = await window.JobHackAIRetry.fetchWithRetry('/api/resume-feedback', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      }, {
        maxRetries: 3,
        initialDelay: 1000
      });

      if (!response.ok) {
        const error = await response.json();
        // Map error codes to user-friendly messages
        let errorMessage = error.error || 'Failed to get feedback';
        if (error.error === 'Feature locked') {
          errorMessage = 'This feature is available on the Pro plan. Upgrade to unlock full feedback.';
        } else if (error.error === 'Unauthorized') {
          errorMessage = 'Please log in to continue.';
        } else if (response.status === 403) {
          errorMessage = error.message || 'Access denied. Please check your plan or try logging in again.';
        }
        console.error('[RESUME-FEEDBACK] API error:', {
          status: response.status,
          error: error.error,
          message: error.message,
          upgradeRequired: error.upgradeRequired
        });
        throw new Error(errorMessage);
      }

      return await response.json();
    }

    // Global storage for latest feedback results to use in rewrite
    window.latestAtsIssues = null;
    window.latestRoleSpecific = null;

    async function rewriteResume(resumeId, section, jobTitle, atsIssues, roleSpecificFeedback) {
      const token = await getAuthToken();
      
      // Build request body with optional ATS context
      const requestBody = { resumeId, section, jobTitle };
      if (atsIssues && Array.isArray(atsIssues) && atsIssues.length > 0) {
        requestBody.atsIssues = atsIssues;
      }
      if (roleSpecificFeedback) {
        requestBody.roleSpecificFeedback = roleSpecificFeedback;
      }
      
      // Use retry logic for API call
      const response = await window.JobHackAIRetry.fetchWithRetry('/api/resume-rewrite', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(requestBody)
      }, {
        maxRetries: 3,
        initialDelay: 1000
      });

      if (!response.ok) {
        const error = await response.json();
        // Map error codes to user-friendly messages
        let errorMessage = error.error || 'Failed to rewrite resume';
        if (error.error === 'Feature locked') {
          errorMessage = 'This feature is available on the Pro plan. Upgrade to unlock full feedback.';
        } else if (error.error === 'Unauthorized') {
          errorMessage = 'Please log in to continue.';
        } else if (response.status === 403) {
          errorMessage = error.message || 'Access denied. Please check your plan or try logging in again.';
        }
        console.error('[RESUME-REWRITE] API error:', {
          status: response.status,
          error: error.error,
          message: error.message,
          upgradeRequired: error.upgradeRequired
        });
        throw new Error(errorMessage);
      }

      const result = await response.json();
      
      // Note: atsIssues and roleSpecificFeedback are only returned from /api/resume-feedback,
      // not from /api/resume-rewrite. They are already stored when feedback is received.
      
      return result;
    }

    function handleApiError(error) {
      // Downgrade to debug level - user-facing errors shown via modals
      if (window.console && window.console.debug) {
        window.console.debug('[API Error]', error);
      }
      let message = error.message || 'An error occurred';
      let modalType = 'error';
      let action = null;
      let actionLabel = 'OK';
      
      // Map error messages to user-friendly modals
      if (message.includes('Unauthorized') || message.includes('Not authenticated')) {
        message = 'Please log in to continue.';
        action = () => window.location.href = 'login.html';
        actionLabel = 'Go to Login';
      } else if (message.includes('Usage limit') || message.includes('limit reached')) {
        message = message + ' Upgrade to unlock more features.';
        action = () => window.location.href = 'pricing-a.html';
        actionLabel = 'View Pricing';
      } else if (message.includes('Rate limit')) {
        message = message + ' Please try again in a moment.';
      } else if (message.includes('Feature locked') || message.includes('upgrade')) {
        message = message;
        action = () => window.location.href = 'pricing-a.html';
        actionLabel = 'Upgrade Now';
      } else if (message.includes('timeout') || message.includes('took too long')) {
        message = 'Our AI took too long to respond. Please try again or simplify your file.';
        action = () => window.location.reload();
        actionLabel = 'Reload Page';
      } else if (message.includes('couldn\'t read') || message.includes('text-based')) {
        // File reading error - already user-friendly
      } else if (message.includes('scanned PDF') || message.includes('image-based')) {
        // Enhanced scanned PDF message with actionable guidance
        message = 'This PDF appears to be image-based (scanned). Please upload a text-based PDF or Word document for best results. We\'re working on scan support for a future update.';
      }

      // Show modal instead of inline error
      if (window.showErrorModal) {
        window.showErrorModal('Error', message, {
          buttonText: actionLabel || 'Got it',
          onClose: action || null,
          showRetry: !!action,
          retryCallback: action || null
        });
      } else {
        // Fallback to inline error if modals not loaded
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = 'background:#FEE2E2;border-left:4px solid #EF4444;color:#991B1B;padding:1rem;border-radius:8px;margin:1rem 0;';
        errorDiv.textContent = message;
        const main = document.querySelector('main');
        if (main) {
          main.insertBefore(errorDiv, main.firstChild);
          setTimeout(() => errorDiv.remove(), 5000);
        }
      }

      return message;
    }

    // Loading overlay management
    let currentLoadingOverlay = null;
    
    function showLoadingState(message = 'Loading...') {
      // For regenerate/rewrite/update/optimize operations - use lightweight overlay
      // since content is already visible and we're just updating it
      if (message.includes('Regenerating') || message.includes('Rewriting') || 
          message.includes('Updating') || message.includes('Optimizing')) {
        if (window.JobHackAILoading) {
          currentLoadingOverlay = window.JobHackAILoading.show(message, 'main-loading-overlay');
        }
        return;
      }
      
      // For initial loads ("Analyzing") - use skeleton loading instead of overlay
      // This provides better UX with contextual placeholders that match the final content layout
      const userPlan = getCurrentUserPlan();
      const willGetFeedback = ['trial', 'essential', 'pro', 'premium'].includes(userPlan);
      
      // Show skeletons for initial analysis
      showSkeletons(willGetFeedback);
      hideHeaderSkeleton();
      
      // Store cleanup function (skeleton hide function)
      currentLoadingOverlay = () => {
        hideSkeletons();
      };
    }

    function hideLoadingState() {
      if (currentLoadingOverlay) {
        if (typeof currentLoadingOverlay === 'function') {
          // It's a skeleton cleanup function
          currentLoadingOverlay();
        } else if (window.JobHackAILoading) {
          // It's an overlay element, hide it
          window.JobHackAILoading.hide('main-loading-overlay');
        }
        currentLoadingOverlay = null;
      }
    }

    function forceHideOverlays() {
      try {
        hideLoadingState();
        const legacy = document.getElementById('loading-overlay');
        if (legacy) legacy.style.display = 'none';
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to force hide overlays', e);
      }
    }

    // --- GLOBAL BUTTON LISTENER FUNCTIONS ---
    // Copy resume handler function
    const copyResumeHandler = function() {
      const rewritten = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[1];
      if (rewritten) {
        navigator.clipboard.writeText(rewritten.value || rewritten.textContent);
        this.textContent = 'Copied!';
        setTimeout(() => { this.textContent = 'Copy Rewritten Resume'; }, 1200);
        
        // Show success toast
        if (window.JobHackAIToast) {
          window.JobHackAIToast.success('Copied to clipboard!');
        }
      }
    };
    
    // Regenerate rewrite handler function
    const regenerateRewriteHandler = async function() {
      if (!currentResumeId) {
        handleApiError(new Error('Please upload a resume first'));
        return;
      }

      const jobTitle = document.getElementById('rf-job-title')?.value?.trim() || currentJobTitle;
      if (!jobTitle) {
        handleApiError(new Error('Please enter a target job title'));
        return;
      }
      const section = null; // Can be enhanced to allow section-specific rewrites

      try {
        showLoadingState('Rewriting resume...');
        this.disabled = true;
        this.textContent = 'Regenerating...';

        // Use stored feedback context if available
        const atsIssues = window.latestAtsIssues || null;
        const roleSpecificFeedback = window.latestRoleSpecific || null;
        
        const result = await rewriteResume(currentResumeId, section, jobTitle, atsIssues, roleSpecificFeedback);
        
        console.log('üìù [RESUME-REWRITE] API result:', {
          hasRewritten: !!result.rewritten,
          hasRewrittenResume: !!result.rewrittenResume,
          hasChangeSummary: !!result.changeSummary,
          changeSummary: result.changeSummary
        });
        
        const rewrittenBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[1];
        if (rewrittenBox) {
          rewrittenBox.value = result.rewritten || result.rewrittenResume || '';
        }
        
        // Also populate the original snippet box
        const originalBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[0];
        if (originalBox && result.original) {
          originalBox.value = result.original;
        }
        
        // Display change summary if available
        if (result.changeSummary) {
          console.log('‚úÖ [RESUME-REWRITE] Displaying change summary:', result.changeSummary);
          displayChangeSummary(result.changeSummary);
        } else {
          console.warn('‚ö†Ô∏è [RESUME-REWRITE] No change summary in API response');
        }

        // Show success toast
        if (window.JobHackAIToast) {
          window.JobHackAIToast.success('Resume rewritten successfully!');
        }
        
        // Save job title to state persistence
        if (window.JobHackAIStatePersistence && jobTitle) {
          // Pass current job title to validate cache match
          const cachedScore = window.JobHackAIStatePersistence.loadATSScore(jobTitle);
          if (cachedScore) {
            window.JobHackAIStatePersistence.saveATSScore({
              ...cachedScore,
              jobTitle: jobTitle
            });
          }
        }

        this.textContent = 'Generate Rewrite';
      // Let cooldown renderer own button state; await to avoid race
      await renderRewriteCooldownIndicator();
      hideLoadingState();
      } catch (error) {
        handleApiError(error);
        this.textContent = 'Generate Rewrite';
      // Let cooldown renderer own button state; await to avoid race
      await renderRewriteCooldownIndicator();
      hideLoadingState();
      }
    };
    
    // Render rewrite cooldown indicator using shared usage indicator component
    async function renderRewriteCooldownIndicator() {
      const container = document.getElementById('rf-rewrite-cooldown');
      const setRegenEnabled = () => {
        const regenBtn = document.querySelector('#rf-rewrite-content .btn.btn-secondary');
        if (regenBtn) regenBtn.disabled = false;
      };
      if (!container || typeof window.renderUsageIndicator !== 'function') {
        setRegenEnabled();
        return;
      }

      // Track latest invocation to avoid overlapping intervals
      const callId = (window._rewriteCooldownCallId || 0) + 1;
      window._rewriteCooldownCallId = callId;

      const clearExistingInterval = () => {
        if (window._rewriteCooldownInterval) {
          clearInterval(window._rewriteCooldownInterval);
          window._rewriteCooldownInterval = null;
        }
      };

      const token = localStorage.getItem('firebase-id-token');
      if (!token) {
        if (callId !== window._rewriteCooldownCallId) return;
        clearExistingInterval();
        container.innerHTML = '';
        setRegenEnabled();
        return;
      }

      try {
        const resp = await fetch('/api/usage', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          }
        });

        if (callId !== window._rewriteCooldownCallId) return;

        if (!resp.ok) {
          clearExistingInterval();
          container.innerHTML = '';
          setRegenEnabled();
          return;
        }

        const data = await resp.json();
        const usage = data?.usage?.resumeRewrite;
        const plan = data?.plan;

        if (!usage || usage.cooldown === undefined) {
          clearExistingInterval();
          container.innerHTML = '';
          setRegenEnabled();
          return;
        }

        // Clear any existing interval before rendering new state
        clearExistingInterval();

        const renderChip = (cooldownValue) => {
          if (callId !== window._rewriteCooldownCallId) return;
          container.innerHTML = '';
          const holder = document.createElement('div');
          container.appendChild(holder);

          window.renderUsageIndicator({
            feature: 'resumeRewrite',
            usage: { ...usage, cooldown: cooldownValue },
            plan,
            container: holder
          });

          if (cooldownValue > 0) {
            const helper = document.createElement('div');
            helper.style.cssText = 'margin-top:0.25rem;color:var(--color-text-secondary);font-size:0.9rem;';
            helper.textContent = 'We‚Äôre preparing your next rewrite. You can run a new one when this ends.';
            container.appendChild(helper);
          }

          const regenBtn = document.querySelector('#rf-rewrite-content .btn.btn-secondary');
          if (regenBtn) regenBtn.disabled = cooldownValue > 0;
          if (cooldownValue === 0) setRegenEnabled();
        };

        renderChip(usage.cooldown);

        if (usage.cooldown > 0) {
          let remaining = usage.cooldown;
          window._rewriteCooldownInterval = setInterval(() => {
            if (callId !== window._rewriteCooldownCallId) {
              clearExistingInterval();
              return;
            }
            remaining -= 1;
            if (remaining <= 0) {
              clearInterval(window._rewriteCooldownInterval);
              window._rewriteCooldownInterval = null;
              renderRewriteCooldownIndicator();
              return;
            }
            renderChip(remaining);
          }, 1000);
        }
      } catch (err) {
        console.warn('[RESUME-REWRITE] Failed to render cooldown indicator', err);
        clearExistingInterval();
        setRegenEnabled();
      }
    }
    
    // Resume Rewriting Buttons - Fixed selectors to match actual HTML
    const attachRewriteButtonListeners = () => {
      const copyBtn = document.querySelector('#rf-rewrite-content .btn.btn-primary');
      const regenRewriteBtn = document.querySelector('#rf-rewrite-content .btn.btn-secondary');
      
      if (copyBtn) {
        // Remove any existing listeners
        copyBtn.removeEventListener('click', copyResumeHandler);
        copyBtn.addEventListener('click', copyResumeHandler);
      }
      
      if (regenRewriteBtn) {
        // Remove any existing listeners
        regenRewriteBtn.removeEventListener('click', regenerateRewriteHandler);
        regenRewriteBtn.addEventListener('click', regenerateRewriteHandler);
      }

      // Initial render of cooldown state on mount
      renderRewriteCooldownIndicator();
    };

    // --- DEV-ONLY PLAN TOGGLE LOGIC ---
    document.addEventListener('DOMContentLoaded', function() {
      // Wait for navigation system to be ready before initializing
      function waitForNavigationAndInit() {
        if (window.JobHackAINavigation && typeof window.JobHackAINavigation.getEffectivePlan === 'function') {
          console.log('Navigation system ready, initializing resume feedback page');
          // Use navigation system's plan instead of hardcoded value
          user.plan = getCurrentUserPlan();
          
          // Listen for plan changes from navigation system
          window.addEventListener('storage', function(e) {
            if (e.key === 'dev-plan' || e.key === 'user-plan' || e.key === 'user-authenticated') {
              console.log('Plan change detected via storage:', e.key, e.newValue);
              updateRfTileForPlan();
            }
          });
          
          // Listen for custom plan change events
          window.addEventListener('planChanged', function(e) {
            console.log('Plan changed from', e.detail.oldPlan, 'to', e.detail.newPlan);
            updateRfTileForPlan();
            // Re-attach button listeners after plan change
            setTimeout(attachRewriteButtonListeners, 100);
          });
          
          // Listen for navigation ready event
          window.addEventListener('navigationReady', function() {
            console.log('Navigation ready event received, updating resume feedback');
            updateRfTileForPlan();
          });
          
          // Initial update
          updateRfTileForPlan();
          
          // Set up periodic plan checking to catch any missed updates
          let lastKnownPlan = null;
          setInterval(function() {
            const currentPlan = getCurrentUserPlan();
            if (currentPlan !== lastKnownPlan) {
              console.log('Plan change detected via periodic check:', lastKnownPlan, '->', currentPlan);
              lastKnownPlan = currentPlan;
              updateRfTileForPlan();
            }
          }, 1000); // Check every second
        } else {
          console.log('Navigation system not ready, retrying in 100ms');
          setTimeout(waitForNavigationAndInit, 100);
        }
      }
      
      // Start waiting for navigation system
      waitForNavigationAndInit();
      
      // Initialize role selector - ensure it's initialized after DOM and RoleSelector are ready
      let roleSelectorInitAttempts = 0;
      const MAX_ROLE_SELECTOR_ATTEMPTS = 50; // Try for up to 10 seconds (50 * 200ms)
      
      function initializeRoleSelector() {
        const jobTitleInput = document.getElementById('rf-job-title');
        if (!jobTitleInput) {
          // Element not ready yet, retry
          if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
            roleSelectorInitAttempts++;
            setTimeout(initializeRoleSelector, 100);
          } else {
            console.warn('[RESUME-FEEDBACK] Job title input not found after max attempts');
          }
          return;
        }
        
        // Wait for RoleSelector class to be available (from role-selector.js module)
        if (window.RoleSelector) {
          // Check if already initialized to avoid duplicate initialization
          if (!jobTitleInput.dataset.roleSelectorInitialized) {
            try {
              const roleSelector = new window.RoleSelector(jobTitleInput, {
                placeholder: 'Start typing your target role (e.g., Software Engineer, Product Manager)',
                minChars: 2,
                maxResults: 8,
                showCustomOption: true,
                onSelect: function(roleName, isCustom) {
                  // Update currentJobTitle when role is selected
                  currentJobTitle = roleName;
                  console.log('[RESUME-FEEDBACK] Role selected:', roleName, isCustom ? '(custom)' : '');
                  
                  // Update the input's aria-expanded attribute
                  jobTitleInput.setAttribute('aria-expanded', 'false');
                  
                  // Enable generate button if file is selected
                  const fileInput = document.getElementById('rf-upload');
                  const generateBtn = document.getElementById('rf-generate-btn');
                  if (fileInput && generateBtn && fileInput.files && fileInput.files.length > 0) {
                    generateBtn.disabled = false;
                  }
                }
              });
              jobTitleInput.dataset.roleSelectorInitialized = 'true';
              console.log('[RESUME-FEEDBACK] RoleSelector initialized successfully');
              
              // Also listen for input changes to update currentJobTitle when user types
              jobTitleInput.addEventListener('input', function() {
                const value = this.value.trim();
                if (value) {
                  currentJobTitle = value;
                  console.log('[RESUME-FEEDBACK] Job title updated:', value);
                } else {
                  // Clear currentJobTitle if input is cleared
                  currentJobTitle = null;
                }
              });
              
              // Prevent default value from being set
              jobTitleInput.addEventListener('focus', function() {
                // Ensure no default value is set when focusing
                if (this.value === 'Software Engineer' && !currentJobTitle) {
                  this.value = '';
                }
              });
              
              // Listen for blur to capture final value even if user doesn't select from dropdown
              jobTitleInput.addEventListener('blur', function() {
                const value = this.value.trim();
                if (value) {
                  currentJobTitle = value;
                } else {
                  currentJobTitle = null;
                }
              });
            } catch (error) {
              console.error('[RESUME-FEEDBACK] Failed to initialize RoleSelector:', error);
              // Retry once more after a delay
              if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
                roleSelectorInitAttempts++;
                setTimeout(initializeRoleSelector, 500);
              } else {
                console.warn('[RESUME-FEEDBACK] RoleSelector initialization failed after max attempts - dropdown may not work');
              }
            }
          }
        } else {
          // RoleSelector not loaded yet, wait and retry
          if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
            roleSelectorInitAttempts++;
            setTimeout(initializeRoleSelector, 200);
          } else {
            console.warn('[RESUME-FEEDBACK] RoleSelector not available after max attempts - dropdown may not work');
          }
        }
      }
      
      // Initialize role selector after DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeRoleSelector);
      } else {
        // DOM already ready, but wait a bit for scripts to load
        setTimeout(initializeRoleSelector, 100);
      }

      // Load cached ATS score on page load (with KV fallback)
      async function loadCachedATSScore() {
        let cachedScore = null;
        
        // FIX: Initialize ATS score to 0% for new users before checking cache
        updateProgressRing(0);
        
        // Try state persistence first
        // On initial page load, don't validate against input field (which is empty)
        // This allows us to restore cached scores and populate the job title field
        // Validation only happens when user explicitly provides a job title for new analysis
        if (window.JobHackAIStatePersistence) {
          cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
        }
        
        // If no cached score, try KV fallback
        if (!cachedScore || !cachedScore.score) {
          try {
            const user = window.FirebaseAuthManager?.getCurrentUser?.();
            if (user) {
              const idToken = await user.getIdToken();
              const kvResponse = await fetch('/api/ats-score-persist', {
                method: 'GET',
                headers: {
                  'Authorization': `Bearer ${idToken}`
                }
              });
              
              if (kvResponse.ok) {
                const kvData = await kvResponse.json();
                if (kvData.success && kvData.data) {
                  const resumeData = kvData.data;
                  cachedScore = {
                    score: resumeData.score,
                    breakdown: resumeData.breakdown || {},
                    jobTitle: resumeData.jobTitle || null,
                    resumeId: resumeData.resumeId || null,
                    timestamp: resumeData.timestamp || Date.now() // Include timestamp, fallback to now if missing
                  };
                  
                  // Cache KV results back to localStorage
                  if (window.JobHackAIStatePersistence) {
                    window.JobHackAIStatePersistence.saveATSScore({
                      score: resumeData.score,
                      breakdown: resumeData.breakdown || {},
                      resumeId: resumeData.resumeId || '',
                      jobTitle: resumeData.jobTitle || null
                    });
                  }
                  
                  console.log('[RESUME-FEEDBACK] Loaded ATS score from KV:', resumeData.score);
                }
              }
            }
          } catch (kvError) {
            console.warn('[RESUME-FEEDBACK] KV fetch failed:', kvError);
          }
        }
        
          if (cachedScore && cachedScore.score) {
          console.log('[RESUME-FEEDBACK] Loading cached ATS score:', cachedScore.score);
          updateProgressRing(cachedScore.score);
          
          // Hide placeholder
          hidePlaceholder();
          
          // Show rubric grid
          const rubricGrid = document.getElementById('rf-rubric-grid');
          if (rubricGrid) {
            rubricGrid.style.display = 'grid';
          }
          
          // Convert breakdown to rubric format if available
          if (cachedScore.breakdown) {
            // Map cached breakdown structure to rubric format
            // API returns: breakdown.keywordScore = { score, max, feedback }
            // Also supports legacy format: breakdown.keywordScore = number
            // Rubric expects: { score, max, tip }
            
            // Helper to extract score from either object or number
            const getScore = (value) => {
              if (typeof value === 'number') return value;
              if (value && typeof value === 'object' && typeof value.score === 'number') return value.score;
              return 0;
            };
            
            // Helper to extract feedback from breakdown object
            // The breakdown objects should have feedback property directly
            const getFeedback = (value) => {
              if (value && typeof value === 'object') {
                // Check for feedback property first (most common)
                if (typeof value.feedback === 'string') {
                  return limitFeedbackToSentences(value.feedback);
                }
                // Fallback to tip property if feedback doesn't exist
                if (typeof value.tip === 'string') {
                  return limitFeedbackToSentences(value.tip);
                }
              }
              return '';
            };
            
            const rubric = [
              {
                label: 'Keyword Relevance',
                score: getScore(cachedScore.breakdown.keywordScore),
                max: 40,
                tip: getFeedback(cachedScore.breakdown.keywordScore)
              },
              {
                label: 'Formatting Compliance',
                score: getScore(cachedScore.breakdown.formattingScore),
                max: 20,
                tip: getFeedback(cachedScore.breakdown.formattingScore)
              },
              {
                label: 'Structure & Section Completeness',
                score: getScore(cachedScore.breakdown.structureScore),
                max: 15,
                tip: getFeedback(cachedScore.breakdown.structureScore)
              },
              {
                label: 'Tone & Clarity',
                score: getScore(cachedScore.breakdown.toneScore),
                max: 15,
                tip: getFeedback(cachedScore.breakdown.toneScore)
              },
              {
                label: 'Grammar & Spelling',
                score: getScore(cachedScore.breakdown.grammarScore),
                max: 10,
                tip: getFeedback(cachedScore.breakdown.grammarScore)
              }
            ];
            updateRubricGrid(rubric);
          }
          
          // Restore role-specific feedback if available (supports both old and new formats)
          if (cachedScore.roleSpecificFeedback) {
            const isOldFormat = Array.isArray(cachedScore.roleSpecificFeedback) && 
                               cachedScore.roleSpecificFeedback.length > 0;
          const isNewFormat = isValidRoleTips(cachedScore.roleSpecificFeedback);
          
          if (isOldFormat || isNewFormat) {
              updateFeedbackGrid(cachedScore.roleSpecificFeedback);
            } else {
              console.warn('[RESUME-FEEDBACK] Invalid roleSpecificFeedback format in cache:', typeof cachedScore.roleSpecificFeedback);
            }

            updateRoleTipsState({
              hasAtsScore: true,
              roleSpecificFeedback: cachedScore.roleSpecificFeedback || null
            });
          } else {
            // No role feedback available or no score ‚Äì hide tips area
            updateRoleTipsState({
              hasAtsScore: !!cachedScore?.score,
              roleSpecificFeedback: null
            });
          }
          
          // Do NOT restore job title from cache; must be explicitly provided each run
          // Restore file name if available (display only - don't enable button)
          // Browsers don't persist file inputs, so user must re-select file
          const fileNameSpan = document.getElementById('rf-file-name');
          if (lastResumeName && fileNameSpan) {
            fileNameSpan.textContent = lastResumeName + ' (please re-select file)';
            fileNameSpan.style.color = 'var(--color-text-muted)';
            fileNameSpan.style.fontWeight = 'normal';
            
            // Do NOT enable generate button - file input is empty after page reload
            // User must select a file again before the button can be enabled
          }
        }
      }
      
    function clearTargetRoleState() {
      const jobTitleInput = document.getElementById('rf-job-title');
      if (jobTitleInput) {
        jobTitleInput.value = '';
      }
      currentJobTitle = '';
      try {
        sessionStorage.removeItem('currentJobTitle');
        localStorage.removeItem('jh_last_job_title');
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to clear job title state', e);
      }
    }

    // Expose for history interactions
    window.clearTargetRoleState = clearTargetRoleState;

    window.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        forceHideOverlays();
      }
    });

    window.addEventListener('pagehide', () => {
      forceHideOverlays();
      clearTargetRoleState();
    });

    window.addEventListener('beforeunload', () => {
      clearTargetRoleState();
    });

      // Load cached score on page load
      loadCachedATSScore().then(() => {
        // Check if we have resume data after loading
        const rubricScores = document.querySelectorAll('#rf-rubric-grid .rf-rubric-item .rf-rubric-score');
        const hasResumeData = rubricScores.length > 0 && Array.from(rubricScores).some(el => el.textContent !== '‚Äî / ‚Äî');
        
        if (!hasResumeData) {
          // Keep placeholder hidden to avoid duplicate empty-state copy
          const placeholder = document.getElementById('ats-placeholder');
          if (placeholder) placeholder.style.display = 'none';
          const regenBtn = document.getElementById('rf-regenerate-btn');
          if (regenBtn) regenBtn.style.display = 'none';
        }

        const optimizeBtn = document.getElementById('rf-optimize-btn');
        if (optimizeBtn) {
          optimizeBtn.addEventListener('click', async function() {
            const currentResumeId = sessionStorage.getItem('currentResumeId') || localStorage.getItem('jh_last_resume_id');
            if (!currentResumeId) {
              if (window.JobHackAIToast) {
                window.JobHackAIToast.error('Please upload a resume first');
              }
              return;
            }
            
            const jobTitleInput = document.getElementById('rf-job-title');
            const jobTitle = jobTitleInput?.value?.trim() || '';
            
            try {
              showLoadingState('Optimizing for ATS compliance‚Ä¶');
              this.disabled = true;
              this.textContent = 'Optimizing...';
              
              const feedbackResult = await getResumeFeedback(currentResumeId, jobTitle);
              
              // Update history with new session (D1-backed)
              if (window.JobHackAIHistory && feedbackResult.sessionId) {
                window.JobHackAIHistory.addItem(feedbackResult.sessionId, feedbackResult.meta);
              }
              
              // Store latest feedback results for rewrite calls
              if (feedbackResult.atsIssues) {
                window.latestAtsIssues = feedbackResult.atsIssues;
              }
              if (feedbackResult.roleSpecificFeedback) {
                window.latestRoleSpecific = feedbackResult.roleSpecificFeedback;
              }
              
              updateFeedbackGrid(feedbackResult.roleSpecificFeedback);
              updateRubricGridFromFeedback(feedbackResult.atsRubric);
              
              // CRITICAL: Ensure feedback content is visible after feedback is generated (Pro & Premium)
              const feedbackContentEl = document.getElementById('rf-feedback-content');
              const userPlanCheck = getCurrentUserPlan();
              if (feedbackContentEl && ['pro', 'premium'].includes(userPlanCheck)) {
                feedbackContentEl.style.display = 'block';
                console.log('[RESUME-FEEDBACK] Feedback content shown after optimize for:', userPlanCheck);
              }

              // Load cached score to check if ATS score exists
              let cachedScore = null;
              if (window.JobHackAIStatePersistence) {
                cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
              }
              
              const hasAtsScore = typeof cachedScore?.score === 'number';
              updateRoleTipsState({
                hasAtsScore,
                roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null
              });

              // Clear target role ONLY after a successful new analysis. History clicks must NOT change this input.
              const jobTitleInput = document.getElementById('rf-job-title');
              if (jobTitleInput) {
                jobTitleInput.value = '';
                currentJobTitle = '';
              }

              // Refresh Last analyzed from D1 (guarded to avoid ReferenceError)
              if (typeof fetchLatestFeedbackFromD1 === 'function') {
                fetchLatestFeedbackFromD1();
              }
              
              // Save role-specific feedback to persistence
              // Use cached score that was already loaded above
              // This allows updating feedback even when job title has changed
              if (window.JobHackAIStatePersistence) {
                if (cachedScore && cachedScore.resumeId === currentResumeId) {
                  // Merge feedback text from atsRubric into breakdown
                  const updatedBreakdown = { ...cachedScore.breakdown };
                  if (feedbackResult.atsRubric && Array.isArray(feedbackResult.atsRubric)) {
                    feedbackResult.atsRubric.forEach(item => {
                      const category = (item.category || item.label || '').toLowerCase();
                      const feedback = item.feedback || item.tip || '';
                      
                      if (category.includes('keyword') && updatedBreakdown.keywordScore) {
                        updatedBreakdown.keywordScore.feedback = feedback;
                      } else if (category.includes('format') && updatedBreakdown.formattingScore) {
                        updatedBreakdown.formattingScore.feedback = feedback;
                      } else if ((category.includes('structure') || category.includes('section')) && updatedBreakdown.structureScore) {
                        updatedBreakdown.structureScore.feedback = feedback;
                      } else if ((category.includes('tone') || category.includes('clarity')) && updatedBreakdown.toneScore) {
                        updatedBreakdown.toneScore.feedback = feedback;
                      } else if ((category.includes('grammar') || category.includes('spelling')) && updatedBreakdown.grammarScore) {
                        updatedBreakdown.grammarScore.feedback = feedback;
                      }
                    });
                  }
                  
                  // Update existing cached score with new job title, feedback, and updated breakdown
                  window.JobHackAIStatePersistence.saveATSScore({
                    ...cachedScore,
                    breakdown: updatedBreakdown,
                    jobTitle: jobTitle || null,
                    roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null
                  });
                } else if (currentResumeId && feedbackResult.atsRubric) {
                  // If no cached score exists, reconstruct breakdown from atsRubric to save feedback
                  // This ensures feedback is always saved even if cache is missing
                  const reconstructedBreakdown = {};
                  let totalScore = 0;
                  
                  // Reconstruct breakdown from atsRubric
                  feedbackResult.atsRubric.forEach(item => {
                    const category = (item.category || item.label || '').toLowerCase();
                    const score = item.score || 0;
                    const max = item.max || 0;
                    const feedback = item.feedback || item.tip || '';
                    
                    totalScore += score;
                    
                    if (category.includes('keyword')) {
                      reconstructedBreakdown.keywordScore = { score, max: 40, feedback };
                    } else if (category.includes('format')) {
                      reconstructedBreakdown.formattingScore = { score, max: 20, feedback };
                    } else if (category.includes('structure') || category.includes('section')) {
                      reconstructedBreakdown.structureScore = { score, max: 15, feedback };
                    } else if (category.includes('tone') || category.includes('clarity')) {
                      reconstructedBreakdown.toneScore = { score, max: 15, feedback };
                    } else if (category.includes('grammar') || category.includes('spelling')) {
                      reconstructedBreakdown.grammarScore = { score, max: 10, feedback };
                    }
                  });
                  
                  // Save with reconstructed data
                  window.JobHackAIStatePersistence.saveATSScore({
                    score: totalScore,
                    breakdown: reconstructedBreakdown,
                    resumeId: currentResumeId,
                    jobTitle: jobTitle || null,
                    roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null
                  });
                  console.log('[RESUME-FEEDBACK] Saved feedback with reconstructed breakdown');
                }
              }
              
              // Show role feedback
              showRoleFeedback();
              
              if (window.JobHackAIToast) {
                window.JobHackAIToast.success('Feedback generated successfully!');
              }
              
              this.textContent = 'Optimize this resume';
              this.disabled = false;
              hideLoadingState();
            } catch (error) {
              handleApiError(error);
              this.textContent = 'Optimize this resume';
              this.disabled = false;
              hideLoadingState();
            }
          });
        }
      });

      // Helper function to limit feedback to 1-2 sentences
      function limitFeedbackToSentences(text, maxSentences = 2) {
        if (!text || typeof text !== 'string') return '';
        const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
        if (sentences.length === 0) return '';
        const result = sentences.slice(0, maxSentences).join('. ').trim();
        // Always ensure a period at the end if there's content
        return result + (result.endsWith('.') ? '' : '.');
      }
      
      // Helper function to generate ATS score and feedback
      async function generateATSAndFeedback() {
        const uploadInput = document.getElementById('rf-upload');
        const file = uploadInput?.files[0];
        if (!file) {
          handleApiError(new Error('Please select a resume file first'));
          return;
        }

        const jobTitleInput = document.getElementById('rf-job-title');
        const jobTitle = jobTitleInput?.value?.trim() || '';
        currentJobTitle = jobTitle; // Save for later use (optional, so empty is OK)
        
        // Save job title to state persistence (even if empty)
        if (window.JobHackAIStatePersistence) {
          // Pass current job title directly (empty string is valid and should be validated)
          // Only null should skip validation (page load scenario)
          const cachedScore = window.JobHackAIStatePersistence.loadATSScore(currentJobTitle ?? '');
          if (cachedScore) {
            window.JobHackAIStatePersistence.saveATSScore({
              ...cachedScore,
              jobTitle: currentJobTitle || null
            });
          }
        }

        const generateBtn = document.getElementById('rf-generate-btn');
        const statusDiv = document.getElementById('rf-generate-status');
        
        // Track whether ATS scoring succeeded (for credit restoration logic)
        let atsScoringSucceeded = false;
        
        try {
          generateBtn.disabled = true;
          if (statusDiv) {
            statusDiv.style.display = 'none';
          }
          showLoadingState('Analyzing your r√©sum√© for ATS criteria‚Ä¶');
          uploadInput.disabled = true;

          // Check if we already have a resumeId for this file
          // IMPORTANT: Only reuse if file name AND size match to detect content changes
          // File size is a simple content check - if user edits resume, size likely changes
          const existingResumeId = sessionStorage.getItem('currentResumeId') || localStorage.getItem('jh_last_resume_id');
          const existingFileName = localStorage.getItem('lastUploadedResumeName');
          const existingFileSize = localStorage.getItem('lastUploadedResumeSize');
          const currentFileSize = file.size.toString();
          
          let uploadResult;
          if (existingResumeId && existingFileName === file.name && existingFileSize === currentFileSize) {
            // File name and size match - likely same file, reuse existing resumeId
            // CRITICAL: Still need to check and consume credit for free accounts even when reusing
            // This prevents free users from bypassing the limit by re-uploading the same file
            const userPlan = getCurrentUserPlan();
            if (userPlan === 'free') {
              const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
              let hasCredit = false;
              
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                if (creditsData) {
                  try {
                    const credits = JSON.parse(creditsData);
                    hasCredit = credits.ats_free_lifetime > 0;
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data (cached path):', e);
                    hasCredit = true; // Default to allowing for new users or corrupted data
                  }
                } else {
                  // No credits data means user hasn't used it yet - grant access
                  hasCredit = true;
                }
              } else {
                console.warn('[RESUME-FEEDBACK] No authenticated user found for free account check (cached path)');
                hasCredit = false;
              }
              
              // Also check freeAccountManager as fallback
              if (!hasCredit && window.freeAccountManager) {
                try {
                  const usageCheck = window.freeAccountManager.canUseATSScoring();
                  hasCredit = usageCheck.allowed;
                } catch (e) {
                  console.warn('[RESUME-FEEDBACK] Error checking free account manager (cached path):', e);
                  hasCredit = false;
                }
              }
              
              if (!hasCredit) {
                // Free account limit reached - show upgrade message
                uploadInput.disabled = false;
                generateBtn.disabled = false;
                hideLoadingState();
                handleApiError(new Error('You have used your 1 free lifetime ATS score. Upgrade to continue scoring unlimited resumes.'));
                // Redirect to pricing page after showing error
                setTimeout(() => {
                  window.location.href = 'pricing-a.html?plan=essential';
                }, 2000);
                return;
              }
              
              // CRITICAL: Consume credit even when reusing cached resumeId
              // This prevents free users from bypassing the limit by re-uploading the same file
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                let credits = { ats_free_lifetime: 1 }; // Default for new users
                
                if (creditsData) {
                  try {
                    credits = JSON.parse(creditsData);
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data before consumption (cached path):', e);
                    credits = { ats_free_lifetime: 1 }; // Default to available on parse error
                  }
                }
                
                // Consume credit immediately (even for cached file reuse)
                credits.ats_free_lifetime = 0;
                localStorage.setItem(creditKey, JSON.stringify(credits));
                console.log('[RESUME-FEEDBACK] ‚úÖ Free ATS credit consumed in localStorage (cached file reuse)');
              }
            }
            
            console.log('[RESUME-FEEDBACK] Reusing existing resumeId (name and size match):', existingResumeId);
            const existingResumeText = sessionStorage.getItem('currentResumeText');
            uploadResult = {
              success: true,
              resumeId: existingResumeId,
              resumeText: existingResumeText || undefined,
              textPreview: existingResumeText ? (existingResumeText.length > 200 ? existingResumeText.substring(0, 200) + '...' : existingResumeText) : undefined
            };
            currentResumeId = existingResumeId;
            // Ensure resumeId is in sessionStorage for consistency
            sessionStorage.setItem('currentResumeId', existingResumeId);
            // Update filename and size in localStorage to keep state consistent
            localStorage.setItem('lastUploadedResumeName', file.name);
            localStorage.setItem('lastUploadedResumeSize', currentFileSize);
          } else {
            // New file or file changed - check free account limits before upload
            const userPlan = getCurrentUserPlan();
            if (userPlan === 'free') {
              // Check if free account has remaining credit
              const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
              let hasCredit = false;
              
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                if (creditsData) {
                  try {
                    const credits = JSON.parse(creditsData);
                    hasCredit = credits.ats_free_lifetime > 0;
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data:', e);
                    // Default to allowing for new users or corrupted data
                    hasCredit = true;
                  }
                } else {
                  // No credits data means user hasn't used it yet - grant access
                  hasCredit = true;
                }
              } else {
                // No authenticated user - should not reach here due to access control, but handle gracefully
                console.warn('[RESUME-FEEDBACK] No authenticated user found for free account check');
                hasCredit = false;
              }
              
              // Also check freeAccountManager as fallback
              if (!hasCredit && window.freeAccountManager) {
                try {
                  const usageCheck = window.freeAccountManager.canUseATSScoring();
                  hasCredit = usageCheck.allowed;
                } catch (e) {
                  console.warn('[RESUME-FEEDBACK] Error checking free account manager:', e);
                  // If check fails, deny access to be safe
                  hasCredit = false;
                }
              }
              
              if (!hasCredit) {
                // Free account limit reached - show upgrade message
                uploadInput.disabled = false;
                generateBtn.disabled = false;
                hideLoadingState();
                handleApiError(new Error('You have used your 1 free lifetime ATS score. Upgrade to continue scoring unlimited resumes.'));
                // Redirect to pricing page after showing error
                setTimeout(() => {
                  window.location.href = 'pricing-a.html?plan=essential';
                }, 2000);
                return;
              }
              
              // CRITICAL: Consume credit immediately after check passes to prevent multiple uploads
              // This prevents race conditions where multiple uploads could pass the check
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                let credits = { ats_free_lifetime: 1 }; // Default for new users
                
                if (creditsData) {
                  try {
                    credits = JSON.parse(creditsData);
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data before consumption:', e);
                    credits = { ats_free_lifetime: 1 }; // Default to available on parse error
                  }
                }
                
                // Consume credit immediately (before upload)
                credits.ats_free_lifetime = 0;
                localStorage.setItem(creditKey, JSON.stringify(credits));
                console.log('[RESUME-FEEDBACK] ‚úÖ Free ATS credit consumed in localStorage (before upload)');
              }
            }
            
            // New file or file changed (name or size different), upload it
            // Store file name and size after determining we need to upload
            localStorage.setItem('lastUploadedResumeName', file.name);
            localStorage.setItem('lastUploadedResumeSize', currentFileSize);
            uploadResult = await uploadResume(file);
          }
          
          // CRITICAL: If upload failed, don't proceed to ATS scoring
          if (!uploadResult || !uploadResult.success || !uploadResult.resumeId) {
            // Restore credit if upload failed (for free accounts)
            const userPlan = getCurrentUserPlan();
            if (userPlan === 'free') {
              const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
              if (currentUser && currentUser.uid) {
                const creditKey = `creditsByUid:${currentUser.uid}`;
                const creditsData = localStorage.getItem(creditKey);
                let credits = { ats_free_lifetime: 1 }; // Default for new users
                
                if (creditsData) {
                  try {
                    credits = JSON.parse(creditsData);
                  } catch (e) {
                    console.warn('[RESUME-FEEDBACK] Failed to parse credits data during restoration:', e);
                    credits = { ats_free_lifetime: 1 }; // Default on parse error
                  }
                }
                
                // Restore only the ats_free_lifetime credit, preserving other credit types
                credits.ats_free_lifetime = 1;
                localStorage.setItem(creditKey, JSON.stringify(credits));
                console.log('[RESUME-FEEDBACK] ‚úÖ Free ATS credit restored due to upload failure');
              }
            }
            
            // Error already shown by uploadResume, but we need to clean up UI state
            // Clean up any loading overlays
            if (window._currentFeedbackLoading) {
              window._currentFeedbackLoading();
              window._currentFeedbackLoading = null;
            }
            uploadInput.disabled = false;
            generateBtn.disabled = false;
            hideLoadingState();
            return;
          }
          
          currentResumeId = uploadResult.resumeId;
          
          // Clear previous feedback context when uploading a new resume
          // This prevents using feedback from the previous resume with the new one
          window.latestAtsIssues = null;
          window.latestRoleSpecific = null;

          // Step 1 complete: "Reading your resume..." overlay is already hidden by uploadResume()
          // Step 2: Show skeleton loading states instead of full-screen overlay
          // Free users only get ATS scoring, not AI feedback, so show different message
          const userPlan = getCurrentUserPlan();
          const willGetFeedback = ['trial', 'essential', 'pro', 'premium'].includes(userPlan);
          
          // Show skeleton loading states (replaces full-screen overlay)
          // Pass willGetFeedback to conditionally show/hide feedback skeleton
          showSkeletons(willGetFeedback);
          if (willGetFeedback) {
            setRoleStatus('Generating tips‚Ä¶');
          } else {
            setRoleStatus('');
          }
          // Capture skeleton generation for this run to guard against stale callbacks
          const atsRequestGeneration = skeletonOperationGeneration;
          // Hide skeleton header since real progress header is already visible
          hideHeaderSkeleton();
          
          // Store cleanup function for error handling (skeleton hide function)
          window._currentFeedbackLoading = () => {
            hideSkeletons();
          };

          // --- PARALLEL API CALLS: ATS Score + Feedback ---
          const jobTitleForScore = currentJobTitle || jobTitleInput?.value?.trim() || '';
          const jobTitleForFeedback = jobTitleInput?.value?.trim() || '';

          // Start both API calls in parallel
          const atsPromise = getAtsScore(uploadResult.resumeId, jobTitleForScore);
          const feedbackPromise = (async () => {
            const plan = getCurrentUserPlan();
            if (['trial', 'essential', 'pro', 'premium'].includes(plan)) {
              return await getResumeFeedback(uploadResult.resumeId, jobTitleForFeedback);
            }
            return null; // Free plan doesn't get feedback
          })();

          // Handle ATS result immediately without waiting for feedback (progressive display)
          // This ensures ATS scores appear in 2-3s as claimed in the PR
          let atsSettled;
          let feedbackSettled;
          
          // Process ATS result as soon as it's available
          atsPromise
            .then((result) => {
              // ATS succeeded - update UI immediately
              atsScoringSucceeded = result.success && result.score !== undefined;
              
              if (atsScoringSucceeded) {
                // Store ATS score in sessionStorage
                sessionStorage.setItem('currentAtsScore', result.score.toString());
                if (result.breakdown) {
                  sessionStorage.setItem('currentAtsBreakdown', JSON.stringify(result.breakdown));
                }
                
                // Also store in localStorage for backward compatibility
                const summary = result.score > 85 ? 'Excellent! Your resume is highly ATS compatible.' : 
                               result.score > 70 ? 'Your resume meets many ATS criteria and is likely to be noticed.' : 
                               'Your resume needs improvement for better ATS results.';
                localStorage.setItem('lastATSScore', result.score.toString());
                localStorage.setItem('lastATSSummary', summary);
                
                // Update UI immediately (progress ring, placeholder, etc.)
                updateProgressRing(result.score);
                hidePlaceholder();
                
                // Helper functions to handle both number and object formats (matches existing code pattern)
                const getScore = (value) => {
                  if (typeof value === 'number') return value;
                  if (value && typeof value === 'object' && typeof value.score === 'number') return value.score;
                  return 0;
                };
                
                const getFeedback = (value, feedbackArray, index) => {
                  // First try to get feedback from the value object (if it's an object with feedback property)
                  if (value && typeof value === 'object') {
                    if (typeof value.feedback === 'string') {
                      return limitFeedbackToSentences(value.feedback);
                    }
                    if (typeof value.tip === 'string') {
                      return limitFeedbackToSentences(value.tip);
                    }
                  }
                  // Fallback to feedback array (API returns breakdown as numbers, feedback in separate array)
                  if (feedbackArray && Array.isArray(feedbackArray) && feedbackArray[index]) {
                    return limitFeedbackToSentences(feedbackArray[index]);
                  }
                  return '';
                };
                
                // Convert breakdown to rubric format
                // Note: API returns breakdown values as numbers, feedback in separate array
                const rubric = [
                  {
                    label: 'Keyword Relevance',
                    score: getScore(result.breakdown.keywordScore),
                    max: 40,
                    tip: getFeedback(result.breakdown.keywordScore, result.feedback, 0)
                  },
                  {
                    label: 'Formatting Compliance',
                    score: getScore(result.breakdown.formattingScore),
                    max: 20,
                    tip: getFeedback(result.breakdown.formattingScore, result.feedback, 1)
                  },
                  {
                    label: 'Structure & Section Completeness',
                    score: getScore(result.breakdown.structureScore),
                    max: 15,
                    tip: getFeedback(result.breakdown.structureScore, result.feedback, 2)
                  },
                  {
                    label: 'Tone & Clarity',
                    score: getScore(result.breakdown.toneScore),
                    max: 15,
                    tip: getFeedback(result.breakdown.toneScore, result.feedback, 3)
                  },
                  {
                    label: 'Grammar & Spelling',
                    score: getScore(result.breakdown.grammarScore),
                    max: 10,
                    tip: getFeedback(result.breakdown.grammarScore, result.feedback, 4)
                  }
                ];
                updateRubricGrid(rubric);
                
                // Show ATS content immediately; keep role skeleton visible until role tips arrive
                if (atsRequestGeneration === skeletonOperationGeneration) {
                  hideATSSkeleton();
                } else {
                  console.warn('[RESUME-FEEDBACK] ATS skeleton hide skipped due to generation mismatch');
                }
                
                const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
                const skeletonContainer = document.getElementById('rf-skeleton-container');
                const shouldHideSkeletonContainer =
                  skeletonFeedback &&
                  (skeletonFeedback.style.display === 'none' || skeletonFeedback.childElementCount === 0);
                
                if (shouldHideSkeletonContainer && skeletonContainer) {
                  skeletonContainer.style.display = 'none';
                }
                
                // Show content container and ATS rubric
                const feedbackContentEl = document.getElementById('rf-feedback-content');
                if (feedbackContentEl) {
                  feedbackContentEl.style.display = 'block';
                }
                
                const rubricGrid = document.getElementById('rf-rubric-grid');
                if (rubricGrid) {
                  rubricGrid.style.display = 'grid';
                }
                
                // Trigger fade transition for ATS feedback
                setTimeout(() => {
                  showATSFeedback();
                }, 100);
                
                // Show success toast
                if (window.JobHackAIToast) {
                  window.JobHackAIToast.success('ATS score calculated successfully.');
                }
              } else {
                // ATS scoring failed
                // Clean up feedback loading overlay (consistent with .catch() handler)
                if (window._currentFeedbackLoading) {
                  window._currentFeedbackLoading();
                  window._currentFeedbackLoading = null;
                }
                handleApiError(new Error('Failed to calculate ATS score. Please try again.'));
              }
            })
            .catch((error) => {
              // ATS promise rejected
              console.error('[RESUME-FEEDBACK] ATS scoring failed:', error);
              // Clean up feedback loading overlay
              if (window._currentFeedbackLoading) {
                window._currentFeedbackLoading();
                window._currentFeedbackLoading = null;
              }
              handleApiError(error);
            });

          // Wait for both promises to settle (for error handling and final state)
          [atsSettled, feedbackSettled] = await Promise.allSettled([atsPromise, feedbackPromise]);
          
          // --- Process ATS Result (for error handling and state management) ---
          // Note: UI updates already happened in the .then() above for progressive display
          // This block is only for state management and error handling
          let scoreResult = null;
          if (atsSettled.status === 'fulfilled') {
            scoreResult = atsSettled.value;
            // atsScoringSucceeded already set in .then() handler above
          } else {
            // ATS promise rejected - error already handled in .catch() above
          }

          // --- Process Feedback Result (show when ready) ---
          if (feedbackSettled.status === 'fulfilled' && feedbackSettled.value) {
            const feedbackResult = feedbackSettled.value;
            try {
              // Update history with new session (D1-backed)
              if (window.JobHackAIHistory && feedbackResult.sessionId) {
                window.JobHackAIHistory.addItem(feedbackResult.sessionId, feedbackResult.meta);
              }
              
              // Store latest feedback results for rewrite calls
              if (feedbackResult.atsIssues) {
                window.latestAtsIssues = feedbackResult.atsIssues;
              }
              if (feedbackResult.roleSpecificFeedback) {
                window.latestRoleSpecific = feedbackResult.roleSpecificFeedback;
              }
              
              updateFeedbackGrid(feedbackResult.roleSpecificFeedback);
              updateRubricGridFromFeedback(feedbackResult.atsRubric);
              
              // Hide feedback skeleton now that real content is ready
              hideFeedbackSkeleton();
              
              // Feedback content container is already visible from ATS success handler
              // This ensures progressive display: ATS first, then feedback
              
              // Update role-specific tips state
              const hasAtsScore = atsScoringSucceeded;
              updateRoleTipsState({
                hasAtsScore,
                roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null
              });
              
              // Save role-specific feedback to persistence
              if (window.JobHackAIStatePersistence && atsScoringSucceeded) {
                // Use ATS score result if available, otherwise reconstruct
                const finalScore = atsScoringSucceeded ? 
                  (atsSettled.status === 'fulfilled' ? atsSettled.value.score : 0) : 0;
                const finalBreakdown = atsScoringSucceeded && atsSettled.status === 'fulfilled' ?
                  atsSettled.value.breakdown : {};
                
                // Reconstruct breakdown from atsRubric to ensure feedback is included
                let finalBreakdownWithFeedback = { ...finalBreakdown };
                
                if (feedbackResult.atsRubric && Array.isArray(feedbackResult.atsRubric)) {
                  const reconstructedBreakdown = {};
                  
                  feedbackResult.atsRubric.forEach(item => {
                    const category = (item.category || item.label || '').toLowerCase();
                    const score = item.score || 0;
                    const max = item.max || 0;
                    const feedback = item.feedback || item.tip || '';
                    
                    if (category.includes('keyword')) {
                      reconstructedBreakdown.keywordScore = { 
                        score, 
                        max: 40, 
                        feedback: feedback || finalBreakdown.keywordScore?.feedback || '' 
                      };
                    } else if (category.includes('format')) {
                      reconstructedBreakdown.formattingScore = { 
                        score, 
                        max: 20, 
                        feedback: feedback || finalBreakdown.formattingScore?.feedback || '' 
                      };
                    } else if ((category.includes('structure') || category.includes('section'))) {
                      reconstructedBreakdown.structureScore = { 
                        score, 
                        max: 15, 
                        feedback: feedback || finalBreakdown.structureScore?.feedback || '' 
                      };
                    } else if ((category.includes('tone') || category.includes('clarity'))) {
                      reconstructedBreakdown.toneScore = { 
                        score, 
                        max: 15, 
                        feedback: feedback || finalBreakdown.toneScore?.feedback || '' 
                      };
                    } else if ((category.includes('grammar') || category.includes('spelling'))) {
                      reconstructedBreakdown.grammarScore = { 
                        score, 
                        max: 10, 
                        feedback: feedback || finalBreakdown.grammarScore?.feedback || '' 
                      };
                    }
                  });
                  
                  finalBreakdownWithFeedback = {
                    ...finalBreakdown,
                    ...reconstructedBreakdown
                  };
                }
                
                // Save with reconstructed breakdown
                const saveSuccess = window.JobHackAIStatePersistence.saveATSScore({
                  score: finalScore,
                  breakdown: finalBreakdownWithFeedback,
                  resumeId: uploadResult.resumeId,
                  jobTitle: jobTitleForFeedback || null,
                  roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null
                });
                
                if (!saveSuccess) {
                  console.warn('[RESUME-FEEDBACK] Failed to save ATS score to persistence');
                } else {
                  console.log('[RESUME-FEEDBACK] Saved ATS score with breakdown including feedback');
                }
              }
            
              // Trigger fade transition for role feedback
              setTimeout(() => {
                showRoleFeedback();
              }, 100);
              
              // Truthful toast + inline status based on ATS/tips state
              const toastStatus = toastForAtsAndTips({
                atsOk: atsScoringSucceeded,
                tips: feedbackResult.roleSpecificFeedback
              });
              if (toastStatus === 'tips_ok' || toastStatus === 'tips_only') {
                setRoleStatus('Role-specific tips updated.');
              } else if (toastStatus === 'ats_only') {
                setRoleStatus('ATS score is ready. Role-specific tips are still loading‚Äîretry if needed.');
            } else if (toastStatus === 'missing') {
              setRoleStatus('Couldn‚Äôt refresh tips‚Äîretry.');
              }
            } catch (feedbackError) {
              console.error('[RESUME-FEEDBACK] Error processing feedback result:', feedbackError);
              // Don't show error modal - ATS score is already visible, feedback is optional
            }
          } else if (feedbackSettled.status === 'rejected') {
            // Feedback failed - log but don't block (ATS score is already shown)
            const error = feedbackSettled.reason;
            console.warn('[RESUME-FEEDBACK] Feedback generation failed (non-blocking):', error);
            
            // Hide role feedback container since we don't have valid feedback data
            hideRoleFeedback();
            setRoleStatus('Couldn‚Äôt refresh tips‚Äîretry.');
            
            // Show error modal but keep ATS score visible
            if (window.showErrorModal) {
              const errorMsg = error.message || 'Failed to generate feedback. Your ATS score is still available.';
              window.showErrorModal('Feedback Generation Failed', errorMsg, {
                buttonText: 'OK',
                onClose: () => {
                  // Keep ATS score visible - don't clear state
                }
              });
            }
            
            // Clean up feedback loading overlay on feedback failure
            if (window._currentFeedbackLoading) {
              window._currentFeedbackLoading();
              window._currentFeedbackLoading = null;
            }
            
            // Feedback failed, but ATS scoring may have succeeded
          } else {
            // Free plan - no feedback
            hideRoleFeedback();
            
            // Free plan - ATS scoring may have succeeded
          }
          
          // Hide "Generating AI feedback..." overlay when both API calls complete
          if (window._currentFeedbackLoading) {
            window._currentFeedbackLoading();
            window._currentFeedbackLoading = null;
          }
          
          // Both ATS scoring and feedback completed successfully

          // Update original snippet in rewrite section
          // Use full resume text if available, otherwise use preview
          const origBox = document.querySelectorAll('#rf-rewrite-content .rf-snippet-box')[0];
          if (origBox) {
            // Try to get full resume text from sessionStorage or upload result
            const resumeText = sessionStorage.getItem('currentResumeText') || uploadResult.resumeText;
            if (resumeText && resumeText.length > 0) {
              // Clean up text for display - remove excessive whitespace and ensure readability
              let cleanText = resumeText.replace(/\s+/g, ' ').trim();
              
              // Check if text became empty after cleaning (only whitespace was present)
              if (cleanText.length === 0) {
                // Text was only whitespace - show helpful message
                origBox.value = '‚ö†Ô∏è No readable text could be extracted from this file. Please upload a text-based PDF or DOCX file.';
              } else {
                // Validate text quality - check for excessive non-alphanumeric characters (possible OCR corruption)
                // Only calculate ratio if cleanText has content to avoid division by zero
                const alphanumericRatio = cleanText.length > 0 
                  ? (cleanText.match(/[a-zA-Z0-9\s]/g) || []).length / cleanText.length 
                  : 0;
                
                if (alphanumericRatio < 0.7 && cleanText.length > 100) {
                  // Text appears corrupted - show warning message instead
                  origBox.value = '‚ö†Ô∏è Text extraction quality is low. For best results, please upload a text-based PDF or DOCX file.\n\nExtracted text preview:\n' + cleanText.substring(0, 200) + '...';
                } else {
                  // Use first 500 characters for snippet display (more readable than 200)
                  // Ensure we don't cut in the middle of a word if possible
                  let snippet = cleanText.length > 500 ? cleanText.substring(0, 500) : cleanText;
                  const lastSpace = snippet.lastIndexOf(' ');
                  if (cleanText.length > 500 && lastSpace > 400) {
                    snippet = snippet.substring(0, lastSpace) + '...';
                  } else if (cleanText.length > 500) {
                    snippet = snippet + '...';
                  }
                  origBox.value = snippet;
                }
              }
            } else if (uploadResult.textPreview) {
              origBox.value = uploadResult.textPreview;
            } else {
              // If no text available, show placeholder
              origBox.value = 'Resume text will appear here after analysis.';
            }
          }

          // Update description (preserve tooltip HTML)
          const descEl = document.getElementById('rf-score-desc');
          if (descEl && atsScoringSucceeded) {
            // Preserve existing tooltip if it exists
            const existingTooltip = descEl.querySelector('.rf-tooltip-trigger');
            const tooltipHtml = existingTooltip ? existingTooltip.outerHTML : '';
            descEl.innerHTML = 'Your resume was analyzed. See your ATS score and feedback below.' + (tooltipHtml ? ' ' + tooltipHtml : '');
          }

          uploadInput.disabled = false;
          generateBtn.disabled = false;
          hideLoadingState();
        } catch (error) {
          // Restore credit ONLY if ATS scoring failed (not for post-scoring errors)
          // If scoring succeeded but UI/feedback generation failed, user already got value
          const userPlan = getCurrentUserPlan();
          if (userPlan === 'free' && !atsScoringSucceeded) {
            const currentUser = window.FirebaseAuthManager?.getCurrentUser?.();
            if (currentUser && currentUser.uid) {
              const creditKey = `creditsByUid:${currentUser.uid}`;
              const creditsData = localStorage.getItem(creditKey);
              let credits = { ats_free_lifetime: 1 }; // Default for new users
              
              if (creditsData) {
                try {
                  credits = JSON.parse(creditsData);
                } catch (e) {
                  console.warn('[RESUME-FEEDBACK] Failed to parse credits data during restoration:', e);
                  credits = { ats_free_lifetime: 1 }; // Default on parse error
                }
              }
              
              // Restore only the ats_free_lifetime credit, preserving other credit types
              credits.ats_free_lifetime = 1;
              localStorage.setItem(creditKey, JSON.stringify(credits));
              console.log('[RESUME-FEEDBACK] ‚úÖ Free ATS credit restored due to scoring/upload failure');
            }
          } else if (userPlan === 'free' && atsScoringSucceeded) {
            // Log that credit is NOT restored because scoring succeeded
            console.log('[RESUME-FEEDBACK] ‚ö†Ô∏è Error occurred but ATS scoring succeeded - credit NOT restored');
          }
          
          // Clear state on error
          // Clean up feedback loading overlay
          if (window._currentFeedbackLoading) {
            window._currentFeedbackLoading();
            window._currentFeedbackLoading = null;
          }
          clearAtsState();
          handleApiError(error);
          uploadInput.disabled = false;
          generateBtn.disabled = false;
          hideLoadingState();
        }
      }

      // ATS Resume Upload Logic - Only update UI, don't trigger processing
      const uploadInput = document.getElementById('rf-upload');
      const fileNameSpan = document.getElementById('rf-file-name');
      const generateBtn = document.getElementById('rf-generate-btn');
      const statusDiv = document.getElementById('rf-generate-status');
      const startFreshBtn = document.getElementById('rf-start-fresh-btn');
      
      if (startFreshBtn) {
        startFreshBtn.addEventListener('click', function() {
          resetSession();
        });
      }
      
      if (uploadInput) {
        uploadInput.addEventListener('change', async function(e) {
          const file = e.target.files[0];
          const pdfHelper = document.getElementById('rf-pdf-helper');
          
          if (file) {
            // Immediately disable generate button while validating new file
            if (generateBtn) {
              generateBtn.disabled = true;
            }
            
            // Hide status pill initially while validating
            hideFileStatus();
            
            // Show/hide PDF helper text based on file type
            if (pdfHelper) {
              if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
                pdfHelper.style.display = 'block';
              } else {
                pdfHelper.style.display = 'none';
              }
            }
            
            // Validate file and show status pill
            try {
              const validation = await window.JobHackAIFileValidation.validateFile(file);
              
              if (!validation.valid) {
                // Invalid file - show error status
                showFileStatus('error', validation.error || 'File validation failed');
                if (fileNameSpan) {
                  fileNameSpan.textContent = file.name;
                  fileNameSpan.style.color = 'var(--color-error)';
                  fileNameSpan.style.fontWeight = '600';
                }
                if (generateBtn) {
                  generateBtn.disabled = true;
                }
                if (statusDiv) {
                  statusDiv.style.display = 'none';
                }
                return;
              }
              
              // Valid file - check for warnings
              if (validation.warning && validation.isScanned) {
                showFileStatus('warning', 'Scanned PDF detected ‚Äì may take longer');
              } else {
                showFileStatus('success', 'Ready to analyze');
              }
              
              // Preserve targeted role selection when uploading a resume
              // Don't clear job title input - user may want to analyze different resumes for the same role
              
              // Store file name in localStorage for persistence
              localStorage.setItem('lastUploadedResumeName', file.name);
              
              // Update file name display
              if (fileNameSpan) {
                fileNameSpan.textContent = file.name;
                fileNameSpan.style.color = 'var(--color-success)';
                fileNameSpan.style.fontWeight = '600';
              }
              
              // Enable generate button
              if (generateBtn) {
                generateBtn.disabled = false;
              }
              
              // Show ready status (legacy status div - keep for compatibility)
              if (statusDiv) {
                statusDiv.style.display = 'block';
                statusDiv.textContent = 'Ready to analyze';
                statusDiv.style.background = 'rgba(5,150,105,0.08)';
                statusDiv.style.color = 'var(--color-success)';
                statusDiv.style.width = 'fit-content';
                statusDiv.style.maxWidth = '100%';
              }
            } catch (validationError) {
              // Validation error - show error status
              console.error('[RESUME-FEEDBACK] File validation error:', validationError);
              showFileStatus('error', 'File validation failed');
              if (fileNameSpan) {
                fileNameSpan.textContent = file.name;
                fileNameSpan.style.color = 'var(--color-error)';
                fileNameSpan.style.fontWeight = '600';
              }
              if (generateBtn) {
                generateBtn.disabled = true;
              }
              if (statusDiv) {
                statusDiv.style.display = 'none';
              }
            }
          } else {
            // Reset if file cleared
            hideFileStatus();
            if (pdfHelper) {
              pdfHelper.style.display = 'none';
            }
            if (fileNameSpan) {
              fileNameSpan.textContent = 'No file selected';
              fileNameSpan.style.color = 'var(--color-text-muted)';
              fileNameSpan.style.fontWeight = 'normal';
            }
            if (generateBtn) {
              generateBtn.disabled = true;
            }
            if (statusDiv) {
              statusDiv.style.display = 'none';
            }
            localStorage.removeItem('lastUploadedResumeName');
          }
        });
      }

      // Generate Button Click Handler
      if (generateBtn) {
        generateBtn.addEventListener('click', generateATSAndFeedback);
      }
      // Regenerate Feedback Button
      const regenBtn = document.getElementById('rf-regenerate-btn');
      if (regenBtn) {
        regenBtn.addEventListener('click', async function() {
          if (!currentResumeId) {
            handleApiError(new Error('Please upload a resume first'));
            return;
          }

          const jobTitleInput = document.getElementById('rf-job-title');
          const jobTitle = jobTitleInput?.value?.trim() || '';
          const previousJobTitle = currentJobTitle || '';
          currentJobTitle = jobTitle; // Job title is optional, so empty is OK

          // Check if we need to regenerate (resume changed or role changed)
          // If nothing changed, skip API call to save tokens
          if (window.JobHackAIStatePersistence) {
            const cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
            if (cachedScore && cachedScore.resumeId === currentResumeId) {
              const cachedJobTitle = (cachedScore.jobTitle || '').trim();
              const newJobTitle = (jobTitle || '').trim();
              
              // If resume and role haven't changed, and cached tips are valid, don't call API
              const cachedTips = cachedScore.roleSpecificFeedback;
              if (cachedJobTitle === newJobTitle && isValidRoleTips(cachedTips)) {
                console.log('[RESUME-FEEDBACK] Resume and role unchanged, skipping API call');
                if (window.JobHackAIToast) {
                  window.JobHackAIToast.info('No changes detected. Feedback is already up to date.');
                }
                return;
              }
            }
          }

          try {
            showLoadingState('Regenerating feedback...');
            this.disabled = true;
            this.textContent = 'Regenerating...';
            setRoleStatus('Generating tips‚Ä¶');
            const roleChanged = previousJobTitle !== jobTitle;

            // Start ATS (if role changed) and feedback in parallel
            const atsPromise = roleChanged ? getAtsScore(currentResumeId, jobTitle) : Promise.resolve(null);
            const feedbackPromise = getResumeFeedback(currentResumeId, jobTitle);
            const [atsSettled, feedbackSettled] = await Promise.allSettled([atsPromise, feedbackPromise]);

            let scoreResult = null;
            let scoreUpdated = false;
            if (atsSettled.status === 'fulfilled' && atsSettled.value) {
              const possibleScore = atsSettled.value;
              if (possibleScore.success && possibleScore.score !== undefined && possibleScore.breakdown) {
                scoreResult = possibleScore;
                scoreUpdated = true;
                updateProgressRing(scoreResult.score);
                const rubric = [
                  {
                    label: 'Keyword Relevance',
                    score: scoreResult.breakdown.keywordScore?.score || 0,
                    max: 40,
                    tip: limitFeedbackToSentences(scoreResult.breakdown.keywordScore?.feedback || '')
                  },
                  {
                    label: 'Formatting Compliance',
                    score: scoreResult.breakdown.formattingScore?.score || 0,
                    max: 20,
                    tip: limitFeedbackToSentences(scoreResult.breakdown.formattingScore?.feedback || '')
                  },
                  {
                    label: 'Structure & Section Completeness',
                    score: scoreResult.breakdown.structureScore?.score || 0,
                    max: 15,
                    tip: limitFeedbackToSentences(scoreResult.breakdown.structureScore?.feedback || '')
                  },
                  {
                    label: 'Tone & Clarity',
                    score: scoreResult.breakdown.toneScore?.score || 0,
                    max: 15,
                    tip: limitFeedbackToSentences(scoreResult.breakdown.toneScore?.feedback || '')
                  },
                  {
                    label: 'Grammar & Spelling',
                    score: scoreResult.breakdown.grammarScore?.score || 0,
                    max: 10,
                    tip: limitFeedbackToSentences(scoreResult.breakdown.grammarScore?.feedback || '')
                  }
                ];
                updateRubricGrid(rubric);
                sessionStorage.setItem('currentAtsScore', scoreResult.score.toString());
                sessionStorage.setItem('currentAtsBreakdown', JSON.stringify(scoreResult.breakdown));
              } else {
                console.warn('[RESUME-FEEDBACK] ATS score update incomplete:', {
                  success: possibleScore?.success,
                  hasScore: possibleScore?.score !== undefined,
                  hasBreakdown: !!possibleScore?.breakdown
                });
              }
            } else if (atsSettled.status === 'rejected') {
              console.warn('[RESUME-FEEDBACK] Failed to update ATS score:', atsSettled.reason);
            }

            if (feedbackSettled.status !== 'fulfilled' || !feedbackSettled.value) {
              // Feedback failed - log but don't block (ATS score may be shown)
              const error = feedbackSettled.status === 'rejected' ? feedbackSettled.reason : new Error('No feedback result');
              console.warn('[RESUME-FEEDBACK] Feedback generation failed (non-blocking):', error);
              hideRoleFeedback();
              setRoleStatus('Couldn‚Äôt refresh tips‚Äîretry.');
              if (window.showErrorModal) {
                const errorMsg = error.message || 'Failed to generate feedback. Your ATS score is still available.';
                window.showErrorModal('Feedback Generation Failed', errorMsg, {
                  buttonText: 'OK',
                  onClose: () => {}
                });
              }
              this.textContent = 'Regenerate Feedback';
              this.disabled = false;
              hideLoadingState();
              return;
            }

            const feedbackResult = feedbackSettled.value;
            
            // Update history with new session (D1-backed)
            if (window.JobHackAIHistory && feedbackResult.sessionId) {
              window.JobHackAIHistory.addItem(feedbackResult.sessionId, feedbackResult.meta);
            }
            
            updateFeedbackGrid(feedbackResult.roleSpecificFeedback);
            updateRubricGridFromFeedback(feedbackResult.atsRubric);
            
            // CRITICAL: Ensure feedback content is visible after feedback is generated (Pro & Premium)
            const feedbackContentEl = document.getElementById('rf-feedback-content');
            const userPlanCheck = getCurrentUserPlan();
            if (feedbackContentEl && ['pro', 'premium'].includes(userPlanCheck)) {
              feedbackContentEl.style.display = 'block';
            }

            // Load cached score to check if ATS score exists (must be loaded before use)
            let cachedScore = null;
            if (window.JobHackAIStatePersistence) {
              cachedScore = window.JobHackAIStatePersistence.loadATSScore(null);
            }
            
            const hasAtsScore = !!(scoreResult?.success || cachedScore?.score);
            updateRoleTipsState({
              hasAtsScore,
              roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null
            });

            // Clear target role ONLY after a successful new analysis. History clicks must NOT change this input.
            const jobTitleInput = document.getElementById('rf-job-title');
            if (jobTitleInput) {
              jobTitleInput.value = '';
              currentJobTitle = '';
            }

            // Refresh Last analyzed from D1 (guarded to avoid ReferenceError)
            if (typeof fetchLatestFeedbackFromD1 === 'function') {
              fetchLatestFeedbackFromD1();
            }
            
            // Save role-specific feedback to persistence
            // Use cached score that was already loaded above
            // This allows updating feedback even when job title has changed
            if (window.JobHackAIStatePersistence) {
              // Use updated score if role changed, otherwise use cached score
              const finalScore = scoreResult?.success ? scoreResult.score : (cachedScore?.score || 0);
              const finalBreakdown = scoreResult?.success ? scoreResult.breakdown : (cachedScore?.breakdown || {});
              
              if (cachedScore && cachedScore.resumeId === currentResumeId) {
                // Merge feedback text from atsRubric into breakdown
                const updatedBreakdown = { ...finalBreakdown };
                if (feedbackResult.atsRubric && Array.isArray(feedbackResult.atsRubric)) {
                  feedbackResult.atsRubric.forEach(item => {
                    const category = (item.category || item.label || '').toLowerCase();
                    const feedback = item.feedback || item.tip || '';
                    
                    if (category.includes('keyword') && updatedBreakdown.keywordScore) {
                      updatedBreakdown.keywordScore.feedback = feedback;
                    } else if (category.includes('format') && updatedBreakdown.formattingScore) {
                      updatedBreakdown.formattingScore.feedback = feedback;
                    } else if ((category.includes('structure') || category.includes('section')) && updatedBreakdown.structureScore) {
                      updatedBreakdown.structureScore.feedback = feedback;
                    } else if ((category.includes('tone') || category.includes('clarity')) && updatedBreakdown.toneScore) {
                      updatedBreakdown.toneScore.feedback = feedback;
                    } else if ((category.includes('grammar') || category.includes('spelling')) && updatedBreakdown.grammarScore) {
                      updatedBreakdown.grammarScore.feedback = feedback;
                    }
                  });
                }
                
                // Update existing cached score with new job title, feedback, and updated breakdown
                window.JobHackAIStatePersistence.saveATSScore({
                  ...cachedScore,
                  score: finalScore,
                  breakdown: updatedBreakdown,
                  jobTitle: jobTitle || null,
                  roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null,
                  timestamp: Date.now() // Update timestamp
                });
              } else if (currentResumeId && feedbackResult.atsRubric) {
                // If no cached score exists, reconstruct breakdown from atsRubric to save feedback
                // This ensures feedback is always saved even if cache is missing
                const reconstructedBreakdown = {};
                let totalScore = 0;
                
                // Reconstruct breakdown from atsRubric and calculate total score
                // Use scoreResult.breakdown if available to ensure consistency with totalScore
                if (scoreResult?.success && scoreResult.score !== undefined && scoreResult.breakdown) {
                  // We have a valid score and breakdown from the API call (when role changed)
                  // Use breakdown from scoreResult to ensure scores match the total
                  totalScore = scoreResult.score;
                  
                  // Build breakdown from scoreResult.breakdown (consistent with totalScore)
                  reconstructedBreakdown.keywordScore = {
                    score: scoreResult.breakdown.keywordScore?.score || 0,
                    max: 40,
                    feedback: feedbackResult.atsRubric.find(item => 
                      (item.category || item.label || '').toLowerCase().includes('keyword')
                    )?.feedback || scoreResult.breakdown.keywordScore?.feedback || ''
                  };
                  reconstructedBreakdown.formattingScore = {
                    score: scoreResult.breakdown.formattingScore?.score || 0,
                    max: 20,
                    feedback: feedbackResult.atsRubric.find(item => 
                      (item.category || item.label || '').toLowerCase().includes('format')
                    )?.feedback || scoreResult.breakdown.formattingScore?.feedback || ''
                  };
                  reconstructedBreakdown.structureScore = {
                    score: scoreResult.breakdown.structureScore?.score || 0,
                    max: 15,
                    feedback: feedbackResult.atsRubric.find(item => 
                      (item.category || item.label || '').toLowerCase().includes('structure') || 
                      (item.category || item.label || '').toLowerCase().includes('section')
                    )?.feedback || scoreResult.breakdown.structureScore?.feedback || ''
                  };
                  reconstructedBreakdown.toneScore = {
                    score: scoreResult.breakdown.toneScore?.score || 0,
                    max: 15,
                    feedback: feedbackResult.atsRubric.find(item => 
                      (item.category || item.label || '').toLowerCase().includes('tone') || 
                      (item.category || item.label || '').toLowerCase().includes('clarity')
                    )?.feedback || scoreResult.breakdown.toneScore?.feedback || ''
                  };
                  reconstructedBreakdown.grammarScore = {
                    score: scoreResult.breakdown.grammarScore?.score || 0,
                    max: 10,
                    feedback: feedbackResult.atsRubric.find(item => 
                      (item.category || item.label || '').toLowerCase().includes('grammar') || 
                      (item.category || item.label || '').toLowerCase().includes('spelling')
                    )?.feedback || scoreResult.breakdown.grammarScore?.feedback || ''
                  };
                } else {
                  // No valid scoreResult.breakdown - use atsRubric for both scores and breakdown
                  feedbackResult.atsRubric.forEach(item => {
                    const category = (item.category || item.label || '').toLowerCase();
                    const score = item.score || 0;
                    const max = item.max || 0;
                    const feedback = item.feedback || item.tip || '';
                    
                    // Accumulate score from atsRubric items
                    totalScore += score;
                    
                    if (category.includes('keyword')) {
                      reconstructedBreakdown.keywordScore = { score, max: 40, feedback };
                    } else if (category.includes('format')) {
                      reconstructedBreakdown.formattingScore = { score, max: 20, feedback };
                    } else if (category.includes('structure') || category.includes('section')) {
                      reconstructedBreakdown.structureScore = { score, max: 15, feedback };
                    } else if (category.includes('tone') || category.includes('clarity')) {
                      reconstructedBreakdown.toneScore = { score, max: 15, feedback };
                    } else if (category.includes('grammar') || category.includes('spelling')) {
                      reconstructedBreakdown.grammarScore = { score, max: 10, feedback };
                    }
                  });
                }
                
                // Save with reconstructed data
                window.JobHackAIStatePersistence.saveATSScore({
                  score: totalScore,
                  breakdown: reconstructedBreakdown,
                  resumeId: currentResumeId,
                  jobTitle: jobTitle || null,
                  roleSpecificFeedback: feedbackResult.roleSpecificFeedback || null,
                  timestamp: Date.now()
                });
                console.log('[RESUME-FEEDBACK] Saved feedback with reconstructed breakdown');
              }
              
            }

            const toastStatus = toastForAtsAndTips({
              atsOk: scoreUpdated,
              tips: feedbackResult.roleSpecificFeedback
            });
            if (toastStatus === 'tips_ok' || toastStatus === 'tips_only') {
              setRoleStatus('Role-specific tips updated.');
            } else if (toastStatus === 'ats_only') {
              setRoleStatus('ATS score is ready. Role-specific tips are still loading‚Äîretry if needed.');
            } else if (toastStatus === 'missing') {
              setRoleStatus('Couldn‚Äôt refresh tips‚Äîretry.');
            }

            this.textContent = 'Regenerate Feedback';
            this.disabled = false;
            hideLoadingState();
          } catch (error) {
            handleApiError(error);
            this.textContent = 'Regenerate Feedback';
            this.disabled = false;
            hideLoadingState();
            setRoleStatus('Couldn‚Äôt refresh tips‚Äîretry.');
          }
        });
      }
      // Initial attachment of button listeners
      attachRewriteButtonListeners();
    });

    // Helper function to limit feedback to 1-2 sentences (accessible globally)
    function limitFeedbackToSentences(text, maxSentences = 2) {
      if (!text || typeof text !== 'string') return '';
      const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
      if (sentences.length === 0) return '';
      const result = sentences.slice(0, maxSentences).join('. ').trim();
      // Always ensure a period at the end if there's content
      return result + (result.endsWith('.') ? '' : '.');
    }
    
    // Map old field names to new labels
    const fieldNameToLabel = {
      'keywordScore': 'Keyword Relevance',
      'formattingScore': 'Formatting Compliance',
      'structureScore': 'Structure & Section Completeness',
      'toneScore': 'Tone & Clarity',
      'grammarScore': 'Grammar & Spelling'
    };
    
    const fieldNameToMax = {
      'keywordScore': 40,
      'formattingScore': 20,
      'structureScore': 15,
      'toneScore': 15,
      'grammarScore': 10
    };
    
    // Update rubric grid from API response
    function updateRubricGridFromFeedback(atsRubric) {
      if (!atsRubric || !Array.isArray(atsRubric)) return;
      
      const rubric = atsRubric.map(item => {
        // Try to get field name from category/label or infer from item structure
        let fieldName = null;
        const category = (item.category || item.label || '').toLowerCase();
        
        // Map common category names to field names
        if (category.includes('keyword')) fieldName = 'keywordScore';
        else if (category.includes('format')) fieldName = 'formattingScore';
        else if (category.includes('structure') || category.includes('section')) fieldName = 'structureScore';
        else if (category.includes('tone') || category.includes('clarity')) fieldName = 'toneScore';
        else if (category.includes('grammar') || category.includes('spelling')) fieldName = 'grammarScore';
        
        // Use mapped label or fall back to original
        const label = fieldName ? fieldNameToLabel[fieldName] : (item.category || item.label || '');
        const max = fieldName ? fieldNameToMax[fieldName] : (item.max || 100);
        const tip = limitFeedbackToSentences(item.feedback || item.tip || '');
        
        return {
          label: label,
          // Only use a numeric score when it‚Äôs explicitly provided
          score: (typeof item.score === 'number' ? item.score : null),
          max: max,
          tip: tip
        };
      });
      
      updateRubricGrid(rubric);
    }

    function updateProgressRing(score) {
      // Update SVG ring and text
      const svg = document.querySelector('#rf-ats-score-tile .rf-progress-ring svg');
      if (!svg) {
        console.warn('[RESUME-FEEDBACK] SVG not found for progress ring');
        return;
      }
      
      // FIX: Default to 0% if score is undefined or null (for new users)
      const hasResumeData = score !== undefined && score !== null;
      let displayScore = hasResumeData ? score : 0;
      if (!Number.isFinite(displayScore) || displayScore < 0 || displayScore > 100) {
        console.warn('[ATS-DONUT] Invalid score for donut', { score: displayScore });
        displayScore = 0;
      }
      
      // Always show progress ring (even at 0% for new users)
      const progressRing = document.querySelector('#rf-ats-score-tile .rf-progress-ring');
      if (progressRing) {
        progressRing.style.display = 'inline-block';
      }
      
      const circle = svg.querySelectorAll('circle')[1];
      if (!circle) {
        console.warn('[RESUME-FEEDBACK] Progress circle not found');
        return;
      }
      // FIX: Use displayScore instead of score to ensure 0% default works correctly
      const percent = Math.max(0, Math.min(100, displayScore));
      const radius = 36;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - (percent / 100) * circumference;
      
      // Ensure circle is visible and green (use direct color value for SVG compatibility)
      circle.setAttribute('stroke', '#00E676');
      circle.setAttribute('stroke-width', '8');
      circle.setAttribute('stroke-dasharray', String(circumference));
      circle.setAttribute('stroke-dashoffset', offset);
      circle.setAttribute('stroke-linecap', 'round');
      circle.setAttribute('fill', 'none');
      
      // Update text
      let text = svg.querySelector('text');
      if (!text) {
        text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '40');
        text.setAttribute('y', '48');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', '1.6rem');
        text.setAttribute('font-weight', '700');
        text.setAttribute('fill', '#1F2937');
        svg.appendChild(text);
      }
      text.textContent = percent + '%';
      
      console.log('[RESUME-FEEDBACK] Updated progress ring to', percent + '%');
    }

    // Helper function to escape HTML to prevent XSS (shared across functions)
    function escapeHtml(text) {
      if (typeof text !== 'string') return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function formatRewriteChangeSummary(summary) {
      if (!summary) return '';
      if (typeof summary === 'string') return summary;
      if (Array.isArray(summary)) return summary.join('\n');
      if (typeof summary === 'object') {
        const lines = [];
        if (Array.isArray(summary.atsFixes) && summary.atsFixes.length > 0) {
          lines.push('ATS fixes:');
          summary.atsFixes.forEach(item => lines.push(`- ${item}`));
        }
        if (Array.isArray(summary.roleFixes) && summary.roleFixes.length > 0) {
          lines.push('Role fixes:');
          summary.roleFixes.forEach(item => lines.push(`- ${item}`));
        }
        return lines.join('\n');
      }
      return String(summary);
    }

    function updateRubricGrid(rubric) {
      const grid = document.getElementById('rf-rubric-grid');
      if (!grid) return;
      grid.innerHTML = '';
      rubric.forEach(item => {
        const div = document.createElement('div');
        div.className = 'rf-rubric-item';
        // Use ‚Äî / ‚Äî for empty scores
        const scoreDisplay = (item.score === undefined || item.score === null) ? '‚Äî / ‚Äî' : `${item.score} / ${item.max}`;
        
        div.innerHTML = `
          <div class="rf-rubric-label">${escapeHtml(item.label)}</div>
          <div class="rf-rubric-score">${escapeHtml(scoreDisplay)}</div>
          <div style="color:var(--color-text-secondary);font-size:0.98rem;">${escapeHtml(item.tip || item.feedback || '')}</div>
        `;
        grid.appendChild(div);
      });
    }

    // Role-specific helpers (shared across generate, retry, regenerate, cached restore)
    function isValidRoleTips(roleSpecificFeedback) {
      if (!roleSpecificFeedback || typeof roleSpecificFeedback !== 'object') return false;
      // Legacy array format: treat non-empty array as valid
      if (Array.isArray(roleSpecificFeedback)) return roleSpecificFeedback.length > 0;
      // New format: object with sections array
      if (!Array.isArray(roleSpecificFeedback.sections)) return false;
      return roleSpecificFeedback.sections.length > 0;
    }

    function getRoleTipsStatus({ atsOk, tips }) {
      const validTips = isValidRoleTips(tips);
      if (validTips && atsOk) return 'tips_ok';
      if (validTips && !atsOk) return 'tips_only';
      if (!validTips && atsOk) return 'ats_only';
      return 'missing';
    }

    function toastForAtsAndTips({ atsOk, tips }) {
      const status = getRoleTipsStatus({ atsOk, tips });
      if (!window.JobHackAIToast) return status;
      if (status === 'tips_ok') {
        window.JobHackAIToast.success('ATS score and role-specific tips updated.');
      } else if (status === 'tips_only') {
        window.JobHackAIToast.success('Role-specific tips updated.');
      } else if (status === 'ats_only') {
        if (window.JobHackAIToast.info) {
          window.JobHackAIToast.info('ATS score is ready. Role-specific tips are still loading‚Äîretry if needed.');
        } else {
          window.JobHackAIToast.success('ATS score is ready. Role-specific tips are still loading‚Äîretry if needed.');
        }
      }
      return status;
    }

    function setRoleStatus(text) {
      const el = document.getElementById('rf-role-status');
      if (!el) return;
      if (text) {
        el.textContent = text;
        el.style.display = 'block';
      } else {
        el.textContent = '';
        el.style.display = 'none';
      }
    }

    function updateFeedbackGrid(roleSpecificFeedback) {
      const grid = document.getElementById('rf-feedback-grid');
      if (!grid) return;
      
      // Distinguish new vs legacy formats to avoid crashing on arrays
      const isOldStructure = roleSpecificFeedback && Array.isArray(roleSpecificFeedback) && roleSpecificFeedback.length > 0;
      const isNewStructure = !Array.isArray(roleSpecificFeedback) && isValidRoleTips(roleSpecificFeedback);
      if (isOldStructure) {
        console.warn('[RESUME-FEEDBACK] Using legacy roleSpecificFeedback array format');
      }
      
      // Update section title and subtitle if new structure
      const roleTitleEl = document.getElementById('rf-role-title');
      const roleTitleTextEl = document.getElementById('rf-role-title-text');
      const roleDescEl = document.getElementById('rf-role-desc');
      
      if (isNewStructure && roleTitleTextEl) {
        roleTitleTextEl.textContent = 'Role-Specific Tailoring Tips';
        if (roleDescEl) {
          const targetRoleUsed = roleSpecificFeedback.targetRoleUsed || 'general';
          if (targetRoleUsed !== 'general') {
            roleDescEl.textContent = `How to tune your resume for ${targetRoleUsed} roles.`;
          } else {
            roleDescEl.textContent = 'Tell us your target role and we‚Äôll tailor the advice to what hiring managers expect.';
          }
        }
      }
      
      grid.innerHTML = '';
      
      if (!isNewStructure && !isOldStructure) {
        // Show placeholder cards
        const placeholderCards = [
          { section: 'Header & Contact', placeholder: 'Your r√©sum√© feedback will appear here once analyzed.' },
          { section: 'Professional Summary', placeholder: 'We\'ll review your summary and tone for keyword alignment.' },
          { section: 'Experience', placeholder: 'Experience feedback coming after your first analysis.' },
          { section: 'Skills', placeholder: 'We\'ll score your technical and soft skills once you upload.' },
          { section: 'Education', placeholder: 'Education section feedback appears here after analysis.' }
        ];
        
        placeholderCards.forEach(item => {
          const div = document.createElement('div');
          div.className = 'rf-feedback-card';
          div.innerHTML = `
            <div class="rf-feedback-label">${item.section}</div>
            <div class="rf-feedback-tip" style="color: var(--color-text-muted); font-style: italic;">${item.placeholder}</div>
          `;
          grid.appendChild(div);
        });
        return;
      }
      
      // Handle NEW structure with fitLevel, diagnosis, tips, rewritePreview
      if (isNewStructure) {
        roleSpecificFeedback.sections.forEach(section => {
          const div = document.createElement('div');
          div.className = 'rf-feedback-card';
          
          // Fit level chip styling
          let fitChipClass = 'rf-fit-chip-tunable';
          let fitChipText = 'Good but Tunable';
          if (section.fitLevel === 'big_impact') {
            fitChipClass = 'rf-fit-chip-big-impact';
            fitChipText = 'Big Impact Opportunity';
          } else if (section.fitLevel === 'strong') {
            fitChipClass = 'rf-fit-chip-strong';
            fitChipText = 'Strong Match';
          }
          
          // Build tips list (escape HTML to prevent XSS)
          const tipsHtml = section.tips && Array.isArray(section.tips) && section.tips.length > 0
            ? section.tips.map(tip => `<li>${escapeHtml(tip)}</li>`).join('')
            : '<li>No high-impact changes detected for this section.</li>';
          
          div.innerHTML = `
            <div class="rf-feedback-label" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.75rem;">
              <span>${escapeHtml(section.section || 'Section')}</span>
              <span class="${fitChipClass}" style="padding:0.25rem 0.75rem;border-radius:12px;font-size:0.75rem;font-weight:600;">${escapeHtml(fitChipText)}</span>
            </div>
            <div class="rf-feedback-diagnosis" style="color:var(--color-text-main);margin-bottom:0.75rem;font-weight:500;">${escapeHtml(section.diagnosis || '')}</div>
            <div class="rf-feedback-tips" style="margin-bottom:0.75rem;">
              <ul style="margin:0;padding-left:1.25rem;color:var(--color-text-secondary);">
                ${tipsHtml}
              </ul>
            </div>
            <div class="rf-rewrite-preview" style="margin-top:0.75rem;padding-top:0.75rem;border-top:1px solid var(--color-divider);">
              <div style="font-size:0.75rem;font-weight:600;color:var(--color-text-muted);margin-bottom:0.5rem;text-transform:uppercase;letter-spacing:0.5px;">AI Rewrite Preview</div>
              <div style="color:var(--color-text-secondary);font-style:italic;font-size:0.9rem;line-height:1.5;">${escapeHtml(section.rewritePreview || 'Preview not available')}</div>
            </div>
          `;
          grid.appendChild(div);
        });
        return;
      }
      
      // Handle OLD structure (backwards compatibility)
      if (isOldStructure) {
        roleSpecificFeedback.forEach(item => {
          const div = document.createElement('div');
          div.className = 'rf-feedback-card';
          const scoreDisplay = (item.score === undefined || item.score === null) ? '‚Äî / ‚Äî' : escapeHtml(item.score);
          div.innerHTML = `
            <div class="rf-feedback-label">${escapeHtml(item.section || item.label || 'Section')} <span class="rf-feedback-score">${scoreDisplay}</span></div>
            <div class="rf-feedback-tip">${escapeHtml(item.feedback || item.tip || '')}</div>
          `;
          grid.appendChild(div);
        });
        return;
      }
    }
    
    // Track consecutive role-tip failures to adjust messaging
    let roleTipsFailureCount = 0;

    // Helper: control Role-Specific Tips state and retry button visibility
    function updateRoleTipsState({ hasAtsScore, roleSpecificFeedback }) {
      const roleContainer = document.getElementById('role-feedback-container');
      const feedbackGrid = document.getElementById('rf-feedback-grid');
      const regenBtn = document.getElementById('rf-regenerate-btn');
      const roleDescEl = document.getElementById('rf-role-desc');
      const roleInfoBar = document.getElementById('rf-role-info');
      let roleBadge = document.getElementById('rf-role-badge');
      let roleHelper = document.getElementById('rf-role-helper');
      const firstTryText = 'ATS score is ready. We couldn‚Äôt generate tailored tips for this role. Try again or adjust your target role.';
      const exhaustedText = 'No tailored tips available for this run. Consider adding role-specific details or trying another role.';

      if (roleDescEl && !roleDescEl.dataset.baseText) {
        roleDescEl.dataset.baseText = roleDescEl.textContent || '';
      }

      const rsf = roleSpecificFeedback;
      const isOldStructure = rsf && Array.isArray(rsf) && rsf.length > 0;
      const isNewStructure = !Array.isArray(rsf) && isValidRoleTips(rsf);
      if (isOldStructure) {
        console.warn('[RESUME-FEEDBACK] Using legacy roleSpecificFeedback array format');
      }
      const hasRoleSpecific = !!(isNewStructure || isOldStructure);
      const sectionCount = isNewStructure
        ? (rsf.sections || []).length
        : (isOldStructure ? rsf.length : 0);

      if (!roleContainer) return;

      // No ATS score ‚Äì hide section and button
      if (!hasAtsScore) {
        roleTipsFailureCount = 0;
        if (feedbackGrid) feedbackGrid.style.display = 'none';
        hideRoleFeedback();
        if (roleInfoBar) roleInfoBar.style.display = 'none';
        if (roleBadge) roleBadge.style.display = 'none';
        if (roleHelper) roleHelper.style.display = 'none';
        if (regenBtn) {
          regenBtn.style.display = 'none';
          regenBtn.textContent = 'Regenerate Feedback';
        }
        if (roleDescEl && roleDescEl.dataset.baseText) {
          roleDescEl.textContent = roleDescEl.dataset.baseText;
          // Clear any previous partial-error state when fully resetting
          delete roleDescEl.dataset.lastRoleState;
        }
        setRoleStatus('');
        return;
      }

      // Clean success: ATS + role-specific tips present
      if (hasRoleSpecific) {
        roleTipsFailureCount = 0;
        if (feedbackGrid) feedbackGrid.style.display = 'grid';
        showRoleFeedback();
        if (roleBadge) roleBadge.style.display = 'none';
        if (roleHelper) roleHelper.style.display = 'none';
        // Show info bar only when we have partial role tips (some sections but not all)
        if (roleInfoBar) {
          if (sectionCount > 0 && sectionCount < 5) {
            roleInfoBar.style.display = 'block';
            roleInfoBar.textContent = 'We generated tips for these sections. Add a few impact bullets to see the rest.';
          } else {
            roleInfoBar.style.display = 'none';
          }
        }
        // Hide badge/helper on success
        if (roleBadge) roleBadge.style.display = 'none';
        if (roleHelper) roleHelper.style.display = 'none';
        if (regenBtn) {
          regenBtn.style.display = 'none';
          regenBtn.textContent = 'Regenerate Feedback';
        }
        // Only restore baseText if current text matches baseText (no plan-specific text was set)
        // This prevents overwriting plan-specific descriptions set by updateRfTileForPlan
        if (roleDescEl && roleDescEl.dataset.baseText) {
          const currentText = roleDescEl.textContent || '';
          const baseText = roleDescEl.dataset.baseText || '';
          const lastState = roleDescEl.dataset.lastRoleState || '';
          const isPartialErrorState =
            lastState === 'partial-error' || currentText === firstTryText || currentText === exhaustedText;
          // Restore baseText if:
          // - we are recovering from a previous partial-error state, or
          // - current text matches baseText (no plan-specific text was set), or
          // - the element is effectively empty
          if (isPartialErrorState || currentText === baseText || !currentText.trim()) {
            roleDescEl.textContent = baseText;
          }
          if (isPartialErrorState) {
            delete roleDescEl.dataset.lastRoleState;
          }
        }
        setRoleStatus('Showing last saved tips.');
        return;
      }

      // Partial success: ATS present but role-specific tips missing/invalid
      roleTipsFailureCount += 1;
      if (feedbackGrid) feedbackGrid.style.display = 'none';
      roleContainer.style.display = 'block';
      if (roleInfoBar) roleInfoBar.style.display = 'none';
      if (roleDescEl) {
        const message = roleTipsFailureCount > 1 ? exhaustedText : firstTryText;
        roleDescEl.textContent = message;
        roleDescEl.dataset.lastRoleState = 'partial-error';
      }
      const statusMessage = roleTipsFailureCount > 1 ? exhaustedText : firstTryText;
      setRoleStatus(statusMessage);

      // Render a lightweight guidance badge + helper text (above tips area)
      roleBadge = document.getElementById('rf-role-badge');
      if (roleBadge) {
        roleBadge.style.display = 'inline-flex';
        roleBadge.style.marginBottom = '8px';
        roleBadge.textContent = 'Quick suggestions (ATS-based)';
      }
      roleHelper = document.getElementById('rf-role-helper');
      if (roleHelper) {
        roleHelper.style.display = 'block';
        roleHelper.style.marginBottom = '12px';
        roleHelper.textContent = roleTipsFailureCount > 1
          ? 'We couldn‚Äôt generate detailed tips this time. Try adding role-specific details or adjusting the target role, then retry.'
          : 'Here are quick suggestions from your ATS check. Add a metric and a tool you used for this role, then try again.';
      }

      if (regenBtn) {
        regenBtn.style.display = 'inline-flex';
        regenBtn.textContent = 'Try again for tailored tips';
        regenBtn.disabled = false;
      }
    }

    // Fade transition helpers
    function hidePlaceholder() {
      const ph = document.getElementById('ats-placeholder');
      if (ph) {
        ph.classList.add('fade-exit');
        setTimeout(() => ph.remove(), 250);
      }
    }
    
    function showATSFeedback() {
      const el = document.getElementById('ats-feedback-container');
      if (!el) return;
      // Clear animation classes first to ensure animation triggers on repeat runs
      el.classList.remove('fade-enter', 'fade-enter-active');
      // Force reflow to reset animation state
      void el.offsetWidth;
      // Re-apply animation classes
      el.style.display = 'block';
      el.classList.add('fade-enter');
      requestAnimationFrame(() => el.classList.add('fade-enter-active'));
    }
    
    function showRoleFeedback() {
      const el = document.getElementById('role-feedback-container');
      if (!el) return;
      // Clear animation classes first to ensure animation triggers on repeat runs
      el.classList.remove('fade-enter', 'fade-enter-active');
      // Force reflow to reset animation state
      void el.offsetWidth;
      // Re-apply animation classes
      el.style.display = 'block';
      el.classList.add('fade-enter');
      requestAnimationFrame(() => el.classList.add('fade-enter-active'));
    }

    function applyFadeIn(el) {
      if (!el) return;
      el.classList.remove('rf-fade-in');
      // Force reflow to restart animation if applied multiple times
      void el.offsetWidth;
      el.classList.add('rf-fade-in');
    }

    function hideRoleFeedback() {
      const el = document.getElementById('role-feedback-container');
      if (!el) return;
      el.style.display = 'none';
      el.classList.remove('fade-enter', 'fade-enter-active');
    }

    // Skeleton loading state management (performance-optimized, non-blocking)
    // Track timeout ID and pending Promise resolvers to handle concurrent calls
    let skeletonHideTimeout = null;
    let skeletonHideResolvers = []; // Array of pending Promise resolvers with generation IDs
    let skeletonOperationGeneration = 0; // Generation counter to invalidate stale operations
    
    function showSkeletons(willGetFeedback = true) {
      const skeletonContainer = document.getElementById('rf-skeleton-container');
      if (skeletonContainer) {
        // CRITICAL: Increment generation to invalidate any pending hide operations
        // This prevents stale Promise callbacks from executing when a new upload starts
        skeletonOperationGeneration++;
        
        // Cancel any pending hide timeout and resolve all pending Promises as cancelled
        if (skeletonHideTimeout !== null) {
          clearTimeout(skeletonHideTimeout);
          skeletonHideTimeout = null;
        }
        // Resolve all pending hide Promises with cancelled flag (operations are now stale)
        // This ensures Promises complete but callbacks will check and exit early
        skeletonHideResolvers.forEach(({ resolve, generation }) => {
          resolve({ generation, cancelled: true });
        });
        skeletonHideResolvers = [];
        
        skeletonContainer.style.display = 'block';
        
        // Remove hidden class from all skeletons (in case they were hidden previously)
        const skeletons = skeletonContainer.querySelectorAll('.rf-skeleton');
        skeletons.forEach(skeleton => {
          skeleton.classList.remove('hidden');
        });
        
        // Reset display properties of all skeleton elements for subsequent uses
        const skeletonHeader = document.getElementById('rf-skeleton-header');
        if (skeletonHeader) {
          skeletonHeader.style.display = 'block';
        }
        const skeletonRubric = document.getElementById('rf-skeleton-rubric');
        if (skeletonRubric) {
          skeletonRubric.style.display = 'grid';
        }
        const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
        if (skeletonFeedback) {
          // Only show feedback skeleton if user will receive feedback
          skeletonFeedback.style.display = willGetFeedback ? 'grid' : 'none';
        }
        // Ensure feedback content is visible so skeletons render; hide real grids
        const feedbackContent = document.getElementById('rf-feedback-content');
        if (feedbackContent) {
          feedbackContent.style.display = 'block';
          const rubricGrid = document.getElementById('rf-rubric-grid');
          const feedbackGrid = document.getElementById('rf-feedback-grid');
          if (rubricGrid) rubricGrid.style.display = 'none';
          if (feedbackGrid) feedbackGrid.style.display = 'none';
        }
      }
    }

    function hideSkeletons() {
      return new Promise((resolve) => {
        const skeletonContainer = document.getElementById('rf-skeleton-container');
        if (!skeletonContainer) {
          resolve({ generation: skeletonOperationGeneration, cancelled: false });
          return;
        }
        
        // Capture the current generation when this hide operation starts
        const operationGeneration = skeletonOperationGeneration;
        
        // If a hide operation is already in progress, queue this resolver
        // This prevents race conditions where concurrent calls cancel each other's timeouts
        if (skeletonHideTimeout !== null) {
          // Add this resolver to the queue with its generation ID
          skeletonHideResolvers.push({ resolve, generation: operationGeneration });
          return;
        }
        
        // Start new hide operation - initialize resolver array with this one
        skeletonHideResolvers = [{ resolve, generation: operationGeneration }];
        
        // Fade out skeletons smoothly
        const skeletons = skeletonContainer.querySelectorAll('.rf-skeleton');
        skeletons.forEach(skeleton => {
          skeleton.classList.add('hidden');
        });
        
        // Remove container after fade completes, then resolve all pending Promises
        skeletonHideTimeout = setTimeout(() => {
          skeletonContainer.style.display = 'none';
          // Remove hidden class for next use
          skeletons.forEach(skeleton => {
            skeleton.classList.remove('hidden');
          });
          
          // Resolve ALL pending Promises with their generation IDs
          // Callbacks will check if generation matches current before executing
          skeletonHideResolvers.forEach(({ resolve: resolver, generation }) => {
            resolver({ generation, cancelled: generation !== skeletonOperationGeneration });
          });
          skeletonHideResolvers = [];
          skeletonHideTimeout = null;
        }, 300);
      });
    }

    function hideHeaderSkeleton() {
      const skeletonHeader = document.getElementById('rf-skeleton-header');
      if (skeletonHeader) {
        skeletonHeader.style.display = 'none';
      }
    }

    function hideATSSkeleton() {
      const skeletonRubric = document.getElementById('rf-skeleton-rubric');
      if (skeletonRubric) {
        skeletonRubric.style.display = 'none';
      }
      const skeletonContainer = document.getElementById('rf-skeleton-container');
      const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
      if (skeletonContainer && skeletonFeedback && skeletonFeedback.style.display === 'none') {
        skeletonContainer.style.display = 'none';
      }
    }

    function hideFeedbackSkeleton() {
      const skeletonFeedback = document.getElementById('rf-skeleton-feedback');
      if (skeletonFeedback) {
        skeletonFeedback.style.display = 'none';
      }
      const skeletonContainer = document.getElementById('rf-skeleton-container');
      const skeletonRubric = document.getElementById('rf-skeleton-rubric');
      if (skeletonContainer && skeletonRubric && skeletonRubric.style.display === 'none') {
        skeletonContainer.style.display = 'none';
      }
    }

    // --- Priority Review Tooltip (modular) ---
    function createPriorityReviewTooltip(text = 'Priority Review') {
      const wrapper = document.createElement('span');
      wrapper.className = 'priority-review-tooltip';
      wrapper.innerHTML = `${text} <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:16px;height:16px;margin-left:4px;vertical-align:middle;color:var(--color-text-muted);"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg> <span class="tooltip-text">Premium users get their resume analyzed first‚Äîfaster results, prioritized AI review, and VIP support.</span>`;
      return wrapper;
    }
    
    // --- Priority Review CTA (modular) ---
    function renderPriorityReviewCTA() {
      const cta = document.createElement('div');
      cta.className = 'priority-review-cta premium-cta';
      cta.innerHTML = `<strong>Want your resume reviewed first?</strong> <span id="priority-review-inline"></span> <button class="priority-btn" onclick="window.location.href='pricing-a.html'">Upgrade to Premium</button>`;
      // Insert tooltip
      setTimeout(() => {
        const inline = cta.querySelector('#priority-review-inline');
        if (inline) inline.appendChild(createPriorityReviewTooltip('Upgrade to Premium for Priority Review'));
      }, 0);
      return cta;
    }
    
    // --- Premium Priority Review CTA (white background) ---
    function renderPremiumPriorityReviewCTA() {
      const cta = document.createElement('div');
      cta.className = 'priority-review-cta premium-cta';
      cta.innerHTML = `<strong>You're on Premium!</strong> <span id="priority-review-inline-premium"></span>`;
      // Insert tooltip
      setTimeout(() => {
        const inline = cta.querySelector('#priority-review-inline-premium');
        if (inline) inline.appendChild(createPriorityReviewTooltip('Priority Review included'));
      }, 0);
      return cta;
    }
    
    // --- Premium Priority Review note (no CTA) ---
    function renderPremiumPriorityReviewNote() {
      // Premium should not show any Priority Review messaging
      const existing = document.getElementById('priority-review-premium-note');
      if (existing) existing.remove();
      return;
    }
    
    // --- Insert Priority Review CTA / note below Resume Rewriting ---
    function updatePriorityReviewCTA() {
      // Remove any existing CTA (only show one Premium banner per page)
      const oldCta = document.getElementById('priority-review-cta-main');
      if (oldCta) oldCta.remove();
      
      const plan = getCurrentUserPlan();
      if (plan === 'essential' || plan === 'pro') {
        // Insert Priority Review CTA after Resume Rewriting tile
        const rewriteTile = document.getElementById('rf-rewrite-tile');
        if (rewriteTile && rewriteTile.parentNode) {
          const cta = renderPriorityReviewCTA();
          cta.id = 'priority-review-cta-main';
          rewriteTile.parentNode.insertBefore(cta, rewriteTile.nextSibling);
        }
      } else if (plan === 'premium') {
        // Insert Premium CTA with white background
        const rewriteTile = document.getElementById('rf-rewrite-tile');
        if (rewriteTile && rewriteTile.parentNode) {
          const cta = renderPremiumPriorityReviewCTA();
          cta.id = 'priority-review-cta-main';
          rewriteTile.parentNode.insertBefore(cta, rewriteTile.nextSibling);
        }
      }
    }

    // Display change summary from rewrite result
    function displayChangeSummary(changeSummary) {
      const summaryContainer = document.getElementById('rf-change-summary');
      if (!summaryContainer || !changeSummary) return;
      
      const atsFixes = changeSummary.atsFixes || [];
      const roleFixes = changeSummary.roleFixes || [];
      
      if (atsFixes.length === 0 && roleFixes.length === 0) {
        summaryContainer.style.display = 'none';
        return;
      }
      
      // Add the class to the container element itself (not a nested div)
      summaryContainer.className = 'rf-change-summary';
      
      // Only create the inner grid structure without redundant wrapper
      let summaryHtml = '<div class="rf-change-summary-grid">';
      
      
      if (atsFixes.length > 0) {
        summaryHtml += `
          <div>
            <h4>ATS Fixes</h4>
            <ul>
              ${atsFixes.map(fix => `<li>${escapeHtml(fix)}</li>`).join('')}
            </ul>
          </div>
        `;
      }
      
      if (roleFixes.length > 0) {
        summaryHtml += `
          <div>
            <h4>Role Tailoring</h4>
            <ul>
              ${roleFixes.map(fix => `<li>${escapeHtml(fix)}</li>`).join('')}
            </ul>
          </div>
        `;
      }
      
      summaryHtml += '</div>';
      summaryContainer.innerHTML = summaryHtml;
      summaryContainer.style.display = 'block';
    }

    // Hide details for Free plan
    function updateRfTileForPlan() {
      const atsScoreTile = document.getElementById('rf-ats-score-tile');
      const feedbackTile = document.getElementById('rf-feedback-tile');
      const rewriteTile = document.getElementById('rf-rewrite-tile');
      const feedbackContent = document.getElementById('rf-feedback-content');
      const rewriteContent = document.getElementById('rf-rewrite-content');
      const plan = getCurrentUserPlan();
      const roleDescEl = document.getElementById('rf-role-desc');
      
      // Helper function to safely set text content
      function safeSetText(element, text) {
        if (element) element.textContent = text;
      }
      
      // Helper function to safely set innerHTML
      function safeSetHTML(element, html) {
        if (element) element.innerHTML = html;
      }
      
      // Helper function to safely set style property
      function safeSetStyle(element, prop, value) {
        if (element && element.style) element.style[prop] = value;
      }
      
      // Helper function to safely query and set text
      function safeQueryText(parent, selector, text) {
        if (!parent) return null;
        const el = parent.querySelector(selector);
        if (el) el.textContent = text;
        return el;
      }
      
      // Helper function to safely query and set style
      function safeQueryStyle(parent, selector, prop, value) {
        if (!parent) return null;
        const el = parent.querySelector(selector);
        if (el && el.style) el.style[prop] = value;
        return el;
      }
      
      // Helper function to safely query and set HTML
      function safeQueryHTML(parent, selector, html) {
        if (!parent) return null;
        const el = parent.querySelector(selector);
        if (el) el.innerHTML = html;
        return el;
      }
      
      // Helper function to safely query an element (for passing to other functions)
      function safeQuerySelector(parent, selector) {
        if (!parent) return null;
        return parent.querySelector(selector);
      }
      
      // Cache base role description for later restores
      if (roleDescEl && !roleDescEl.dataset.baseText) {
        roleDescEl.dataset.baseText = roleDescEl.textContent || '';
      }

      // Clean up old upgrade banners
      const cleanupOldBanners = () => {
        const oldBanners = document.querySelectorAll('#rf-feedback-upgrade-banner, #rf-rewrite-upgrade-banner');
        oldBanners.forEach(banner => banner.remove());
      };

      // Reset all tiles to default state
      const resetTiles = () => {
        if (atsScoreTile) atsScoreTile.style.display = 'block';
        if (feedbackTile) feedbackTile.style.display = 'block';
        if (rewriteTile) rewriteTile.style.display = 'block';
        if (feedbackContent) feedbackContent.style.display = 'none';
        if (rewriteContent) rewriteContent.style.display = 'none';
        cleanupOldBanners();
      };

      resetTiles();

      // Helper function to update description with tooltip preserved
      function updateDescriptionWithTooltip(element, text, tooltipText) {
        if (!element) return;
        const tooltipHtml = `<span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.4em;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="8"/>
            <line x1="12" y1="12" x2="12" y2="16"/>
          </svg>
          <span class="rf-tooltip-text">${tooltipText}</span>
        </span>`;
        element.innerHTML = text + tooltipHtml;
      }

      // Free Plan Logic
      if (plan === 'free') {
        if (atsScoreTile) {
          safeQueryText(atsScoreTile, '#rf-plan-badge', 'Free Plan');
          updateDescriptionWithTooltip(
            safeQuerySelector(atsScoreTile, '#rf-score-desc'),
            'Get your basic ATS compatibility score.',
            'Receive an overall ATS compliance score (0-100) for your resume, highlighting key areas to improve for better job application success.'
          );
          // Check if free ATS score has been used
          const usageKey = `atsUsage:${getCurrentUserPlan()}:lifetime`;
          // For now, show message - will be updated dynamically after API call
          safeQueryText(atsScoreTile, '#rf-ats-checks', '1 free ATS score per account lifetime');
        }
        if (feedbackTile) {
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Locked');
          safeSetStyle(badge, 'background', '#E11D48');
          safeQueryText(feedbackTile, '.rf-upgrade-text strong', 'Start Free Trial');
          safeQueryHTML(feedbackTile, '.rf-upgrade-text', '<strong>Start Free Trial</strong> to unlock detailed ATS and role-specific feedback instantly.');
          // Add trial CTA button
          const upgradeButton = feedbackTile.querySelector('.rf-upgrade-prompt a');
          if (upgradeButton) {
            upgradeButton.textContent = 'Start Free Trial';
            upgradeButton.style.background = 'var(--color-accent-blue)';
            upgradeButton.style.color = '#fff';
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Pro Feature');
          safeSetStyle(badge, 'background', '#6B7280');
          safeQueryText(rewriteTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
          safeQueryHTML(rewriteTile, '.rf-upgrade-text', '<strong>Upgrade to Pro</strong> to unlock AI-powered resume rewriting with unlimited revisions');
        }
      }

      // Trial Plan Logic
      else if (plan === 'trial') {
        if (atsScoreTile) {
          const badge = atsScoreTile.querySelector('#rf-plan-badge');
          safeSetText(badge, 'Trial Plan');
          safeSetStyle(badge, 'background', '#FF9100');
          updateDescriptionWithTooltip(
            safeQuerySelector(atsScoreTile, '#rf-score-desc'),
            'Your trial includes 3 full ATS score & feedback runs.',
            'Each run combines ATS scoring with detailed feedback so you can see exactly what to fix before you apply.'
          );
          safeQueryText(atsScoreTile, '#rf-ats-checks', 'Max 3 feedback runs during your 3-day trial (rate limited to 1 per minute).');
        }
        // Trial feedback: 3 full runs total during trial
        if (feedbackTile) {
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Trial Plan');
          safeSetStyle(badge, 'background', '#FF9100');
          safeQueryStyle(feedbackTile, '.rf-upgrade-text', 'display', 'none');
          if (feedbackContent) {
            feedbackContent.style.display = 'block';
          }
          if (roleDescEl) {
            const planSpecificText = 'Basic feedback on your resume\'s content and presentation for your target role. Upgrade to Pro for deeper analysis and richer AI suggestions.';
            roleDescEl.textContent = planSpecificText;
            // Update baseText to plan-specific text so updateRoleTipsState restores the correct text
            roleDescEl.dataset.baseText = planSpecificText;
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Pro Feature');
          safeSetStyle(badge, 'background', '#6B7280');
          safeQueryText(rewriteTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
          safeQueryHTML(rewriteTile, '.rf-upgrade-text', '<strong>Trial shows you what to fix. Pro fixes it now (rewrites unlocked).</strong> Upgrade to Pro to complete your resume optimization.');
          // Add special upgrade CTA for trial users
          const upgradeButton = rewriteTile.querySelector('.rf-upgrade-prompt a');
          if (upgradeButton) {
            upgradeButton.textContent = 'Upgrade to Pro';
            // Use standard btn-secondary styling - ensure proper class and remove conflicting styles
            upgradeButton.className = 'btn btn-secondary';
            // Remove any inline styles and ensure proper styling
            upgradeButton.removeAttribute('style');
            // Force the correct colors to override any conflicting CSS
            upgradeButton.style.setProperty('background', '#1976D2', 'important');
            upgradeButton.style.setProperty('color', '#fff', 'important');
            upgradeButton.style.setProperty('border', 'none', 'important');
            
            // Add hover effect to match other buttons
            upgradeButton.addEventListener('mouseenter', function() {
              this.style.setProperty('background', '#125bb5', 'important');
            });
            upgradeButton.addEventListener('mouseleave', function() {
              this.style.setProperty('background', '#1976D2', 'important');
            });
          }
        }
      }

      // Essential Plan Logic
      else if (plan === 'essential') {
        if (atsScoreTile) {
          const badge = atsScoreTile.querySelector('#rf-plan-badge');
          safeSetText(badge, 'Essential Plan');
          safeSetStyle(badge, 'background', '#0077B5');
          updateDescriptionWithTooltip(
            safeQuerySelector(atsScoreTile, '#rf-score-desc'),
            'Receive an overall ATS compliance score for your resume, highlighting key areas to improve.',
            'Receive an overall ATS compliance score (0-100) for your resume, highlighting key areas to improve for better job application success.'
          );
          safeQueryText(atsScoreTile, '#rf-ats-checks', 'Unlimited ATS checks');
        }
        // Essential: 3 feedbacks/month
        if (feedbackTile) {
          // Check monthly usage (will be updated dynamically via API)
          const monthlyUsage = 0; // Will be fetched from /api/usage
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          if (monthlyUsage >= 3) {
            safeSetText(badge, 'Monthly Limit Reached');
            safeSetStyle(badge, 'background', '#6B7280');
            safeQueryText(feedbackTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
            safeQueryHTML(feedbackTile, '.rf-upgrade-text', '<strong>Upgrade to Pro</strong> for AI resume rewriting and higher feedback limits.');
          } else {
            safeSetText(badge, 'Essential Plan');
            safeSetStyle(badge, 'background', '#0077B5');
            safeQueryStyle(feedbackTile, '.rf-upgrade-text', 'display', 'none');
            if (feedbackContent) {
              feedbackContent.style.display = 'block';
            }
            // Ensure Essential feedback limit is clearly communicated
            let essentialNote = document.getElementById('rf-essential-feedback-note');
            if (!essentialNote) {
              essentialNote = document.createElement('div');
              essentialNote.id = 'rf-essential-feedback-note';
              essentialNote.style.marginTop = '0.5rem';
              essentialNote.style.color = 'var(--color-text-secondary)';
              essentialNote.style.fontSize = '0.9rem';
              essentialNote.textContent = 'Your Essential plan includes 3 feedback runs per month.';
              feedbackTile.insertBefore(essentialNote, feedbackContent);
            }
            if (roleDescEl) {
              const planSpecificText = 'Basic feedback on your resume\'s content and presentation for your target role. Upgrade to Pro for deeper analysis and richer AI suggestions.';
              roleDescEl.textContent = planSpecificText;
              // Update baseText to plan-specific text so updateRoleTipsState restores the correct text
              roleDescEl.dataset.baseText = planSpecificText;
            }
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, 'Pro Feature');
          safeSetStyle(badge, 'background', '#6B7280');
          safeQueryText(rewriteTile, '.rf-upgrade-text strong', 'Upgrade to Pro');
          safeQueryHTML(rewriteTile, '.rf-upgrade-text', '<strong>Trial shows you what to fix. Pro fixes it now (rewrites unlocked).</strong> Upgrade to Pro to complete your resume optimization.');
          // Add special upgrade CTA for essential users
          const upgradeButton = rewriteTile.querySelector('.rf-upgrade-prompt a');
          if (upgradeButton) {
            upgradeButton.textContent = 'Upgrade to Pro';
            // Use standard btn-secondary styling - ensure proper class and remove conflicting styles
            upgradeButton.className = 'btn btn-secondary';
            // Remove any inline styles and ensure proper styling
            upgradeButton.removeAttribute('style');
            // Force the correct colors to override any conflicting CSS
            upgradeButton.style.setProperty('background', '#1976D2', 'important');
            upgradeButton.style.setProperty('color', '#fff', 'important');
            upgradeButton.style.setProperty('border', 'none', 'important');
            
            // Add hover effect to match other buttons
            upgradeButton.addEventListener('mouseenter', function() {
              this.style.setProperty('background', '#125bb5', 'important');
            });
            upgradeButton.addEventListener('mouseleave', function() {
              this.style.setProperty('background', '#1976D2', 'important');
            });
          }
        }
      }

      // Pro & Premium Plan Logic
      else if (plan === 'pro' || plan === 'premium') {
        const isProPlan = plan === 'pro';
        const isPremiumPlan = plan === 'premium';
        const planLabel = plan.charAt(0).toUpperCase() + plan.slice(1) + ' Plan';
        const planColor = isProPlan ? '#388E3C' : '#C62828';
        
        if (atsScoreTile) {
          const badge = atsScoreTile.querySelector('#rf-plan-badge');
          safeSetText(badge, planLabel);
          safeSetStyle(badge, 'background', planColor);
          updateDescriptionWithTooltip(
            safeQuerySelector(atsScoreTile, '#rf-score-desc'),
            'Upload your resume once. Improve it step-by-step with ATS insights, role-specific feedback, and AI-powered rewrites!',
            'Receive an overall ATS compliance score (0-100) for your resume, highlighting key areas to improve for better job application success. Score as many resumes as you need with unlimited access.'
          );
          safeQueryHTML(atsScoreTile, '#rf-ats-checks', '');
        }
        if (feedbackTile) {
          const badge = feedbackTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, planLabel);
          safeSetStyle(badge, 'background', planColor);
          safeQueryStyle(feedbackTile, '.rf-upgrade-text', 'display', 'none');
          if (feedbackContent) {
            feedbackContent.style.display = 'block';
            // Premium CTA removed - already exists at bottom of page
          }
          if (roleDescEl) {
            const planSpecificText = 'See how your resume aligns with what hiring managers expect for your target role.';
            roleDescEl.textContent = planSpecificText;
            // Update baseText to plan-specific text so updateRoleTipsState restores the correct text
            roleDescEl.dataset.baseText = planSpecificText;
          }
        }
        if (rewriteTile) {
          const badge = rewriteTile.querySelector('.rf-title .rf-plan-badge');
          safeSetText(badge, planLabel);
          safeSetStyle(badge, 'background', planColor);
          // Update description text for Pro/Premium users
          const rewriteDesc = rewriteTile.querySelector('#rf-rewrite-desc');
          if (rewriteDesc) {
            const planName = isPremiumPlan ? 'Premium' : 'Pro';
            rewriteDesc.innerHTML = 'AI rewrites your resume line-by-line using this ATS feedback and your target role. <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.4em;"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="8"/><line x1="12" y1="12" x2="12" y2="16"/></svg><span class="rf-tooltip-text">See a rewritten version of your resume tailored to your target job - ready to copy and paste. Unlimited with your ' + planName + ' plan.</span></span>';
          }
          // Hide upgrade prompt and show content
          const upgradePrompt = rewriteTile.querySelector('.rf-upgrade-prompt');
          if (upgradePrompt) upgradePrompt.style.display = 'none';
          if (rewriteContent) {
            rewriteContent.style.display = 'block';
            // Re-attach button listeners when content is shown
            setTimeout(attachRewriteButtonListeners, 100);
            // Remove any Premium upgrade banner from rewrite tile (only show in feedback tile)
            const oldBanner = document.getElementById('rf-rewrite-upgrade-banner');
            if (oldBanner) oldBanner.remove();
          }
        }
      }
      // Always update Priority Review CTA
      updatePriorityReviewCTA();
    }

    // Add usage indicator using shared component
    document.addEventListener('DOMContentLoaded', async function() {
      const atsTile = document.getElementById('rf-ats-score-tile');
      const generateBtn = document.getElementById('rf-generate-btn');
      const currentPlan = getCurrentUserPlan();
      
      // Only show usage indicator for plans that have limits (essential, trial)
      if (atsTile && (currentPlan === 'essential' || currentPlan === 'trial')) {
        try {
          // Fetch usage data from API
          const token = localStorage.getItem('firebase-id-token');
          if (!token) {
            console.warn('[RESUME-FEEDBACK] No auth token available for usage fetch');
            return;
          }

          const usageResponse = await fetch('/api/usage', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            }
          });

          if (!usageResponse.ok) {
            console.warn('[RESUME-FEEDBACK] Failed to fetch usage data');
            return;
          }

          const usageData = await usageResponse.json();
          
          if (usageData.success && usageData.usage && usageData.usage.resumeFeedback) {
            const usage = usageData.usage.resumeFeedback;
            const plan = usageData.plan;

            // Create container for usage indicator
            const usageContainer = document.createElement('div');
            usageContainer.className = 'rf-plan-limit';
            usageContainer.style.cssText = 'margin-top: 0.75rem; margin-bottom: 0.25rem;';
            
            // Build plan-specific copy focused on feedback runs
            let customText = '';
            if (plan === 'trial') {
              customText = `${usage.used || 0} of ${usage.limit || 3} feedback runs used during your trial`;
            } else if (plan === 'essential') {
              customText = `${usage.used || 0} of ${usage.limit || 3} feedback runs used this month`;
            }

            // Render usage indicator using shared component
            if (window.renderUsageIndicator) {
              window.renderUsageIndicator({
                feature: 'resumeFeedback',
                usage,
                plan,
                container: usageContainer,
                customText
              });
              
              // Insert just under the main Generate ATS Score & Feedback button
              if (generateBtn && generateBtn.parentNode) {
                generateBtn.insertAdjacentElement('afterend', usageContainer);
              } else {
                atsTile.appendChild(usageContainer);
              }
            } else {
              console.warn('[RESUME-FEEDBACK] Usage indicator component not loaded');
            }
          }
        } catch (error) {
          console.error('[RESUME-FEEDBACK] Error loading usage indicator:', error);
        }
      }
    });

    // --- PLAN LOGIC ---
    // Update plan badges and unlock features based on user plan
    document.addEventListener('DOMContentLoaded', function() {
      const updatePlanUI = () => {
        const userPlan = getCurrentUserPlan();
        
        // Update all plan badges
        document.querySelectorAll('.rf-plan-badge').forEach(badge => {
          // Determine badge color based on plan
          let bgColor = 'var(--color-accent-blue)'; // Trial/Essential blue
          if (userPlan === 'pro') bgColor = '#388E3C'; // Pro green
          if (userPlan === 'premium') bgColor = '#C62828'; // Premium red
          if (userPlan === 'free') bgColor = '#6B7280'; // Free gray
          
          badge.style.background = bgColor;
          badge.textContent = userPlan.charAt(0).toUpperCase() + userPlan.slice(1) + ' Plan';
        });
        
        // Unlock ATS scoring and feedback for trial and above
        if (['trial', 'essential', 'pro', 'premium'].includes(userPlan)) {
          const atsSection = document.getElementById('ats-section');
          if (atsSection) atsSection.classList.remove('locked');
          
          // Show feedback content, hide upgrade prompts
          const feedbackContent = document.getElementById('rf-feedback-content');
          const feedbackUpgradePrompt = document.querySelector('#rf-feedback-tile .rf-upgrade-prompt');
          if (feedbackContent && ['pro', 'premium'].includes(userPlan)) {
            feedbackContent.style.display = 'block';
            console.log('[RESUME-FEEDBACK] Showing feedback content for plan:', userPlan);
          }
          if (feedbackUpgradePrompt) feedbackUpgradePrompt.style.display = 'none';
        }
        
        // Pro/Premium: Unlock resume rewriting
        if (['pro', 'premium'].includes(userPlan)) {
          const rewriteContent = document.getElementById('rf-rewrite-content');
          const rewriteUpgradePrompt = document.querySelector('#rf-rewrite-tile .rf-upgrade-prompt');
          const rewriteBadge = document.querySelector('#rf-rewrite-tile .rf-plan-badge');
          
          // Show rewrite content, hide upgrade prompt
          if (rewriteContent) {
            rewriteContent.style.display = 'block';
            console.log('[RESUME-FEEDBACK] Showing rewrite content for plan:', userPlan);
          }
          if (rewriteUpgradePrompt) rewriteUpgradePrompt.style.display = 'none';
          
          // Update rewrite badge
          if (rewriteBadge) {
            rewriteBadge.style.background = userPlan === 'premium' ? '#C62828' : '#388E3C';
            rewriteBadge.textContent = userPlan === 'premium' ? 'Premium' : 'Pro';
          }
        } else {
          // Non-Pro: Show upgrade prompt, hide rewrite content
          const rewriteContent = document.getElementById('rf-rewrite-content');
          const rewriteUpgradePrompt = document.querySelector('#rf-rewrite-tile .rf-upgrade-prompt');
          const rewriteBadge = document.querySelector('#rf-rewrite-tile .rf-plan-badge');
          
          if (rewriteContent) rewriteContent.style.display = 'none';
          if (rewriteUpgradePrompt) rewriteUpgradePrompt.style.display = 'flex';
          
          // Gray out rewrite badge
          if (rewriteBadge) {
            rewriteBadge.style.background = '#6B7280';
            rewriteBadge.textContent = 'Pro Only';
          }
        }
        
        // Update plan limit text
        updatePlanLimitText();
      };
      
      // Update on load
      updatePlanUI();
      
      // Listen for plan changes (cross-tab via localStorage)
      window.addEventListener('storage', function(e) {
        if (e.key === 'dev-plan' || e.key === 'user-plan') {
          updatePlanUI();
        }
      });
       
      // Listen for custom plan change events
      window.addEventListener('planChanged', function(e) {
        updatePlanUI();
      });
    });

    // =======================================================
    // RESUME FEEDBACK HISTORY (D1-backed)
    // Fetches and displays persistent feedback history from the server
    // =======================================================
    
    // In-memory history cache (source of truth is always the server)
    let _historyItems = [];
    
    /**
     * Normalize SQLite datetime format to ISO 8601 for Safari compatibility
     * SQLite returns dates as 'YYYY-MM-DD HH:MM:SS' (space-separated)
     * Safari requires ISO 8601 format 'YYYY-MM-DDTHH:MM:SSZ'
     */
    function normalizeDateForSafari(dateStr) {
      if (!dateStr || typeof dateStr !== 'string') return dateStr;
      
      // Check if it's SQLite format (YYYY-MM-DD HH:MM:SS)
      if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}/.test(dateStr)) {
        // Replace space with 'T' to make it ISO 8601 compliant
        let normalized = dateStr.replace(' ', 'T');
        // Add 'Z' if no timezone info is present (assume UTC)
        if (!normalized.includes('Z') && !normalized.includes('+') && !normalized.includes('-', 10)) {
          normalized += 'Z';
        }
        return normalized;
      }
      
      return dateStr; // Already in correct format or unrecognized
    }
    
    /**
     * Parse a date string with Safari compatibility
     * Returns a Date object or null if parsing fails
     */
    function parseDateSafely(dateStr) {
      if (!dateStr) return null;
      
      const normalized = normalizeDateForSafari(dateStr);
      const date = new Date(normalized);
      
      // Validate date is valid (Safari returns Invalid Date as NaN, not an error)
      if (isNaN(date.getTime())) {
        console.warn('[RESUME-FEEDBACK] Invalid date string:', dateStr);
        return null;
      }
      
      return date;
    }
    
    /**
     * Format a date string for display
     * Handles SQLite datetime format (YYYY-MM-DD HH:MM:SS) which Safari rejects
     * by normalizing to ISO 8601 format (YYYY-MM-DDTHH:MM:SS) before parsing
     */
    function formatHistoryDate(dateStr) {
      if (!dateStr) return '';
      
      const date = parseDateSafely(dateStr);
      if (!date) return dateStr; // Return original string if parsing fails
      
      try {
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        
        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins} min ago`;
        if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        
        return date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric',
          year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
        });
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Date formatting error:', e, 'for date:', dateStr);
        return dateStr;
      }
    }
    
    /**
     * Generate a display title for a history item
     */
    function getHistoryItemTitle(item) {
      if (item.title && item.title.trim()) {
        return item.title;
      }
      if (item.role && item.role.trim()) {
        return `${item.role} Resume`;
      }
      // Fallback to date-based title
      const date = parseDateSafely(item.createdAt);
      if (date) {
        return `Resume from ${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
      }
      return 'Resume Analysis';
    }
    
    /**
     * Render history items to the DOM
     */
    const HISTORY_PAGE_SIZE = 10;
    let _historyVisibleCount = HISTORY_PAGE_SIZE;
    
    function renderHistoryItems(items) {
      const listEl = document.getElementById('rf-history-list');
      const emptyEl = document.getElementById('rf-history-empty');
      const loadingEl = document.getElementById('rf-history-loading');
      const actionsEl = document.getElementById('rf-history-actions');
      const countEl = document.getElementById('rf-history-count');
      const showMoreBtn = document.getElementById('rf-history-show-more');
      const showLessBtn = document.getElementById('rf-history-show-less');
      
      if (!listEl) return;
      
      // Hide loading
      if (loadingEl) loadingEl.style.display = 'none';
      
      if (!items || items.length === 0) {
        listEl.style.display = 'none';
        if (emptyEl) emptyEl.style.display = 'block';
        if (actionsEl) actionsEl.style.display = 'none';
        return;
      }
      
      if (emptyEl) emptyEl.style.display = 'none';
      
      // Limit visible items to current page size
      const visibleItems = items.slice(0, _historyVisibleCount);
      
      // Build history list HTML with clickable items and atsScore
      listEl.innerHTML = visibleItems.map(item => `
        <div class="rf-history-item" data-session-id="${item.sessionId || ''}" title="Click to view this analysis">
          <div class="rf-history-icon">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
              <polyline points="14 2 14 8 20 8"/>
              <line x1="16" y1="13" x2="8" y2="13"/>
              <line x1="16" y1="17" x2="8" y2="17"/>
              <polyline points="10 9 9 9 8 9"/>
            </svg>
          </div>
          <div class="rf-history-details">
            <div class="rf-history-title">${escapeHtml(getHistoryItemTitle(item))}</div>
            <div class="rf-history-meta">
              ${item.role ? `<span style="margin-right:0.5rem;">üìå ${escapeHtml(item.role)}</span>` : ''}
              <span>üìÖ ${formatHistoryDate(item.createdAt)}</span>
            </div>
          </div>
          ${item.atsScore !== null && item.atsScore !== undefined ? `<div class="rf-history-score">${item.atsScore}</div>` : ''}
        </div>
      `).join('');
      
      listEl.style.display = 'flex';
      
      // Add click handlers for history items
      listEl.querySelectorAll('.rf-history-item').forEach(itemEl => {
        itemEl.addEventListener('click', function() {
          const sessionId = this.dataset.sessionId;
          if (sessionId) {
            loadHistoryDetail(sessionId);
          }
        });
      });
      
      // Show/hide actions (Show more / Show less)
      const hasMore = items.length > _historyVisibleCount;
      const canShowLess = _historyVisibleCount > HISTORY_PAGE_SIZE;
      
      if (actionsEl) actionsEl.style.display = (hasMore || canShowLess) ? 'flex' : 'none';
      if (countEl) countEl.textContent = `Showing ${Math.min(_historyVisibleCount, items.length)} of ${items.length}`;
      
      if (showMoreBtn) {
        showMoreBtn.style.display = hasMore ? 'inline-flex' : 'none';
        showMoreBtn.onclick = () => {
          _historyVisibleCount = Math.min(_historyVisibleCount + HISTORY_PAGE_SIZE, _historyItems.length);
          renderHistoryItems(_historyItems);
        };
      }
      
      if (showLessBtn) {
        showLessBtn.style.display = canShowLess ? 'inline-flex' : 'none';
        showLessBtn.onclick = () => {
          _historyVisibleCount = HISTORY_PAGE_SIZE;
          renderHistoryItems(_historyItems);
        };
      }
    }
    
    /**
     * Track if we're viewing historical feedback (D1-only view)
     */
    let _isHistoricalView = false;
    let _currentHistoricalSessionId = null;
    let _mode = 'new';
    let _selectedHistoryItem = null;

    function setMode(mode) {
      _mode = mode === 'saved' ? 'saved' : 'new';
      updateModeUI();
    }

    function updateModeUI() {
      const generateLabel = document.getElementById('rf-generate-label');
      const generateBtn = document.getElementById('rf-generate-btn');
      const fileInput = document.getElementById('rf-upload');
      const savedLine = document.getElementById('rf-saved-file-line');
      
      if (generateLabel) {
        generateLabel.textContent = _mode === 'saved'
          ? 'Re-run with new file'
          : 'Generate ATS Score & Feedback';
      }
      
      if (generateBtn) {
        const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
        if (_mode === 'saved' && !hasFile) {
          generateBtn.disabled = true;
        }
      }
      
      if (savedLine) {
        savedLine.style.display = _mode === 'saved' ? 'block' : 'none';
      }
    }

    function updateSavedFileLine(fileName) {
      const savedLine = document.getElementById('rf-saved-file-line');
      const savedName = document.getElementById('rf-saved-file-name');
      if (!savedLine || !savedName) return;
      savedName.textContent = fileName || '(file not stored)';
    }

    // Initialize mode UI on load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', updateModeUI);
    } else {
      updateModeUI();
    }
    
    /**
     * Load full feedback detail from D1 (NO OpenAI calls)
     * Restores the entire page state from saved data
     */
    async function loadHistoryDetail(sessionId) {
      console.log('[RESUME-FEEDBACK-HISTORY] Loading history detail:', sessionId);
      
      // Show loading state
      const loadingOverlay = document.getElementById('loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.style.display = 'flex';
        const loadingText = loadingOverlay.querySelector('.loading-text');
        if (loadingText) loadingText.textContent = 'Loading saved feedback...';
      }
      
      try {
        const token = await getAuthToken().catch(() => null);
        if (!token) {
          console.warn('[RESUME-FEEDBACK-HISTORY] No auth token for history detail');
          if (window.showToast) window.showToast('Please log in to view history', 'error');
          return;
        }
        
        const response = await fetch(`/api/resume-feedback/history/${sessionId}`, {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to load history (${response.status})`);
        }
        
        const data = await response.json();
        console.log('[RESUME-FEEDBACK-HISTORY] Loaded detail:', data);
      
      // Clear role state only after we have successfully loaded history data
      const clearFn = window.clearTargetRoleState || clearTargetRoleState;
      if (typeof clearFn === 'function') {
        clearFn();
      }
        
        // Mark as historical view
        _isHistoricalView = true;
        _currentHistoricalSessionId = sessionId;
        
        // Show historical banner
        showHistoricalBanner(data);
        
        // Restore page state from D1 data
        restorePageStateFromHistory(data);
        
        // Update mode/state for saved view
        _selectedHistoryItem = {
          sessionId,
          role: data.role || null,
          fileName: data.fileName || data.file_name || null,
          resumeId: data.resumeId || data.resume_id || null
        };
        updateSavedFileLine(_selectedHistoryItem.fileName);
        setMode('saved');
        
        // Clear file input; user must choose a new file to re-run
        const fileInput = document.getElementById('rf-upload');
        const fileNameSpan = document.getElementById('rf-file-name');
        const statusDiv = document.getElementById('rf-generate-status');
        const fileStatus = document.getElementById('rf-file-status');
        const pdfHelper = document.getElementById('rf-pdf-helper');
        if (fileInput) {
          fileInput.value = '';
        }
        if (fileNameSpan) {
          fileNameSpan.textContent = 'No file selected';
          fileNameSpan.style.color = 'var(--color-text-muted)';
          fileNameSpan.style.fontWeight = 'normal';
        }
        if (statusDiv) statusDiv.style.display = 'none';
        if (fileStatus) fileStatus.style.display = 'none';
        if (pdfHelper) pdfHelper.style.display = 'none';
        
        // Populate target role input for clarity
        const jobTitleInput = document.getElementById('rf-job-title');
        if (jobTitleInput && data.role) {
          jobTitleInput.value = data.role;
        }
        
        // Require a new file before re-running
        const generateBtn = document.getElementById('rf-generate-btn');
        if (generateBtn) {
          generateBtn.disabled = true;
        }
        
        // Mark active history item
        markActiveHistoryItem(sessionId);
        
        // Scroll to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
        
      } catch (error) {
        console.error('[RESUME-FEEDBACK-HISTORY] Error loading detail:', error);
        if (window.JobHackAIToast) {
          window.JobHackAIToast.error(error.message || 'Failed to load history');
        } else if (window.showToast) {
          window.showToast(error.message || 'Failed to load history', 'error');
        }
      } finally {
        if (loadingOverlay) loadingOverlay.style.display = 'none';
        forceHideOverlays();
      }
    }
    
    /**
     * Show the historical view banner
     */
    function showHistoricalBanner(data) {
      const banner = document.getElementById('rf-historical-banner');
      const bannerText = document.getElementById('rf-historical-banner-text');
      
      if (banner && bannerText) {
        // Format the date
        const date = parseDateSafely(data.createdAt);
        const dateStr = date ? date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric', 
          year: 'numeric' 
        }) : 'saved feedback';
        
        bannerText.textContent = `Viewing saved feedback from ${dateStr}${data.role ? ` for ${data.role}` : ''} ‚Äì run a new analysis to update.`;
        banner.style.display = 'flex';
      }
    }
    
    /**
     * Hide the historical view banner and clear state
     */
    function resetSession() {
      // Reset high-level state flags (UI only; never touches usage counters)
      _isHistoricalView = false;
      _currentHistoricalSessionId = null;
      _selectedHistoryItem = null;
      setMode('new');
      
      // Hide banner
      const banner = document.getElementById('rf-historical-banner');
      if (banner) banner.style.display = 'none';
      
      // Clear active history item
      document.querySelectorAll('.rf-history-item.active').forEach(el => el.classList.remove('active'));
      
      // Reset form and results
      resetFormToDefault();
      updateModeUI();
      
      // Reset saved filename line
      updateSavedFileLine('(file not stored)');
      
      // Clear rewrite text boxes to defaults
      const rewriteContent = document.getElementById('rf-rewrite-content');
      const rewriteTextareas = rewriteContent ? rewriteContent.querySelectorAll('.rf-snippet-box') : [];
      if (rewriteTextareas && rewriteTextareas.length >= 2) {
        rewriteTextareas[0].value = 'Original resume excerpt will appear here after upload.';
        rewriteTextareas[1].value = 'AI-optimized resume excerpt.';
      }

      // Clear rewrite change summary display
      const changeSummary = document.getElementById('rf-change-summary');
      if (changeSummary) {
        changeSummary.innerHTML = '';
        changeSummary.style.display = 'none';
      }
      
      // Clear in-memory resume state
      try {
        sessionStorage.removeItem('currentResumeText');
        sessionStorage.removeItem('currentResumeId');
        localStorage.removeItem('jh_last_resume_id');
      } catch (e) {
        console.warn('[RESUME-FEEDBACK] Failed to clear session state', e);
      }
    }
    
    function clearHistoricalView() {
      resetSession();
      
      // Scroll to upload section
      const uploadSection = document.getElementById('rf-ats-score-tile');
      if (uploadSection) uploadSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    
    /**
     * Mark the active history item in the sidebar
     */
    function markActiveHistoryItem(sessionId) {
      // Remove active from all items
      document.querySelectorAll('.rf-history-item.active').forEach(el => el.classList.remove('active'));
      
      // Add active to current
      const activeItem = document.querySelector(`.rf-history-item[data-session-id="${sessionId}"]`);
      if (activeItem) activeItem.classList.add('active');
    }
    
    /**
     * Reset form to default state
     */
    function resetFormToDefault() {
      // Reset file input
      const fileInput = document.getElementById('rf-upload');
      const fileName = document.getElementById('rf-file-name');
      const generateBtn = document.getElementById('rf-generate-btn');
      const statusDiv = document.getElementById('rf-generate-status');
      const fileStatus = document.getElementById('rf-file-status');
      const pdfHelper = document.getElementById('rf-pdf-helper');
      if (fileInput) fileInput.value = '';
      if (fileName) fileName.textContent = 'No file selected';
      if (generateBtn) generateBtn.disabled = true;
      if (statusDiv) statusDiv.style.display = 'none';
      if (fileStatus) fileStatus.style.display = 'none';
      if (pdfHelper) pdfHelper.style.display = 'none';
      clearTargetRoleState();
      const changeSummary = document.getElementById('rf-change-summary');
      if (changeSummary) {
        changeSummary.innerHTML = '';
        changeSummary.style.display = 'none';
      }
      
      // Reset score ring
      const svg = document.querySelector('#rf-ats-score-tile .rf-progress-ring svg');
      const scoreRing = svg ? svg.querySelectorAll('circle')[1] : null;
      const scoreText = svg ? svg.querySelector('text') : null;
      if (scoreRing) {
        scoreRing.style.strokeDashoffset = '';
        scoreRing.setAttribute('stroke-dashoffset', '226.2');
        scoreRing.setAttribute('stroke', '#00E676');
      }
      if (scoreText) scoreText.textContent = '0%';
      
      // Hide feedback sections
      const feedbackContent = document.getElementById('rf-feedback-content');
      const rubricGrid = document.getElementById('rf-rubric-grid');
      const feedbackGrid = document.getElementById('rf-feedback-grid');
      if (feedbackContent) feedbackContent.style.display = 'none';
      if (rubricGrid) rubricGrid.style.display = 'none';
      if (feedbackGrid) feedbackGrid.style.display = 'none';

      // Restore default score description and badge when exiting history
      if (typeof updateRfTileForPlan === 'function') {
        updateRfTileForPlan();
      } else {
        // Fallback: minimally reset score description while preserving tooltip
        const scoreDesc = document.getElementById('rf-score-desc');
        if (scoreDesc) {
          scoreDesc.innerHTML = 'Get your basic ATS compatibility score.';
        }
      }
    }
    
    /**
     * Restore full page state from history data (D1-only, NO OpenAI)
     */
    function restorePageStateFromHistory(data) {
      const atsRubric = data.atsRubric || data.feedback?.atsRubric || null;
      const roleSpecificFeedback = data.roleSpecificFeedback || data.feedback?.roleSpecificFeedback || null;
      const rewritten = data.rewrittenResume || data.feedback?.rewrittenResume || null;
      const rewriteSummary = data.rewriteChangeSummary || data.changeSummary || data.feedback?.rewriteChangeSummary || data.feedback?.changeSummary || null;
      const original = data.originalResume || data.feedback?.originalResume || null;

      // Historical views are fully loaded; hide any in-progress UI elements
      hideSkeletons();

      // Update ATS score ring using shared logic (clamps/guards inside)
      if (data.atsScore !== null && data.atsScore !== undefined) {
        updateProgressRing(data.atsScore);
        // Update score description
        const scoreDesc = document.getElementById('rf-score-desc');
        if (scoreDesc && data.role) {
          scoreDesc.innerHTML = `Your resume scored <strong>${data.atsScore}/100</strong> for ${escapeHtml(data.role)} roles.`;
        }
      }
      
      // Show and populate feedback content
      const feedbackContent = document.getElementById('rf-feedback-content');
      if (feedbackContent) feedbackContent.style.display = 'block';
      
      // Populate ATS rubric
      if (atsRubric && Array.isArray(atsRubric)) {
        populateAtsRubric(atsRubric);
      } else {
        const rubricGrid = document.getElementById('rf-rubric-grid');
        if (rubricGrid) rubricGrid.style.display = 'none';
      }
      
      // Populate role-specific feedback
      if (roleSpecificFeedback) {
        populateRoleSpecificFeedback(roleSpecificFeedback, data.role);
      } else {
        const roleContainer = document.getElementById('role-feedback-container');
        if (roleContainer) roleContainer.style.display = 'none';
      }
      
      updateRoleTipsState({
        hasAtsScore: typeof data.atsScore === 'number',
        roleSpecificFeedback: roleSpecificFeedback || null
      });
      
      // Update plan limit text based on current plan
      updatePlanLimitText();
      
      // Handle rewrite data based on plan gating
      const rewriteContent = document.getElementById('rf-rewrite-content');
      const rewritePrompt = document.querySelector('#rf-rewrite-tile .rf-upgrade-prompt');
      const rewrittenTextarea = rewriteContent ? rewriteContent.querySelectorAll('.rf-snippet-box')[1] : null;
      const originalTextarea = rewriteContent ? rewriteContent.querySelectorAll('.rf-snippet-box')[0] : null;

      if (data.rewriteLocked) {
        if (rewriteContent) rewriteContent.style.display = 'none';
        if (rewritePrompt) {
          rewritePrompt.style.display = 'block';
          const promptText = rewritePrompt.querySelector('.rf-upgrade-text');
          if (promptText) {
            promptText.innerHTML = 'AI resume rewrites are a Pro/Premium feature. Upgrade to unlock your detailed rewrites for this resume.';
          }
        }
        if (rewrittenTextarea) rewrittenTextarea.value = '';
        if (originalTextarea && originalTextarea.value) {
          // keep original text if present
        }
      } else {
        if (rewritePrompt) rewritePrompt.style.display = 'none';
        if (rewriteContent) rewriteContent.style.display = 'block';

        if (rewrittenTextarea) {
          if (rewritten) {
            rewrittenTextarea.value = rewritten;
          } else if (rewriteSummary) {
            const formattedSummary = formatRewriteChangeSummary(rewriteSummary);
            rewrittenTextarea.value = formattedSummary
              ? `Summary of changes:\n${formattedSummary}`
              : 'No rewrite available for this run yet.';
          } else {
            rewrittenTextarea.value = 'No rewrite available for this run yet.';
          }
        }
        
        // Also populate original snippet if available
        if (originalTextarea && original) {
          originalTextarea.value = original;
        }
      }

      // Always display change summary (ATS Fixes / Role Tailoring) when present
      displayChangeSummary(rewriteSummary || data.changeSummary || data.feedback?.rewriteChangeSummary || null);
    }
    
    /**
     * Populate ATS rubric grid from saved data
     */
    function populateAtsRubric(atsRubric) {
      const rubricGrid = document.getElementById('rf-rubric-grid');
      if (!rubricGrid) return;
      
      rubricGrid.innerHTML = atsRubric.map(item => `
        <div class="rf-rubric-item">
          <div class="rf-rubric-label">${escapeHtml(item.category || '')}</div>
          <div class="rf-rubric-score">${item.score || 0} / ${item.max || 10}</div>
          <div style="color:var(--color-text-secondary);font-size:0.95rem;margin-top:0.5rem;">${escapeHtml(item.feedback || '')}</div>
          ${item.suggestions && item.suggestions.length > 0 ? `
            <ul style="margin-top:0.5rem;padding-left:1.25rem;color:var(--color-text-muted);font-size:0.9rem;">
              ${item.suggestions.map(s => `<li>${escapeHtml(s)}</li>`).join('')}
            </ul>
          ` : ''}
        </div>
      `).join('');
      
      rubricGrid.style.display = 'grid';
      applyFadeIn(rubricGrid);
    }
    
    /**
     * Populate role-specific feedback from saved data
     */
    function populateRoleSpecificFeedback(roleSpecificFeedback, targetRole) {
      const feedbackGrid = document.getElementById('rf-feedback-grid');
      const roleTitle = document.getElementById('rf-role-title');
      const roleTitleText = document.getElementById('rf-role-title-text');
      const roleDesc = document.getElementById('rf-role-desc');
      
      if (!feedbackGrid) return;
      
      // Update title text without removing tooltip
      if (roleTitleText) {
        roleTitleText.textContent = 'Role-Specific Tailoring Tips';
      }
      if (roleDesc && targetRole) {
        roleDesc.textContent = `How to tune your resume for ${targetRole} roles.`;
      }
      
      // Handle both old array format and new object format
      const sections = roleSpecificFeedback.sections || (Array.isArray(roleSpecificFeedback) ? roleSpecificFeedback : []);
      
      if (sections.length === 0) {
        feedbackGrid.style.display = 'none';
        return;
      }
      
      feedbackGrid.innerHTML = sections.map(section => {
        const fitChipClass = {
          'big_impact': 'rf-fit-chip-big-impact',
          'tunable': 'rf-fit-chip-tunable',
          'strong': 'rf-fit-chip-strong'
        }[section.fitLevel] || 'rf-fit-chip-tunable';
        
        const fitLabel = {
          'big_impact': 'Big Impact Opportunity',
          'tunable': 'Good but Tunable',
          'strong': 'Strong Match'
        }[section.fitLevel] || 'Tunable';
        
        return `
          <div class="rf-feedback-card">
            <div class="rf-feedback-label" style="display:flex;justify-content:space-between;align-items:center;">
              <span>${escapeHtml(section.section || '')}</span>
              <span class="${fitChipClass}" style="padding:0.25rem 0.75rem;border-radius:12px;font-size:0.75rem;font-weight:600;">${fitLabel}</span>
            </div>
            <div style="color:var(--color-text-main);margin-bottom:0.75rem;font-weight:500;line-height:1.5;">
              ${escapeHtml(section.diagnosis || '')}
            </div>
            ${section.tips && section.tips.length > 0 ? `
              <ul style="margin:0 0 0.75rem 0;padding-left:1.25rem;color:var(--color-text-secondary);line-height:1.6;">
                ${section.tips.map(tip => `<li style="margin-bottom:0.5rem;">${escapeHtml(tip)}</li>`).join('')}
              </ul>
            ` : ''}
            ${section.rewritePreview ? `
              <div style="margin-top:0.75rem;padding-top:0.75rem;border-top:1px solid var(--color-divider);">
                <div style="font-size:0.75rem;font-weight:600;color:var(--color-text-muted);margin-bottom:0.5rem;text-transform:uppercase;letter-spacing:0.5px;">AI Rewrite Preview</div>
                <div style="color:var(--color-text-secondary);font-style:italic;font-size:0.9rem;line-height:1.5;">${escapeHtml(section.rewritePreview)}</div>
              </div>
            ` : ''}
          </div>
        `;
      }).join('');
      
      feedbackGrid.style.display = 'grid';
      applyFadeIn(feedbackGrid);
    }
    
    /**
     * Update plan limit text based on current plan
     */
    function updatePlanLimitText() {
      const planLimit = document.getElementById('rf-plan-limit');
      const userPlan = getCurrentUserPlan();
      
      if (!planLimit) return;
      
      const planMessages = {
        'trial': 'Your trial includes <strong>3 total detailed feedback runs</strong>. ATS scoring is always unlimited.',
        'essential': 'Your Essential plan includes <strong>3 detailed feedback runs per month</strong>. ATS scoring is always unlimited.',
        'pro': 'Your Pro plan includes <strong>unlimited detailed feedback runs</strong>.',
        'premium': 'Your Premium plan includes <strong>unlimited detailed feedback runs</strong> with priority processing.'
      };
      
      planLimit.innerHTML = `<span>${planMessages[userPlan] || planMessages['trial']}</span>`;
    }
    
    /**
     * Simple HTML escape helper
     */
    function escapeHtml(str) {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
    
    /**
     * Fetch history from the D1-backed API
     */
    async function fetchResumeFeedbackHistory() {
      const loadingEl = document.getElementById('rf-history-loading');
      const emptyEl = document.getElementById('rf-history-empty');
      const listEl = document.getElementById('rf-history-list');
      
      // Show loading state
      if (loadingEl) loadingEl.style.display = 'flex';
      if (emptyEl) emptyEl.style.display = 'none';
      if (listEl) listEl.style.display = 'none';
      
      try {
        const token = await getAuthToken().catch(() => null);
        if (!token) {
          console.warn('[RESUME-FEEDBACK-HISTORY] No auth token available');
          _historyItems = [];
          renderHistoryItems([]);
          return;
        }
        
        const response = await fetch('/api/resume-feedback/history?limit=20', {
          method: 'GET',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });
        
        if (!response.ok) {
          console.warn('[RESUME-FEEDBACK-HISTORY] API returned error:', response.status);
          _historyItems = [];
          renderHistoryItems([]);
          return;
        }
        
        const data = await response.json();
        _historyItems = data.items || [];
        _historyVisibleCount = HISTORY_PAGE_SIZE;
        
        console.log('[RESUME-FEEDBACK-HISTORY] Loaded history:', _historyItems.length, 'items');
        renderHistoryItems(_historyItems);
        
      } catch (error) {
        console.error('[RESUME-FEEDBACK-HISTORY] Error fetching history:', error);
        _historyItems = [];
        renderHistoryItems([]);
      }
    }
    
    /**
     * Add a new item to the top of the history list (optimistic update)
     * Called after a successful feedback run
     */
    function addHistoryItem(sessionId, meta) {
      if (!sessionId) return;
      
      // Skip if this session already exists in the current list
      const alreadyExists = _historyItems.some(item => item.sessionId === sessionId);
      if (alreadyExists) {
        console.log('[RESUME-FEEDBACK-HISTORY] Skipping duplicate history item:', sessionId);
        return;
      }
      
      const newItem = {
        sessionId: sessionId,
        title: meta?.title || null,
        role: meta?.role || null,
        createdAt: meta?.createdAt || new Date().toISOString(),
        hasFeedback: true
      };
      
      // Add to the front of the list
      _historyItems = [newItem, ..._historyItems];
      
      // Re-render
      renderHistoryItems(_historyItems);
      
      console.log('[RESUME-FEEDBACK-HISTORY] Added new item to history:', sessionId);
    }
    
    /**
     * Initialize history on page load
     */
    function initializeHistory() {
      // Only load history if user is authenticated
      const isAuthenticated = localStorage.getItem('user-authenticated') === 'true' && !!localStorage.getItem('user-email');
      if (!isAuthenticated) {
        console.log('[RESUME-FEEDBACK-HISTORY] Skipping history load - not authenticated');
        const loadingEl = document.getElementById('rf-history-loading');
        const emptyEl = document.getElementById('rf-history-empty');
        if (loadingEl) loadingEl.style.display = 'none';
        if (emptyEl) emptyEl.style.display = 'block';
        return;
      }
      
      // Load history from server
      fetchResumeFeedbackHistory();
      
      // Set up refresh button
      const refreshBtn = document.getElementById('rf-history-refresh');
      if (refreshBtn) {
        refreshBtn.addEventListener('click', function(e) {
          e.preventDefault();
          fetchResumeFeedbackHistory();
        });
      }
    }
    
    // Initialize history when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeHistory);
    } else {
      // DOM already loaded, init after a short delay to allow other scripts
      setTimeout(initializeHistory, 200);
    }
    
    // Expose history functions globally
    window.JobHackAIHistory = {
      addItem: addHistoryItem,
      refresh: fetchResumeFeedbackHistory,
      loadDetail: loadHistoryDetail,
      clearHistoricalView: clearHistoricalView,
      isHistoricalView: () => _isHistoricalView,
      getCurrentSessionId: () => _currentHistoricalSessionId
    };
  </script>
  <script src="js/components/usage-indicator.js" type="module"></script>
  <script src="js/main.js" type="module"></script>

  <!-- page content -->
  <main style="margin:2rem auto 4rem auto;padding:0 var(--space-md);">
    <div class="rf-layout-container">
      <!-- Main Column -->
      <div class="rf-main-column">
        <!-- Historical View Banner (hidden by default, shown when viewing history) -->
        <div class="rf-historical-banner" id="rf-historical-banner" style="display:none;">
          <div class="rf-historical-banner-text">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"/>
              <polyline points="12 6 12 12 16 14"/>
            </svg>
            <span id="rf-historical-banner-text">Viewing saved feedback from Jan 15, 2025</span>
          </div>
          <button class="btn-primary" id="rf-run-new-analysis-btn" onclick="window.JobHackAIHistory.clearHistoricalView()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
            </svg>
            Run New Analysis
          </button>
        </div>
        
        <!-- ATS Score Tile -->
    <section class="rf-card" id="rf-ats-score-tile">
      <div style="display:flex;align-items:center;gap:2.5rem;flex-wrap:wrap;">
        <div class="rf-progress-ring">
          <svg viewBox="0 0 80 80">
            <circle cx="40" cy="40" r="36" stroke="#E5E7EB" stroke-width="8" fill="none"/>
            <circle cx="40" cy="40" r="36" stroke="#00E676" stroke-width="8" fill="none" stroke-dasharray="226.2" stroke-dashoffset="226.2" stroke-linecap="round"/>
            <text x="40" y="48" text-anchor="middle" font-size="1.6rem" font-weight="700" fill="#1F2937">0%</text>
           </svg>
        </div>
        <div style="flex:1;min-width:220px;">
          <div class="rf-title" id="rf-title" style="margin-bottom:0.2rem;">
            Smart Resume Tools
            <span class="rf-plan-badge" id="rf-plan-badge">Free Plan</span>
          </div>
          <div style="color:var(--color-text-secondary);margin-bottom:0.7rem;" id="rf-score-desc">
            Get your basic ATS compatibility score.
            <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.4em;">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="8"/>
                <line x1="12" y1="12" x2="12" y2="16"/>
              </svg>
              <span class="rf-tooltip-text">Receive an overall ATS compliance score (0-100) for your resume, highlighting key areas to improve for better job application success.</span>
            </span>
          </div>
          <div class="rf-plan-limit" id="rf-plan-limit">
            <span id="rf-ats-checks">2 ATS checks remaining this month</span>
          </div>
          <form id="rf-upload-form" style="margin:1rem 0 0.7rem 0;">
            <label for="rf-job-title" style="font-weight:600;display:block;margin-bottom:0.5rem;">Target Role <span style="font-weight:400;color:var(--color-text-muted);font-size:0.9em;">(Recommended for better results)</span></label>
            <div style="position:relative;max-width:400px;margin-bottom:1rem;">
              <input 
                id="rf-job-title" 
                type="text" 
                placeholder="Start typing your target role (e.g., Software Engineer, Product Manager)" 
                class="rf-role-input"
                style="width:100%;padding:0.85rem 1.1rem;border:2px solid #E5E7EB;border-radius:10px;font-size:1.08rem;margin-bottom:0;transition:border 0.18s;background:#fff;color:#232B36;box-sizing:border-box;"
                role="combobox" 
                aria-autocomplete="list" 
                aria-expanded="false" 
                aria-controls="rf-role-list"
                autocomplete="off"
                value="">
              <div id="rf-role-list" class="rf-role-dropdown" role="listbox" style="display:none;position:absolute;left:0;right:0;background:#fff;border:1.5px solid #E5E7EB;border-top:none;border-radius:0 0 10px 10px;box-shadow:0 2px 8px rgba(31,41,55,0.07);z-index:10;max-height:220px;overflow-y:auto;margin-top:-2px;top:100%;"></div>
            </div>
            <div style="font-size:0.85rem;color:var(--color-text-muted);margin-bottom:1rem;line-height:1.4;">Adding a role helps us provide role-specific keyword suggestions, tailored feedback, and optimized resume rewriting.</div>
            <label for="rf-upload" style="font-weight:600;display:block;margin-bottom:0.5rem;">Resume File</label>
            <div id="rf-saved-file-line" style="display:none;font-size:0.9rem;color:var(--color-text-muted);margin-bottom:0.35rem;">
              Resume used in this run: <span id="rf-saved-file-name">(file not stored)</span>
            </div>
            <div style="display:flex;align-items:center;gap:0.75rem;flex-wrap:wrap;margin-bottom:0.5rem;">
              <label for="rf-upload" style="display:inline-flex;align-items:center;gap:0.5rem;padding:0.5rem 1rem;background:var(--color-card-bg);border:1px solid var(--color-divider);border-radius:var(--radius-md);font-size:0.875rem;font-weight:600;color:var(--color-text-main);cursor:pointer;transition:all 0.2s;">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                  <polyline points="17 8 12 3 7 8"></polyline>
                  <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
                Choose File
              </label>
              <span id="rf-file-name" style="font-size:0.875rem;color:var(--color-text-muted);">No file selected</span>
            </div>
            <div id="rf-file-status" class="rf-status-pill" style="display: none;">
              <span class="rf-status-icon"></span>
              <span class="rf-status-text"></span>
            </div>
            <div style="font-size:0.85rem;color:var(--color-text-muted);margin-bottom:0.75rem;line-height:1.4;">Supported formats: PDF, DOCX, or TXT. Maximum file size: 2 MB.</div>
            <div id="rf-pdf-helper" style="font-size: 0.85rem; color: var(--color-text-muted); margin-top: 0.5rem; line-height: 1.4; display: none;">
              PDF resumes may take around 10‚Äì15 seconds to fully analyze.
            </div>
            <input id="rf-upload" type="file" accept=".pdf,.docx,.txt,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document,text/plain" style="position:absolute;opacity:0;width:0;height:0;pointer-events:none;">
            <div id="rf-button-row" style="display:flex;align-items:center;gap:0.65rem;flex-wrap:wrap;margin-top:0.5rem;">
              <button
                type="button"
                id="rf-generate-btn"
                class="btn-primary"
                disabled
                tabindex="0"
                aria-label="Generate ATS Score and Feedback"
                style="min-height:44px;"
              >
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:0.35rem;">
                  <path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"/>
                </svg>
                <span id="rf-generate-label">Generate ATS Score &amp; Feedback</span>
              </button>
              <button type="button" id="rf-start-fresh-btn" class="rf-btn-ghost" style="min-height:44px;">
                Start Fresh
              </button>
            </div>
          </form>
        </div>
      </div>
    </section>

    <!-- ATS Score & Feedback Tile -->
    <section class="rf-card" id="rf-feedback-tile">
      <div class="rf-title">
        ATS Score & Feedback
        <span class="rf-plan-badge" style="background:#6B7280;">Locked</span>
      </div>
      <div style="color:var(--color-text-secondary);margin:0.25rem 0 1.2rem;">
        Run ATS Score &amp; Feedback to see your detailed breakdown here.
        <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.35em; vertical-align:middle;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false" style="width:18px; height:18px;">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="8"/>
            <line x1="12" y1="12" x2="12" y2="16"/>
          </svg>
          <span class="rf-tooltip-text">Get comprehensive feedback on keyword matching, formatting, structure, tone, and grammar to improve your resume's ATS compatibility.</span>
        </span>
      </div>
      <div class="rf-upgrade-prompt" style="display:none !important;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12h14"/>
        </svg>
        <div class="rf-upgrade-text">
          <strong>Upgrade to Essential or Pro</strong> to unlock detailed ATS and role-specific feedback.
        </div>
        <a href="pricing-a.html" class="btn btn-secondary">Upgrade Now</a>
      </div>
      <div id="rf-feedback-content" style="display:none;">
        <!-- Empty state placeholder -->
        <div id="ats-placeholder" class="ats-placeholder-note" style="display:none;">
        </div>
        <!-- ATS Rubric -->
        <div id="ats-feedback-container">
          <div class="rf-rubric-grid" id="rf-rubric-grid" style="display:none;">
          </div>
        </div>
        <!-- Role-Specific Feedback -->
        <div id="role-feedback-container">
          <div class="rf-section-title" id="rf-role-title" style="margin-top:3rem; display:flex; align-items:center; gap:0.5rem;">
            <span id="rf-role-title-text">Role-Specific Tailoring Tips</span>
            <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="8"/>
                <line x1="12" y1="12" x2="12" y2="16"/>
              </svg>
              <span class="rf-tooltip-text">Add projects, tools, and metrics to unlock all tailored sections.</span>
            </span>
          </div>
          <div style="color:var(--color-text-muted);margin-bottom:0.75rem;" id="rf-role-desc">
            Based on current expectations for your target role.
          </div>
          <div id="rf-role-status" style="color:var(--color-text-secondary);font-size:0.95rem;margin-bottom:0.75rem;display:none;"></div>
          <div id="rf-role-info" style="display:none; margin-bottom:1.2rem; padding:0.85rem 1rem; border:1px solid var(--color-divider); border-radius: var(--radius-button); background: rgba(0,123,255,0.06); color: var(--color-text-secondary);">
            We generated tips for these sections. Add a few impact bullets to see the rest.
          </div>
          <!-- Skeleton Loading States (shown during Step 2) -->
          <div id="rf-skeleton-container" style="display:none;">
            <!-- Progress header skeleton -->
            <div class="rf-skeleton rf-skeleton-header" id="rf-skeleton-header"></div>
            
            <!-- ATS Rubric skeleton - 5 cards matching grid layout -->
            <div class="rf-skeleton-rubric-grid" id="rf-skeleton-rubric">
              <div class="rf-skeleton rf-skeleton-rubric-card"></div>
              <div class="rf-skeleton rf-skeleton-rubric-card"></div>
              <div class="rf-skeleton rf-skeleton-rubric-card"></div>
              <div class="rf-skeleton rf-skeleton-rubric-card"></div>
              <div class="rf-skeleton rf-skeleton-rubric-card"></div>
            </div>
            
            <!-- Role-Specific Feedback skeleton - 3 cards -->
            <div class="rf-skeleton-feedback-grid" id="rf-skeleton-feedback" style="margin-top: 3rem;">
              <div class="rf-skeleton rf-skeleton-feedback-card"></div>
              <div class="rf-skeleton rf-skeleton-feedback-card"></div>
              <div class="rf-skeleton rf-skeleton-feedback-card"></div>
            </div>
          </div>
          <div class="rf-feedback-grid" id="rf-feedback-grid" style="display:none;">
          </div>
        <button class="btn btn-primary" id="rf-regenerate-btn" style="margin-top:1.7rem;display:none;">Regenerate Feedback</button>
        </div>
      </div>
    </section>

    <!-- Resume Rewriting Tile -->
    <a id="rewrite"></a>
    <section class="rf-card" id="rf-rewrite-tile">
      <div class="rf-title">
        Resume Rewriting
        <span class="rf-plan-badge" style="background:#6B7280;">Pro Only</span>
      </div>
      <div id="rf-rewrite-desc" style="color:var(--color-text-secondary);margin-bottom:1.2rem;">
        AI rewrites your resume line-by-line using this ATS feedback and your target role. Upgrade to Pro to unlock resume rewriting.
        <span class="rf-tooltip-trigger" tabindex="0" aria-label="More info" style="margin-left:0.4em;">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" focusable="false">
            <circle cx="12" cy="12" r="10"/>
            <line x1="12" y1="8" x2="12" y2="8"/>
            <line x1="12" y1="12" x2="12" y2="16"/>
          </svg>
          <span class="rf-tooltip-text">See a rewritten version of your resume tailored to your target job - ready to copy and paste. Unlimited with your Pro plan.</span>
        </span>
      </div>
      <div class="rf-upgrade-prompt">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 5v14M5 12h14"/>
        </svg>
        <div class="rf-upgrade-text">
          <strong>Upgrade to Pro</strong> to unlock resume rewriting powered by this ATS feedback and your target role.
        </div>
        <a href="pricing-a.html" class="btn btn-secondary">Upgrade Now</a>
      </div>
      <!-- Hidden content that will be shown for Pro/Premium plans -->
      <div id="rf-rewrite-content" style="display:none; padding: 0 1.5rem;">
        <div style="color:var(--color-text-secondary);margin-bottom:1.2rem;">
          Below is your fully optimized resume draft. We used ATS best-practice language, injected relevant keywords, and tightened formatting so it's ready to paste into your next application.
        </div>
        <div style="font-weight:600;margin-bottom:0.5rem;">Your Original Snippet</div>
        <textarea class="rf-snippet-box" readonly>Original resume excerpt will appear here after upload.</textarea>
        <div style="font-weight:600;margin-bottom:0.5rem;">Rewritten Snippet</div>
        <textarea class="rf-snippet-box" readonly>AI-optimized resume excerpt.</textarea>
        <div id="rf-change-summary" style="display:none;"></div>
        <div style="margin-top:1.2rem;">
          <button class="btn btn-primary">Copy Rewritten Resume</button>
          <button class="btn btn-secondary">Generate Rewrite</button>
          <div id="rf-rewrite-cooldown" style="margin-top:0.5rem;"></div>
        </div>
      </div>
    </section>
        
      </div><!-- /.rf-main-column -->

      <!-- Sidebar Column - Sticky History -->
      <aside class="rf-sidebar-column">
        <section class="rf-card" id="rf-history-tile" style="margin-bottom:0;">
          <div class="rf-title" style="display:flex;align-items:center;justify-content:space-between;font-size:var(--font-size-xl);">
            <span>
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:text-bottom;margin-right:0.5rem;">
                <circle cx="12" cy="12" r="10"/>
                <polyline points="12 6 12 12 16 14"/>
              </svg>
              Your Feedback History
            </span>
            <button id="rf-history-refresh" class="rf-btn-secondary" style="padding:0.4rem 0.75rem;font-size:0.85rem;" title="Refresh history">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M23 4v6h-6"/>
                <path d="M1 20v-6h6"/>
                <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
              </svg>
            </button>
          </div>
          <div style="color:var(--color-text-secondary);margin-bottom:1rem;font-size:0.95rem;">
            We automatically save your past feedback so you can come back and compare improvements.
          </div>
          <div id="rf-history-content">
            <!-- Loading state -->
            <div class="rf-history-loading" id="rf-history-loading">
              <div class="spinner"></div>
              <span>Loading history...</span>
            </div>
            <!-- History list (populated by JS) -->
            <div class="rf-history-list" id="rf-history-list" style="display:none;"></div>
            <!-- Empty state -->
            <div class="rf-history-empty" id="rf-history-empty" style="display:none;">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                <line x1="16" y1="2" x2="16" y2="6"/>
                <line x1="8" y1="2" x2="8" y2="6"/>
                <line x1="3" y1="10" x2="21" y2="10"/>
              </svg>
              <div style="font-weight:600;margin-bottom:0.25rem;">No history yet</div>
              <div>Upload a resume and run feedback to see your history here.</div>
            </div>
            <!-- Actions: show more/less -->
            <div class="rf-history-actions" id="rf-history-actions">
              <div class="rf-history-count" id="rf-history-count">Showing 0 of 0</div>
              <div style="display:flex;gap:0.4rem;align-items:center;flex-wrap:wrap;">
                <button class="rf-btn-secondary" id="rf-history-show-more" type="button">Show more</button>
                <button class="rf-btn-link" id="rf-history-show-less" type="button">Show less</button>
              </div>
            </div>
          </div>
        </section>
      </aside><!-- /.rf-sidebar-column -->
    </div><!-- /.rf-layout-container -->
  </main>

  <!-- Footer -->
  <footer class="site-footer" style="position:sticky;bottom:0;width:100%;background:var(--color-card-bg);">
    <div class="footer-container">
      <div class="footer-brand">
        <svg class="footer-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="7" width="18" height="13" rx="2" stroke="#1F2937" stroke-width="2"/>
          <path d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2" stroke="#1F2937" stroke-width="2"/>
        </svg>
        <span class="footer-name">JOBHACKAI</span>
      </div>
      <div class="footer-legal">
        <p>¬© 2025 JobHackAI. All rights reserved.</p>
      </div>
      <div class="footer-links">
        <a href="index.html">Home</a>
        <a href="support.html">Support</a>
        <a href="privacy.html">Privacy</a>
      </div>
    </div>
  </footer>
</body>
</html>
