<!-- DO NOT EDIT HEADER OR FOOTER PER-PAGE. Use canonical snippet from docs/snippets.md. -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>html.auth-pending{visibility:hidden}</style>
  <script src="js/static-auth-guard.js?v=20251007-2"></script>
  <script>
    // --- IMMEDIATE PAGE ACCESS CONTROL ---
    // Wait for Firebase auth to be ready before checking (prevents false negatives)
    (async function enforceAccessImmediate() {
      // Wait for Firebase auth manager to be ready (max 3 seconds)
      if (window.FirebaseAuthManager && window.FirebaseAuthManager.waitForAuthReady) {
        try {
          await window.FirebaseAuthManager.waitForAuthReady(3000);
        } catch (e) {
          console.warn('[INTERVIEW-Q] Auth ready timeout:', e);
        }
      }
      
      // Check auth state
      let isAuthenticated = false;
      let plan = 'free';
      
      if (window.FirebaseAuthManager && window.FirebaseAuthManager.getCurrentUser) {
        const user = window.FirebaseAuthManager.getCurrentUser();
        isAuthenticated = !!user;
        if (window.JobHackAINavigation) {
          plan = window.JobHackAINavigation.getEffectivePlan();
        } else {
          plan = localStorage.getItem('user-plan') || 'free';
        }
      } else {
        // Fallback to localStorage check
        const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
        const hasFirebaseKeys = Object.keys(localStorage).some(k => 
          k.startsWith('firebase:authUser:') && 
          localStorage.getItem(k) && 
          localStorage.getItem(k) !== 'null' &&
          localStorage.getItem(k).length > 10
        );
        isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
        plan = localStorage.getItem('user-plan') || 'free';
      }
      
      const allowedPlans = ['trial', 'essential', 'pro', 'premium'];
      
      // If not authenticated, redirect to login
      if (!isAuthenticated) {
        console.log('ðŸš« [INTERVIEW-Q] Not authenticated, redirecting to login');
        window.location.href = 'login.html';
        return;
      }
      
      // If authenticated but on wrong plan, redirect to pricing
      if (!allowedPlans.includes(plan)) {
        console.log('ðŸš« [INTERVIEW-Q] Access denied for plan:', plan);
        window.location.href = 'pricing-a.html?plan=essential';
        return;
      }
      
      // Access granted
      console.log('âœ… [INTERVIEW-Q] Access granted for plan:', plan);
    })();
  </script>
  <title>JobHackAI</title>
  <link rel="icon" type="image/png" href="assets/jobhackai_icon_only_128.png">
  <link rel="apple-touch-icon" href="assets/jobhackai_icon_only_128.png">
  <script src="js/dynamic-favicon.js?v=20250111-1"></script>
  <link rel="stylesheet" href="css/tokens.css">
  <link rel="stylesheet" href="css/main.css">
  <link rel="stylesheet" href="css/components.css">
  <link rel="stylesheet" href="css/header.css">
  <link rel="stylesheet" href="css/footer.css">
  <script src="js/custom-select.js?v=20251212-1" defer></script>
  <script src="js/components/usage-indicator.js"></script>
  <style>
    .iq-main {
      max-width: 1200px;
      margin: 2.5rem auto 4rem auto;
      padding: 0 1rem;
      width: 100%;
    }
    /* Canonical feature-tile pattern (matches resume-feedback-pro.html) */
    .rf-card {
      background: var(--color-card-bg, #fff);
      border-radius: var(--radius-xl, 16px);
      box-shadow: var(--shadow-card, 0 6px 24px rgba(0,0,0,0.08));
      padding: var(--space-lg, 1.5rem);
      margin-bottom: var(--space-lg, 1.5rem);
    }
    .rf-title {
      font-size: var(--font-size-2xl, 1.85rem);
      font-weight: var(--font-weight-extrabold, 800);
      margin-bottom: var(--space-xs, 0.35rem);
      color: var(--color-text-main, #1F2937);
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .rf-plan-badge {
      display: inline-block;
      /* Default to neutral so premium never shows blue if JS fails */
      background: var(--color-text-muted, #6B7280);
      color: #fff;
      font-weight: 600;
      border-radius: 999px;
      padding: 0.2em 0.8em;
      font-size: 0.9rem;
      margin-left: 0.1rem;
      vertical-align: middle;
      box-shadow: var(--shadow-sm);
    }
    .rf-plan-limit {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--color-text-secondary, #4B5563);
      font-size: 0.95rem;
      margin-top: 0.5rem;
    }
    /* IQ usage stack: allow multiple usage indicators inside the plan-limit row */
    #iq-usage-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      width: 100%;
    }
    .iq-role-input {
      width: 100%;
      padding: 0.85rem 1.1rem;
      border: 2px solid var(--color-divider, #E5E7EB);
      border-radius: var(--radius-button, 8px);
      font-size: 1.08rem;
      margin-bottom: 0;
      transition: border 0.18s;
      background: var(--color-card-bg, #fff);
      color: var(--color-text-main, #1F2937);
      box-sizing: border-box;
      height: 48px;
    }
    .iq-role-input:focus {
      border-color: var(--color-accent-blue, #007BFF);
      outline: none;
    }
    .iq-role-dropdown {
      position: absolute;
      left: 0; right: 0;
      background: var(--color-card-bg, #fff);
      border: 1.5px solid var(--color-divider, #E5E7EB);
      border-top: none;
      border-radius: 0 0 var(--radius-button, 8px) var(--radius-button, 8px);
      box-shadow: var(--shadow-md);
      z-index: var(--z-dropdown, 1000);
      max-height: 220px;
      overflow-y: auto;
      margin-top: -2px;
    }
    .iq-role-item {
      padding: 0.85rem 1.1rem;
      cursor: pointer;
      font-size: 1.08rem;
      color: var(--color-text-main, #1F2937);
      transition: background 0.15s;
    }
    .iq-role-item:hover, .iq-role-item.active {
      background: var(--color-bg-light, #F9FAFB);
    }
    .iq-questions {
      margin-bottom: 1.5rem;
    }
    .iq-question-card {
      background: var(--color-card-bg, #fff);
      border-radius: var(--radius-xl, 16px);
      box-shadow: var(--shadow-sm);
      padding: 1.1rem 1.3rem;
      margin-bottom: 1rem;
      font-size: 1.08rem;
      color: var(--color-text-main, #1F2937);
      line-height: 1.45;
    }
    .iq-lock {
      background: var(--color-card-bg, #fff);
      border: 1.5px solid var(--color-divider, #E5E7EB);
      border-radius: var(--radius-xl, 16px);
      padding: 1rem 1.25rem;
      display: flex;
      align-items: center;
      gap: 0.8rem;
      margin-top: 1.2rem;
      font-size: 1.04rem;
      color: var(--color-text-main, #1F2937);
      box-shadow: var(--shadow-sm);
    }
    .iq-upgrade-btn {
      display: block;
      width: 100%;
      margin: 1.7rem 0 0 0;
      background: var(--color-cta-green, #00E676);
      color: #fff;
      border: none;
      border-radius: var(--radius-button, 8px);
      font-size: 1.13rem;
      padding: 1rem 0;
      font-weight: var(--font-weight-bold, 700);
      cursor: pointer;
      transition: background 0.18s;
      text-align: center;
      box-shadow: var(--shadow-md);
      min-height: 48px;
    }
    .iq-upgrade-btn:hover,
    .iq-upgrade-btn:focus {
      background: var(--color-cta-green-hover, #00c965);
    }
    @media (max-width: 600px) {
      .iq-main { padding: 0 0.3rem; }
      .rf-title { font-size: var(--font-size-2xl, 1.5rem); }
      .iq-question-card { font-size: 1rem; padding: 1rem 0.7rem; }
      .iq-upgrade-btn { font-size: 1.01rem; padding: 0.8rem 0; }
    }
    /* ---- IQ MVP+ additions (append only) ---- */
    .card { background: var(--color-card-bg, #fff); border-radius: var(--radius-xl, 16px); box-shadow: var(--shadow-card); padding: 1rem; margin-bottom: 1rem; }
    .iq-toolbar .iq-row { display: flex; gap: 0.75rem; flex-wrap: wrap; align-items: center; }
    .iq-select, .chip, textarea#iq-jd { 
      border: 1.5px solid var(--color-divider, #E5E7EB); 
      border-radius: var(--radius-button, 8px); 
      padding: 0.6rem 0.8rem; 
      background: var(--color-card-bg, #fff); 
      box-sizing: border-box;
      color: var(--color-text-main, #1F2937);
    }
    .chip { cursor: pointer; user-select: none; transition: all 0.2s ease; }
    .chip.is-on { box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.15); background: rgba(0, 123, 255, 0.1); border-color: var(--color-accent-blue, #007BFF); }
    .chip:hover { border-color: #94A3B8; }
    .chip.is-on:hover { border-color: var(--color-accent-blue, #007BFF); }
    .chip-expand { background: var(--color-bg-light, #F8FAFC); border-color: #CBD5E1; color: var(--color-text-muted, #6B7280); font-weight: var(--font-weight-medium, 500); }
    .chip-expand:hover { background: #F1F5F9; border-color: #94A3B8; }
    .iq-actions { display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 0.75rem; }
    .rf-btn-ghost {
      background: transparent;
      color: #4B5563;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      padding: 0.65rem 1.1rem;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.18s ease;
      min-height: 44px;
      display: inline-flex;
      justify-content: center;
      align-items: center;
    }
    .rf-btn-ghost:hover {
      background: #F9FAFB;
      color: #374151;
      border-color: #D1D5DB;
    }
    .rf-btn-ghost:active {
      background: #F3F4F6;
      border-color: #9CA3AF;
    }
    .cooldown-badge { padding: 0.3rem 0.5rem; border-radius: var(--radius-md, 8px); border: 1px solid var(--color-divider, #E5E7EB); font-size: 0.9rem; color: var(--color-text-secondary, #4B5563); }
    .skeleton { height: 56px; border-radius: var(--radius-xl, 16px); background: linear-gradient(90deg, #f3f4f6 25%, #eceff3 37%, #f3f4f6 63%); background-size: 400% 100%; animation: sheen 1.2s ease-in-out infinite; }
    @keyframes sheen { 0%{background-position:100% 0} 100%{background-position:0 0} }
    .iq-qactions { 
      display:flex; 
      gap:.4rem; 
      opacity: 0.5;
      pointer-events:auto; 
      margin-bottom:.6rem;
      transition: opacity 0.15s ease;
    }
    .iq-question-card:hover .iq-qactions,
    .iq-question-card:focus-within .iq-qactions { 
      opacity: 1;
    }
    .iq-qactions .icon-btn { pointer-events:auto; position:relative; z-index:1; }
    .iq-replace-cooldown {
      margin-left: auto;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.15rem 0.4rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--color-accent-blue, #007BFF);
      background: rgba(0, 123, 255, 0.1);
      border-radius: var(--radius-sm, 4px);
      border: 1px solid rgba(0, 123, 255, 0.25);
    }
    .icon-btn { border: 1px solid var(--color-divider, #E5E7EB); background: var(--color-card-bg, #fff); border-radius: 8px; padding: 0.3rem 0.45rem; cursor: pointer; transition: opacity 0.15s ease; }
    .icon-btn:disabled { opacity: 0.4; cursor: not-allowed; }
    .link-btn { background: none; border: none; color: var(--color-accent-blue, #007BFF); cursor: pointer; text-decoration: underline; padding: 0 0.25rem; }
    .iq-example { margin: 0.5rem 0 0 0; color: var(--color-text-secondary, #4B5563); }
    .iq-types { display: flex; gap: 0.4rem; flex-wrap: wrap; }
    .recent-item { width: 100%; text-align: left; padding: 0.6rem 0.7rem; border: 1.5px solid var(--color-divider, #E5E7EB); border-radius: var(--radius-button, 8px); background: var(--color-card-bg, #fff); cursor: pointer; }
    .ri-role { font-weight: 600; }
    .ri-meta { color: var(--color-text-muted, #6B7280); font-size: 0.9rem; }
    .cta-hint { flex-basis: 100%; font-size: 0.9rem; color: var(--color-text-muted, #6B7280); margin-top: 0.25rem; }
    .iq-global-cooldown {
      display:inline-flex;
      flex-direction:column;
      gap:0.2rem;
      width: fit-content;
    }
    .iq-global-cooldown-chip {
      display:inline-flex;
      align-items:center;
      gap:0.35rem;
      padding:0.3rem 0.75rem;
      border-radius:999px;
      background: rgba(0, 123, 255, 0.1);
      border: 1px solid rgba(0, 123, 255, 0.25);
      color: var(--color-accent-blue, #007BFF);
      font-weight:600;
      font-size:0.87rem;
    }
    .iq-global-cooldown-chip svg {
      flex-shrink:0;
    }
    .btn-save svg { fill:none; stroke:#6B7280; stroke-width:1.5; }
    /* Stronger selectors to beat any theme overrides */
    .iq-qactions .btn-save[aria-pressed="true"] svg,
    .iq-qactions .btn-save.is-saved svg { fill:var(--color-accent-blue, #007BFF); stroke:var(--color-accent-blue, #007BFF); }
    /* Highlight question card when starred */
    .iq-question-card:has(.btn-save[aria-pressed="true"]) { background:rgba(0, 123, 255, 0.05); border-color:rgba(0, 123, 255, 0.2); }
    .saved-remove { padding:.2rem .5rem; font-size:.8rem; }
    .recent-item.is-active { border-color:var(--color-accent-blue, #007BFF); box-shadow:0 0 0 2px rgba(0, 123, 255, 0.15); background:rgba(0, 123, 255, 0.05); }

    /* Fixed question count display (hardcoded 10) */
    .iq-count-display { padding:.6rem .8rem; color:#4B5563; font-size:.9rem; background:#F9FAFB; border:1px solid #E5E7EB; border-radius:var(--radius-md, 8px); }

    /* Accessibility utility */
    .sr-only { position:absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    /* --- Visual polish & overrides --- */
    .iq-main { padding-bottom: 16px; }
    .card { border-radius:var(--radius-xl, 16px); padding:1.25rem; }
    .iq-select, .chip, textarea#iq-jd { border-radius:var(--radius-button, 8px); }
    .chip { border:1px solid #E5E7EB; padding:.5rem .75rem; line-height:1; background:#fff; min-height:36px; }
    .chip:hover { box-shadow:0 0 0 2px rgba(25,118,210,.10); }
    .chip:focus-visible { outline:none; box-shadow:0 0 0 2px rgba(25,118,210,.12); }
    .chip.is-on { border-color:#E5E7EB; box-shadow:0 0 0 2px rgba(25,118,210,.12); background:#fff; }
    .iq-toolbar .iq-row { 
      gap:2rem; 
      align-items:flex-start; 
      flex-wrap:wrap; 
      margin-bottom:1rem;
    }
    .iq-toolbar .iq-field { 
      flex:1 1 300px; 
      min-width:280px; 
      position:relative; 
      z-index:0; 
      margin-right:0;
    }
    .iq-toolbar .iq-row > div:nth-child(2) { 
      flex:0 0 140px; 
      min-width:140px; 
      margin-right:0;
    }
    .iq-types { 
      flex:1 1 400px; 
      min-width:550px; 
      display:flex; 
      flex-wrap:wrap; 
      gap:0.5rem; 
      margin-right:0;
    }
    .iq-toolbar .iq-row > div:last-child { 
      flex:0 0 80px; 
      min-width:80px; 
      margin-right:0;
    }
    .iq-advanced { margin:.75rem 0 1rem 0; }
    .iq-advanced summary { cursor:pointer; padding:.25rem 0; }
    .iq-advanced[open] #iq-jd { margin-top:.5rem; }
    #iq-jd { width:100%; border:1.5px solid #E5E7EB; border-radius:var(--radius-button, 8px); padding:.75rem .9rem; font-family:var(--font-family-base, 'Inter', sans-serif); font-size:var(--font-size-base, 1rem); }
    .iq-toolbar .iq-field .iq-role-input { margin-bottom:0; }
    .iq-toolbar .iq-row > div { 
      margin-bottom: 0; 
      padding-right: 0; 
      overflow: visible;
    }
    .iq-toolbar .iq-row > div:not(:last-child) { 
      margin-right: 0; 
    }
    .btn-outline { border: 1px solid var(--color-divider, #E5E7EB); background: var(--color-card-bg, #fff); box-shadow: none; color: var(--color-text-main, #1F2937); font-weight: 600; border-radius: var(--radius-button, 8px); padding: 0.6rem 1rem; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 0.4rem; min-height: 48px; }
    .btn-outline:hover, .btn-outline:focus-visible { background: var(--color-bg-light, #F9FAFB); border-color: #D1D5DB; }
    .btn-outline.is-pressed { background: var(--color-bg-light, #F3F4F6); }
    .btn-primary[disabled], .btn-outline[disabled] { opacity:.5; cursor:not-allowed; pointer-events:none; }
    .iq-question-card { border:1px solid #E5E7EB; box-shadow:0 1px 4px rgba(31,41,55,.05); border-radius:var(--radius-xl, 16px); padding:1.1rem 1.2rem; }
    .lock { 
      vertical-align: middle; 
      display: inline-flex;
      align-items: center;
      margin-left: 0.35rem;
    }
    .lock svg {
      color: #4B5563;
    }

    /* Question Type chips: clearer selected/focus states */
    .iq-types .chip { transition: background-color .15s ease, border-color .15s ease, color .15s ease; }
    .iq-types .chip.is-on { background:#E8F1FF; border-color:#93C5FD; color:#1D4ED8; box-shadow:0 0 0 2px rgba(29,78,216,.18) inset; }
    .iq-types .chip:focus-visible { box-shadow:0 0 0 2px rgba(25,118,210,.30); }

    /* Question Type segmented control (match Resume Rewrite "Generate Rewrite" UX standard) */
    .iq-segmented {
      display: flex;
      gap: 0.6rem;
      flex-wrap: nowrap;
      align-items: center;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 123, 255, 0.3) transparent;
    }
    .iq-segmented::-webkit-scrollbar {
      height: 4px;
    }
    .iq-segmented::-webkit-scrollbar-track {
      background: transparent;
    }
    .iq-segmented::-webkit-scrollbar-thumb {
      background: rgba(0, 123, 255, 0.3);
      border-radius: 2px;
    }
    .iq-segmented::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 123, 255, 0.5);
    }
    .iq-segment {
      background: #fff;
      color: #007BFF;
      font-weight: 700;
      border: 2px solid #007BFF;
      border-radius: 12px;
      padding: 0.7rem 1.25rem;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      transition: background 0.18s, color 0.18s, box-shadow 0.18s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: 44px;
      flex-shrink: 0;
      white-space: nowrap;
    }
    .iq-segment:hover {
      background: #F0F8FF;
      color: #0056b3;
      box-shadow: 0 4px 16px rgba(0,123,255,0.10);
    }
    .iq-segment.active {
      background: #F0F8FF;
      color: #0056b3;
      box-shadow: 0 4px 16px rgba(0,123,255,0.10);
    }
    .iq-segment:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
    }

    /* Actions layout and cooldown badge text */
    .iq-actions { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; }
    .iq-actions-sec { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin-top:.5rem; }
    /* Add explanatory text before the countdown when visible */
    #cooldown:not([hidden])::before {
      content: 'Next set in ';
      color: #4B5563;
      margin-right: .35rem;
    }

    /* Consistent icon styling for per-question actions (match pricing icons) */
    .icon-btn svg { width:20px; height:20px; stroke:#1F2937; stroke-width:2.25; stroke-linecap:round; stroke-linejoin:round; fill:none; }
    .icon-btn { display:inline-flex; align-items:center; justify-content:center; }

    /* Two-column responsive layout for top section + history */
    .iq-top-grid { display:grid; grid-template-columns: minmax(0,1fr) 380px; gap:2rem; align-items:start; margin-bottom:1.5rem; }
    .iq-top-grid aside.card { 
      position:sticky; 
      top:8px; 
    }
    @media (max-width: 900px) { .iq-top-grid { grid-template-columns: 1fr; } .iq-top-grid aside.card { position:static; max-height:none; } }
    .iq-questions-section { margin-top: 1.5rem; margin-bottom: 1.5rem; }
    @media (max-width: 600px) { 
      .iq-main { padding: 0 .75rem 120px .75rem; } 
      .iq-toolbar .iq-row { align-items: stretch; gap: 1rem; } 
      .iq-field { min-width:100%; } 
      .iq-toolbar .iq-row > div:nth-child(2) { min-width:48%; } 
      .iq-types { gap:.6rem .6rem; min-width:100%; } 
      .iq-qactions { opacity: 1; } 
      .iq-actions .btn-primary, .iq-actions .btn-outline { min-height:44px; width:auto; } 
      /* Allow horizontal scroll for segmented control on mobile */
      .iq-segmented { padding-bottom: 0.25rem; }
      .iq-segment { padding: 0.6rem 1rem; font-size: 0.95rem; }
    }
    @media (max-width: 400px) {
      /* Very small screens: reduce button size further */
      .iq-segment { padding: 0.5rem 0.8rem; font-size: 0.9rem; }
    }

    /* ============================================================
       HistoryPanel v1 (Interview Questions)
       Matches Resume Feedback History panel structure/UX
       ============================================================ */
    @keyframes rf-shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    .rf-skeleton {
      background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
      background-size: 200% 100%;
      animation: rf-shimmer 1.5s infinite;
      border-radius: var(--radius-lg, 14px);
      opacity: 1;
      transition: opacity 0.3s ease;
    }

    .history-card {
      border: 1px solid var(--color-divider, #E5E7EB);
      padding: 24px;
      margin-bottom: 0;
    }

    .rf-history-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .rf-history-title-wrap {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 0;
    }
    .rf-history-title-text {
      font-weight: 800;
      color: var(--color-text-main, #111827);
      font-size: 1.05rem;
      line-height: 1.2;
    }
    .rf-history-header-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }
    .rf-history-icon-btn {
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: 1px solid var(--color-divider, #E5E7EB);
      border-radius: var(--radius-md);
      background: transparent;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease;
    }
    .rf-history-icon-btn:hover {
      background: var(--color-bg-light, #F9FAFB);
      border-color: #D1D5DB;
    }
    .rf-history-manage-btn,
    .rf-history-link-btn {
      background: transparent;
      border: none;
      padding: 0.25rem 0;
      cursor: pointer;
      font-weight: 600;
      color: var(--color-text-secondary, #374151);
      text-decoration: underline;
      font-size: 0.95rem;
    }
    .rf-history-manage-btn {
      text-decoration: none;
      color: var(--color-text-secondary, #374151);
      font-weight: 700;
      border: 1px solid var(--color-divider, #E5E7EB);
      border-radius: var(--radius-md);
      padding: 0.5rem 1rem;
      background: transparent;
      transition: background 0.18s ease, border-color 0.18s ease;
    }
    .rf-history-manage-btn:hover {
      color: var(--color-text-main, #111827);
      background: var(--color-bg-light, #F9FAFB);
      border-color: #D1D5DB;
    }
    .rf-history-subtitle {
      margin-top: 10px;
      font-size: 0.875rem;
      color: var(--color-text-muted, #6B7280);
    }
    .rf-history-body { margin-top: 16px; }
    .rf-history-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .rf-history-item {
      position: relative;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0.875rem 1rem;
      background: var(--color-card-bg, #fff);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-divider, #E5E7EB);
      transition: background 0.18s ease, border-color 0.18s ease, outline 0.18s ease;
      cursor: pointer;
      min-height: 56px;
    }
    .rf-history-item:hover {
      background: var(--color-bg-light, #F9FAFB);
      border-color: #D1D5DB;
    }
    .rf-history-item.is-selected {
      outline: none;
      border-color: var(--color-divider, #E5E7EB);
      background: var(--color-card-bg, #fff);
    }
    .rf-history-checkbox-wrap {
      display: none;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .rf-history-checkbox {
      width: 18px;
      height: 18px;
      accent-color: var(--color-accent-blue);
      cursor: pointer;
    }
    .rf-history-panel--manage .rf-history-checkbox-wrap { display: inline-flex; }
    .rf-history-icon {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-md);
      background: linear-gradient(135deg, #E0E7FF 0%, #C7D2FE 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .rf-history-icon svg { width: 20px; height: 20px; color: #4F46E5; }
    .rf-history-text { flex: 1; min-width: 0; }
    .rf-history-line1 {
      font-weight: 700;
      color: var(--color-text-main, #111827);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 0.95rem;
      line-height: 1.25;
    }
    .rf-history-line2 {
      margin-top: 2px;
      font-size: 0.85rem;
      color: var(--color-text-muted, #6B7280);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .rf-history-score {
      font-weight: 800;
      color: var(--color-text-main, #111827);
      font-size: 1.05rem;
      min-width: 32px;
      text-align: right;
      flex-shrink: 0;
    }
    .rf-history-row-actions {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-left: 2px;
    }
    .rf-history-kebab {
      width: 40px;
      height: 40px;
      border: 1px solid transparent;
      border-radius: var(--radius-md);
      background: transparent;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: background 0.18s ease, border-color 0.18s ease, opacity 0.18s ease;
      opacity: 0;
    }
    .rf-history-item:hover .rf-history-kebab,
    .rf-history-item:focus-within .rf-history-kebab { opacity: 1; }
    .rf-history-kebab:hover {
      background: var(--color-bg-light, #F3F4F6);
      border-color: var(--color-divider, #E5E7EB);
    }
    @media (hover: none), (pointer: coarse) {
      .rf-history-kebab { opacity: 1; }
    }
    .rf-history-menu {
      position: absolute;
      right: 0;
      top: calc(100% + 6px);
      min-width: 170px;
      background: var(--color-card-bg, #fff);
      border: 1px solid var(--color-divider, #E5E7EB);
      border-radius: 12px;
      box-shadow: var(--shadow-dropdown, 0 12px 28px rgba(0,0,0,0.12));
      padding: 6px;
      z-index: var(--z-popover, 1060);
    }
    .rf-history-menu[hidden] { display: none; }
    .rf-history-menu-item {
      width: 100%;
      text-align: left;
      background: transparent;
      border: none;
      padding: 10px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      color: var(--color-text-main, #111827);
    }
    .rf-history-menu-item:hover { background: var(--color-bg-light, #F9FAFB); }
    .rf-history-menu-item--danger { color: var(--color-error, #DC2626); }
    .rf-history-menu-item--danger:hover { background: rgba(220, 38, 38, 0.06); }

    .rf-history-panel--manage .rf-history-header-actions { display: none; }
    .rf-history-manage-actions {
      display: none;
      flex-shrink: 0;
      align-items: center;
    }
    .rf-history-manage-actions__actions {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .rf-history-panel--manage .rf-history-manage-actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-top: 0;
      width: auto;
    }
    .rf-history-panel--manage .rf-history-row-actions { display: none; }

    .rf-history-danger-btn {
      background: rgba(220, 38, 38, 0.10);
      border: 1px solid rgba(220, 38, 38, 0.25);
      color: var(--color-error, #DC2626);
      font-weight: 800;
      border-radius: var(--radius-md);
      padding: 0.7rem 1rem;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease, opacity 0.18s ease;
    }
    .rf-history-danger-btn:disabled { opacity: 0.55; cursor: not-allowed; }
    .rf-history-danger-btn:hover:not(:disabled) {
      background: rgba(220, 38, 38, 0.14);
      border-color: rgba(220, 38, 38, 0.35);
    }
    .rf-history-neutral-btn {
      background: var(--color-card-bg, #fff);
      border: 1px solid var(--color-divider, #E5E7EB);
      color: var(--color-text-main, #111827);
      font-weight: 700;
      border-radius: var(--radius-md);
      padding: 0.7rem 1rem;
      cursor: pointer;
      transition: background 0.18s ease, border-color 0.18s ease;
    }
    .rf-history-neutral-btn:hover { background: var(--color-bg-light, #F9FAFB); border-color: #D1D5DB; }

    @media (max-width: 520px) {
      .rf-history-panel--manage .rf-history-manage-actions {
        flex-direction: column;
        align-items: stretch;
      }
      .rf-history-manage-actions__actions {
        flex-direction: column;
        align-items: stretch;
      }
      #iq-history-delete-selected,
      #iq-history-cancel-manage {
        width: 100%;
      }
    }

    .rf-history-loading { display: none; }
    .rf-history-loading.is-visible {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .rf-history-skeleton-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 0.875rem 1rem;
      border-radius: var(--radius-md);
      border: 1px solid var(--color-divider, #E5E7EB);
      background: #fff;
      min-height: 56px;
    }
    .rf-history-skeleton-pill { height: 12px; width: 160px; border-radius: 999px; }
    .rf-history-skeleton-pill.sm { width: 120px; }
    .rf-history-skeleton-score { height: 16px; width: 32px; border-radius: 6px; }

    .rf-history-error {
      padding: 10px 12px;
      border: 1px solid rgba(220, 38, 38, 0.22);
      background: rgba(220, 38, 38, 0.06);
      border-radius: 12px;
      color: var(--color-text-main, #111827);
      font-size: 0.95rem;
      margin-bottom: 12px;
    }
    .rf-history-error[hidden] { display: none; }
    .rf-history-empty {
      text-align: center;
      padding: 20px 12px;
      color: var(--color-text-muted, #6B7280);
      border: 1px dashed var(--color-divider, #E5E7EB);
      border-radius: 12px;
    }
    .rf-history-empty[hidden] { display: none; }

    .rf-history-footer {
      margin-top: 16px;
      font-size: 0.875rem;
      color: var(--color-text-muted, #6B7280);
      line-height: 1.45;
    }
    .rf-history-footer a,
    .rf-history-footer button { font-size: inherit; }
    .rf-history-footer-links {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      margin-left: 4px;
    }
    .rf-history-footer-link { color: var(--color-accent-blue, #2563EB); text-decoration: underline; }
    .rf-history-footer-separator { color: var(--color-text-muted, #6B7280); font-weight: 600; }
    .rf-history-footer-link--danger {
      color: var(--color-error, #DC2626);
      background: transparent;
      border: none;
      padding: 0;
      font-weight: 600;
      cursor: pointer;
      text-decoration: none;
    }
    .rf-history-footer-link--danger:hover { text-decoration: underline; }

    .rf-history-modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(17, 24, 39, 0.55);
      z-index: var(--z-modal-backdrop, 90);
    }
    .rf-history-modal-backdrop[hidden] { display: none; }
    .rf-history-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: min(520px, calc(100vw - 32px));
      background: #fff;
      border: 1px solid var(--color-divider, #E5E7EB);
      border-radius: var(--radius-xl);
      box-shadow: var(--shadow-xl, 0 20px 50px rgba(0,0,0,0.18));
      padding: 20px;
      z-index: var(--z-modal, 100);
    }
    .rf-history-modal[hidden] { display: none; }
    .rf-history-modal h3 {
      margin: 0 0 8px 0;
      font-size: 1.15rem;
      font-weight: 800;
      color: var(--color-text-main, #111827);
    }
    .rf-history-modal p {
      margin: 6px 0;
      color: var(--color-text-secondary, #374151);
      line-height: 1.5;
    }
    .rf-history-modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 16px;
      flex-wrap: wrap;
    }
    .rf-history-modal-actions button { min-height: 44px; }
    @media (max-width: 520px) {
      .rf-history-modal-actions { flex-direction: column; align-items: stretch; }
    }

    /* (Reverted) No overflow menu styles */

    /* Combobox active item */
    .iq-role-item.active { background:#EEF2FF; }
    /* Ensure last card clears footer (reduced to match footer standards) */
    #iq-questions { padding-bottom: 24px; }
    /* Extra spacer to ensure nothing hides under footer */
    .iq-main::after { content:""; display:block; height:0; }

    /* Lightweight snackbar toast */
    #iq-toast { position:fixed; bottom:18px; right:18px; background:#111827; color:#fff; padding:.55rem .75rem; border-radius:var(--radius-md, 8px); box-shadow:0 6px 18px rgba(0,0,0,.18); font-size:.95rem; z-index:10000; opacity:0; transform:translateY(8px); transition:opacity .18s ease, transform .18s ease; }
    #iq-toast.show { opacity:1; transform:translateY(0); }
    /* Ensure overlay respects hidden state regardless of inline display */
    #iq-upsell[hidden] { display: none !important; }

    /* Accessible, consistent tooltips for action buttons */
    .icon-btn[data-tip] { position: relative; }
    .icon-btn[data-tip]::after {
      content: attr(data-tip);
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(100% + 8px);
      background: #111827;
      color: #fff;
      padding: .25rem .5rem;
      border-radius: 6px;
      font-size: .85rem;
      line-height: 1;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0,0,0,.18);
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease;
      z-index: 50;
    }
    .icon-btn[data-tip]::before {
      content: '';
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(100% + 2px);
      border: 6px solid transparent;
      border-top-color: #111827;
      opacity: 0;
      transition: opacity .12s ease;
      pointer-events: none;
      z-index: 50;
    }
    .icon-btn[data-tip]:hover::after,
    .icon-btn[data-tip]:focus-visible::after,
    .icon-btn[data-tip]:hover::before,
    .icon-btn[data-tip]:focus-visible::before { opacity: 1; }
    /* Plan strip styling - matches dashboard style */
    .iq-plan-strip {
      display: none; /* Hide the old plan strip, we move it inline */
    }
    .usage-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.95rem;
      color: var(--color-text-secondary, #4B5563);
    }

    /* Selection summary styling */
    .iq-selection-summary {
      background: rgba(5, 150, 105, 0.1);
      border: 1px solid rgba(5, 150, 105, 0.25);
      border-radius: var(--radius-md, 8px);
      padding: 0.75rem 1rem;
      margin-bottom: 1.25rem;
      font-size: 0.9rem;
      color: var(--color-success, #059669);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .iq-selection-summary.no-selection {
      background: rgba(217, 119, 6, 0.1);
      border: 1px solid rgba(217, 119, 6, 0.25);
      color: var(--color-warning, #D97706);
    }
    
    /* Tip Banner - Fixed */
    .iq-hint-banner {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      background: rgba(0, 123, 255, 0.1);
      border: 1px solid rgba(0, 123, 255, 0.25);
      border-radius: var(--radius-md, 8px);
      color: var(--color-accent-blue, #007BFF);
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    /* Empty state */
    .iq-empty-state {
      text-align: center;
      padding: 3rem 1.5rem;
      color: #6B7280;
      font-size: 1rem;
      line-height: 1.6;
    }
    .iq-empty-state strong {
      color: #1F2937;
      display: block;
      margin-bottom: 0.5rem;
      font-size: 1.1rem;
    }

    /* Action bar layout for funnel */
    .iq-actions-left {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .iq-actions-right {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .iq-actions-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 0.75rem;
    }
    @media (max-width: 700px) {
      .iq-actions-bar {
        flex-direction: column;
        align-items: stretch;
      }
      .iq-actions-left, .iq-actions-right {
        justify-content: center;
      }
    }

    /* Cooldown tooltip */
    .cooldown-wrapper {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
    }
    .cooldown-info {
      cursor: help;
      color: #6B7280;
    }
    .cooldown-tooltip {
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: #111827;
      color: #fff;
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.8rem;
      line-height: 1.4;
      white-space: normal;
      width: 250px;
      box-shadow: 0 4px 12px rgba(0,0,0,.18);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 100;
    }
    .cooldown-wrapper:hover .cooldown-tooltip,
    .cooldown-info:focus + .cooldown-tooltip {
      opacity: 1;
    }

    /* Start Mock Interview CTA styling */
    .btn-mock-cta {
      background: #00E676;
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 0.6rem 1rem;
      font-weight: 600;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      transition: background 0.18s;
      min-height: 48px; /* Match height of other action buttons */
    }
    .btn-mock-cta:hover {
      background: #00c965;
    }
    .btn-mock-cta[data-locked="true"] {
      background: #6B7280;
    }
    .btn-mock-cta[data-locked="true"]:hover {
      background: #4B5563;
    }
    .btn-mock-cta[data-locked="true"] .lock svg {
      color: #fff; /* White lock icon when button is locked */
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="site-header">
    <div class="container">
      <a href="index.html" class="nav-logo" aria-label="Go to homepage">
        <svg width="24" height="24" fill="none" stroke="#1F2937" stroke-width="2" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="7" width="18" height="13" rx="2"/>
          <path d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2"/>
        </svg>
        <span>JOBHACKAI</span>
      </a>
      <div class="nav-group">
        <nav class="nav-links" role="navigation">
          <!-- Navigation will be dynamically populated by navigation.js -->
        </nav>
      </div>

    <!-- Upsell Overlay (shown when plan is not eligible for Mock Interview) -->
    <div id="iq-upsell" hidden style="position:fixed; inset:0; background:rgba(17,24,39,.55); z-index:1100; display:flex; align-items:center; justify-content:center;">
      <div role="dialog" aria-modal="true" aria-labelledby="upsell-title" class="card" style="max-width:560px; width:92%; box-shadow:0 14px 40px rgba(0,0,0,.25);">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:.75rem;">
          <h3 id="upsell-title" style="margin:0;">Unlock Mock Interviews</h3>
          <button id="upsell-cancel" class="icon-btn" aria-label="Close" style="padding:.35rem;">
            <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
          </button>
        </div>
        <p style="color:#4B5563; margin:.25rem 0 1rem 0;">Your questions are saved â€” upgrade to Pro to run live mock interviews with these questions.</p>
        <ul style="margin:0 0 1rem 1.25rem; color:#374151;">
          <li>Unlimited mock interview sessions</li>
          <li>Answer guidance and coaching tips</li>
          <li>Works with your starred questions</li>
        </ul>
        <div style="display:flex; gap:.5rem; flex-wrap:wrap;">
          <a id="upsell-upgrade" href="#" class="btn-primary" style="text-decoration:none;" onclick="startCheckout('pro'); return false;">Upgrade to Pro</a>
          <script>
            // Inline helper b/c this page doesn't include the global checkout helper by default.
            // Starts server-side Stripe Checkout using /api/stripe-checkout so sessions are created dynamically.
            (function() {
              async function startCheckoutLocal(plan) {
                try {
                  if (window.showLoadingOverlay) {
                    window._currentLoadingOverlay = window.showLoadingOverlay('Redirecting to checkout...');
                  }
                  const user = window.FirebaseAuthManager?.getCurrentUser?.();
                  if (!user) {
                    window.location.href = 'login.html';
                    return;
                  }
                  const idToken = await user.getIdToken();
                  const res = await fetch('/api/stripe-checkout', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...(idToken ? { Authorization: `Bearer ${idToken}` } : {}) },
                    body: JSON.stringify({ plan })
                  });
                  const data = await res.json();
                  if (data && data.ok && data.url) {
                    window.location.href = data.url;
                    return;
                  }
                  throw new Error(data?.error || 'Checkout failed');
                } catch (err) {
                  console.error('Checkout start error:', err);
                  if (window._currentLoadingOverlay) { window._currentLoadingOverlay(); window._currentLoadingOverlay = null; }
                  window.location.href = `pricing-a.html?plan=${encodeURIComponent(plan)}`;
                }
              }
              // Expose a global name expected by the inline onclick handler
              window.startCheckout = startCheckoutLocal;
            })();
          </script>
          <button id="upsell-cancel-2" class="btn-outline">Maybe later</button>
        </div>
      </div>
    </div>
      <button class="mobile-toggle" aria-label="Open navigation menu" aria-expanded="false" aria-controls="mobileNav">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
    </div>
  </header>

  <nav class="mobile-nav" id="mobileNav">
    <!-- Mobile navigation will be dynamically populated by navigation.js -->
  </nav>
  <div class="mobile-nav-backdrop" id="mobileNavBackdrop"></div>
  <main class="iq-main">
    <section class="rf-card" id="iq-feature-tile">
      <div class="rf-title" style="margin-bottom:0.2rem;">
        Interview Questions
        <span id="plan-badge-container"></span>
      </div>
      <div style="color:var(--color-text-secondary);margin:0.35rem 0 0.7rem;">
        Practice your answers with AI-generated questions tailored to your job title.
      </div>
      
      <!-- Process Guide Inside Card -->
      <div class="iq-process-guide" style="margin-top: 1.25rem; padding-top: 1rem; border-top: 1px solid var(--color-divider); display: flex; gap: 1.5rem; flex-wrap: wrap;">
        <div style="font-size: 0.85rem; color: var(--color-text-secondary);">
          <strong style="color: var(--color-text-main);">1.</strong> Generate questions
        </div>
        <div style="font-size: 0.85rem; color: var(--color-text-secondary);">
          <strong style="color: var(--color-text-main);">2.</strong> Star your favorites
        </div>
        <div style="font-size: 0.85rem; color: var(--color-text-secondary);">
          <strong style="color: var(--color-text-main);">3.</strong> Run a Mock Interview
        </div>
      </div>
      
      <div class="rf-plan-limit">
        <div id="iq-usage-container"></div>
      </div>
    </section>

    <!-- Selection Summary -->
    <div id="iq-selection-summary" class="iq-selection-summary" style="display:none;">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"/></svg>
      <span id="selection-count-text">Selected for Mock Interview: 0 of 10 questions</span>
      <span style="font-size:0.8rem; color:var(--color-text-muted, #6B7280); margin-left:0.5rem;">We'll use your starred questions in your mock interview.</span>
    </div>

    <div class="iq-top-grid">
      <div>
    <div class="iq-toolbar card">
      <div class="iq-row">
        <div class="iq-field" style="flex:1 1 300px; min-width:280px; position:relative;">
          <label for="iq-role" style="display:block; margin-bottom:0.5rem; font-weight:600; color:#374151; font-size:0.9rem;">Role</label>
          <input id="iq-role" class="iq-role-input" type="text" placeholder="e.g. Software Engineer"
            role="combobox" aria-autocomplete="list" aria-expanded="false" autocomplete="off">
          <div id="iq-live" class="sr-only" aria-live="polite"></div>
        </div>

        <div style="display:flex; flex-direction:column; min-width:140px;">
          <label for="iq-seniority" style="margin-bottom:0.5rem; font-weight:600; color:#374151; font-size:0.9rem;">Seniority</label>
          <select id="iq-seniority" class="iq-select" aria-label="Seniority">
            <option value="" disabled selected hidden></option>
            <option>Intern</option><option>Junior</option><option>Mid</option>
            <option>Senior</option><option>Lead</option><option>Director</option>
          </select>
        </div>

        <div class="iq-types" aria-label="Question Type" style="min-width:550px;" aria-labelledby="iq-types-label">
          <div id="iq-types-label" style="margin-bottom:0.5rem; font-weight:600; color:#374151; font-size:0.9rem;">Question Type</div>
          <div class="iq-segmented" id="iq-type" role="tablist" aria-label="Question type">
            <button type="button" class="iq-segment active" data-value="mixed" role="tab" aria-selected="true">Mixed</button>
            <button type="button" class="iq-segment" data-value="behavioral" role="tab" aria-selected="false">Behavioral</button>
            <button type="button" class="iq-segment" data-value="technical" role="tab" aria-selected="false">Technical</button>
            <button type="button" class="iq-segment" data-value="leadership" role="tab" aria-selected="false">Leadership</button>
          </div>
        </div>

        
      </div>

      <!-- First-time visitor hint banner -->
      <div id="iq-first-hint" class="iq-hint-banner" style="display:none;">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="flex-shrink:0;">
          <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"/>
          <circle cx="12" cy="12" r="4"/>
        </svg>
        <span style="flex:1;"><strong>Tip:</strong> Star the questions you care about most, then use 'Start Mock Interview' to practice them live.</span>
        <button type="button" class="icon-btn" aria-label="Dismiss" onclick="this.parentElement.style.display='none'; try{localStorage.setItem('iq_first_visit_shown','true');}catch{}" style="flex-shrink:0; padding:0.25rem; min-width:24px; min-height:24px; display:flex; align-items:center; justify-content:center; background:transparent; border:none; color:#1E40AF; cursor:pointer; transition:opacity 0.15s ease;">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
      </div>

      <details class="iq-advanced" style="margin-top:.5rem;">
        <summary>Advanced: Paste Job Description (optional)</summary>
        <textarea id="iq-jd" rows="4" placeholder="Paste the job description to tailor your questions..."></textarea>
      </details>

      <div class="iq-actions">
        <button id="btn-generate" class="btn-primary" aria-label="Generate 10 Questions">Generate 10 Questions</button>
        <button type="button" id="iq-start-fresh-btn" class="rf-btn-ghost" aria-label="Start Fresh">Start Fresh</button>
      </div>
      <div id="iq-generate-cooldown" class="iq-global-cooldown" aria-live="polite" style="margin-top:0.25rem;"></div>
      
      <!-- Action bar with left/right grouping -->
      <div class="iq-actions-bar" id="iq-actions-bar" style="display:none;">
        <div class="iq-actions-left">
        <button id="btn-copy-all" class="btn-outline">Copy All</button>
        <button id="btn-download" class="btn-outline">Download PDF</button>
          <button id="btn-save-set" class="btn-outline">Saved Questions <span id="chip-saved-count" style="margin-left:0.25rem;"></span></button>
        </div>
        <div class="iq-actions-right">
        <button id="toggle-guidance" class="btn-outline" aria-pressed="false">Show Answer Guidance</button>
          <button id="btn-mock" class="btn-mock-cta" data-locked="false">
            Start Mock Interview
            <span class="lock" id="mock-lock-icon" aria-hidden="true" style="display:none;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="5" y="11" width="14" height="10" rx="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
            </span>
          </button>
        </div>
      </div>
      <!-- Hidden for backwards compatibility -->
      <div class="iq-actions-sec" id="iq-actions-sec" hidden style="display:none;">
        <button id="chip-saved" class="chip" hidden aria-hidden="true">Saved (0)</button>
      </div>
      
      <!-- Questions section - moved inside left column to prevent overlap with history panel -->
      <div class="iq-questions-section">
        <div id="iq-questions" class="iq-questions"></div>
      </div>
      </div>
      </div>
      <aside class="card history-card rf-history" id="iq-history-panel" data-history-panel="v1">
        <div class="rf-history-header" data-history-header>
          <div class="rf-history-title-wrap">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <circle cx="12" cy="12" r="10"/>
              <polyline points="12 6 12 12 16 14"/>
            </svg>
            <span class="rf-history-title-text" id="iq-history-header-title">History</span>
          </div>

          <div class="rf-history-header-actions" data-history-header-actions>
            <button id="iq-history-refresh" class="rf-history-icon-btn" title="Refresh history" aria-label="Refresh history" type="button">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M23 4v6h-6"/>
                <path d="M1 20v-6h6"/>
                <path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/>
              </svg>
            </button>
            <button id="iq-history-manage" class="rf-history-manage-btn" type="button">Manage</button>
          </div>

          <div class="rf-history-manage-actions" id="iq-history-manage-actions" data-history-manage-controls>
            <div class="rf-history-manage-actions__actions">
              <button id="iq-history-delete-selected" class="rf-history-danger-btn" type="button" disabled>Delete selected</button>
              <button id="iq-history-cancel-manage" class="rf-history-neutral-btn" type="button">Cancel</button>
            </div>
          </div>
        </div>

        <div class="rf-history-subtitle" data-history-subtitle>
          Last 10 question sets â€¢ Auto-saved
        </div>

        <div class="rf-history-body" data-history-body>
          <div class="rf-history-loading" id="iq-history-loading" data-history-loading>
            <div class="rf-history-skeleton-row">
              <div class="rf-skeleton" style="width:40px;height:40px;border-radius:var(--radius-md);"></div>
              <div style="flex:1;min-width:0;">
                <div class="rf-skeleton rf-history-skeleton-pill"></div>
                <div class="rf-skeleton rf-history-skeleton-pill sm" style="margin-top:8px;"></div>
              </div>
            </div>
            <div class="rf-history-skeleton-row">
              <div class="rf-skeleton" style="width:40px;height:40px;border-radius:var(--radius-md);"></div>
              <div style="flex:1;min-width:0;">
                <div class="rf-skeleton rf-history-skeleton-pill"></div>
                <div class="rf-skeleton rf-history-skeleton-pill sm" style="margin-top:8px;"></div>
              </div>
            </div>
            <div class="rf-history-skeleton-row">
              <div class="rf-skeleton" style="width:40px;height:40px;border-radius:var(--radius-md);"></div>
              <div style="flex:1;min-width:0;">
                <div class="rf-skeleton rf-history-skeleton-pill"></div>
                <div class="rf-skeleton rf-history-skeleton-pill sm" style="margin-top:8px;"></div>
              </div>
            </div>
          </div>

          <div class="rf-history-error" id="iq-history-error" data-history-error hidden>
            <span data-default-message="Couldnâ€™t load history.">Couldnâ€™t load history. </span>
            <button id="iq-history-retry" class="rf-history-link-btn" type="button">Retry.</button>
          </div>

          <div class="rf-history-list" id="iq-history-list" data-history-list></div>

          <div class="rf-history-empty" id="iq-history-empty" data-history-empty hidden>
            <div style="font-weight:800;margin-bottom:0.25rem;color:var(--color-text-main, #111827);">No history yet</div>
            <div>Your last 10 question sets will appear here automatically.</div>
          </div>
        </div>

        <div class="rf-history-footer" data-history-footer>
          <span>Data retention: JobHackAI shows your last 10 question sets. Sets are automatically deleted after 90 days.</span>
          <div class="rf-history-footer-links">
            <a class="rf-history-footer-link" href="#" data-history-learn-more>Learn more</a>
            <span class="rf-history-footer-separator" aria-hidden="true">Â·</span>
            <button id="iq-history-clear" class="rf-history-footer-link rf-history-footer-link--danger" type="button">Clear history</button>
          </div>
        </div>

        <!-- Delete confirmation modal -->
        <div class="rf-history-modal-backdrop" id="iq-history-modal-backdrop" hidden></div>
        <div
          class="rf-history-modal"
          id="iq-history-delete-modal"
          role="dialog"
          aria-modal="true"
          aria-labelledby="iq-history-modal-title"
          hidden
          data-history-modal
        >
          <h3 id="iq-history-modal-title">Permanently delete history?</h3>
          <p>This will remove the selected items from your account.</p>
          <p>This cannot be undone.</p>
          <div class="rf-history-modal-actions">
            <button id="iq-history-modal-cancel" class="rf-history-neutral-btn" type="button">Cancel</button>
            <button id="iq-history-modal-confirm" class="rf-history-danger-btn" type="button">Delete permanently</button>
          </div>
        </div>
      </aside>
    </div>

    <div id="iq-lock" class="iq-lock" style="display:none;">
      <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
        <rect x="5" y="11" width="14" height="10" rx="2"/>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>
      <span>Mock Interviews are only available on the <strong>Pro</strong> plan and above</span>
    </div>
    <button id="iq-upgrade" class="iq-upgrade-btn" style="display:none;">Upgrade to Pro</button>

    <!-- Saved Set Panel -->
    <div id="iq-saved-panel" class="card" hidden style="position:fixed; top:20%; left:50%; transform:translateX(-50%); width:90%; max-width:600px; z-index:1000; box-shadow:0 8px 28px rgba(0,0,0,.15);">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:1rem;">
        <h3 style="margin:0;">Saved Questions</h3>
        <button id="saved-close" class="icon-btn" style="padding:.4rem;">
          <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
        </button>
      </div>
      <div id="iq-saved-list" style="max-height:300px; overflow-y:auto; margin-bottom:1rem;"></div>
      <div style="display:flex; gap:.5rem; flex-wrap:wrap;">
        <button id="saved-copy-all" class="btn-outline">Copy All</button>
        <button id="saved-download" class="btn-outline">Download PDF</button>
        <button id="saved-mock" class="btn-primary">Start with This Saved Set</button>
      </div>
    </div>

    <!-- Toast container -->
    <div id="iq-toast" role="status" aria-live="polite" aria-atomic="true"></div>
  </main>
  <!-- Footer (canonical) -->
  <footer class="site-footer">
    <div class="footer-container">
      <div class="footer-brand">
        <svg class="footer-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="7" width="18" height="13" rx="2" stroke="#1F2937" stroke-width="2"/>
          <path d="M8 7V5a2 2 0 012-2h4a2 2 0 012 2v2" stroke="#1F2937" stroke-width="2"/>
        </svg>
        <span class="footer-name">JOBHACKAI</span>
      </div>
      <div class="footer-legal">
        <p>Â© 2025 JobHackAI. All rights reserved.</p>
      </div>
      <div class="footer-links">
        <a href="index.html">Home</a>
        <a href="help.html">Help</a>
        <a href="privacy.html">Privacy</a>
      </div>
    </div>
  </footer>
  <script>
    // Hamburger menu toggle with proper state management and click-outside handling
    (function initMobileMenu() {
      const mobileToggle = document.querySelector('.mobile-toggle');
      const mobileNav = document.getElementById('mobileNav');
      const backdrop = document.getElementById('mobileNavBackdrop');
      
      if (!mobileToggle || !mobileNav) return;
      
      let isMenuOpen = false;
      
      // Function to open menu
      function openMenu() {
        if (isMenuOpen) return;
        isMenuOpen = true;
        mobileNav.classList.add('open');
        if (backdrop) backdrop.classList.add('show');
        mobileToggle.setAttribute('aria-expanded', 'true');
        // Prevent body scroll when menu is open
        document.body.style.overflow = 'hidden';
      }
      
      // Function to close menu
      function closeMenu() {
        if (!isMenuOpen) return;
        isMenuOpen = false;
        mobileNav.classList.remove('open');
        if (backdrop) backdrop.classList.remove('show');
        mobileToggle.setAttribute('aria-expanded', 'false');
        // Restore body scroll
        document.body.style.overflow = '';
      }
      
      // Toggle menu on button click
      mobileToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        if (isMenuOpen) {
          closeMenu();
        } else {
          openMenu();
        }
      });
      
      // Close menu when clicking on a link
      mobileNav.addEventListener('click', (e) => {
        if (e.target.tagName === 'A') {
          closeMenu();
        }
      });
      
      // Close menu when clicking on backdrop or outside
      if (backdrop) {
        backdrop.addEventListener('click', closeMenu);
      }
      document.addEventListener('click', (e) => {
        if (isMenuOpen && 
            !mobileNav.contains(e.target) && 
            !mobileToggle.contains(e.target)) {
          closeMenu();
        }
      });
      
      // Close menu on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isMenuOpen) {
          closeMenu();
        }
      });
      
      // Close menu on window resize (if resizing to desktop)
      window.addEventListener('resize', () => {
        if (window.innerWidth > 900 && isMenuOpen) {
          closeMenu();
        }
      });
    })();

    // --- AUTHENTICATION CHECK ---
    async function checkAuthentication() {
      // Wait for Firebase auth to be ready
      if (window.FirebaseAuthManager && window.FirebaseAuthManager.waitForAuthReady) {
        try {
          await window.FirebaseAuthManager.waitForAuthReady(3000);
        } catch (e) {
          console.warn('[INTERVIEW-Q] Auth ready timeout in checkAuthentication:', e);
        }
      }
      
      // Use navigation system's authentication check for consistency
      if (window.JobHackAINavigation) {
        const authState = window.JobHackAINavigation.getAuthState();
        if (!authState.isAuthenticated) {
          const mainContent = document.querySelector('main');
          mainContent.innerHTML = `
            <div style="max-width: 600px; margin: 4rem auto; text-align: center; padding: 2rem;">
              <div style="font-size: 4rem; margin-bottom: 1rem;">ðŸ”’</div>
              <h1 style="font-size: 2rem; font-weight: 700; color: var(--color-text-main); margin-bottom: 1rem;">
                Login Required
              </h1>
              <p style="font-size: 1.1rem; color: var(--color-text-secondary); margin-bottom: 2rem; line-height: 1.6;">
                Interview Questions requires you to be logged in to access this tool. 
                Please sign in to get started.
              </p>
              <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <a href="login.html" class="btn-primary" style="text-decoration: none;">
                  Sign In
                </a>
                <a href="pricing-a.html" class="btn-outline" style="text-decoration: none;">
                  View Pricing
                </a>
              </div>
            </div>
          `;
          return false;
        }
        return true;
      } else {
        // Fallback to localStorage check if navigation system not available
        // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
        // FirebaseAuthManager.getCurrentUser() returns null until onAuthStateChanged fires
        function hasFirebaseAuthKeys() {
          try {
            return Object.keys(localStorage).some(k => 
              k.startsWith('firebase:authUser:') && 
              localStorage.getItem(k) && 
              localStorage.getItem(k) !== 'null' &&
              localStorage.getItem(k).length > 10
            );
          } catch (e) {
            return false;
          }
        }
        const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
        const hasFirebaseKeys = hasFirebaseAuthKeys();
        const isAuthenticated = hasLocalStorageAuth || hasFirebaseKeys;
        if (!isAuthenticated) {
          const mainContent = document.querySelector('main');
          mainContent.innerHTML = `
            <div style="max-width: 600px; margin: 4rem auto; text-align: center; padding: 2rem;">
              <div style="font-size: 4rem; margin-bottom: 1rem;">ðŸ”’</div>
              <h1 style="font-size: 2rem; font-weight: 700; color: var(--color-text-main); margin-bottom: 1rem;">
                Login Required
              </h1>
              <p style="font-size: 1.1rem; color: var(--color-text-secondary); margin-bottom: 2rem; line-height: 1.6;">
                Interview Questions requires you to be logged in to access this tool. 
                Please sign in to get started.
              </p>
              <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
                <a href="login.html" class="btn-primary" style="text-decoration: none;">
                  Sign In
                </a>
                <a href="pricing-a.html" class="btn-outline" style="text-decoration: none;">
                  View Pricing
                </a>
              </div>
            </div>
          `;
          return false;
        }
        return true;
      }
    }

    // --- USER PLAN LOGIC ---
    function getUserPlan() {
      // Use navigation system's plan detection for consistency
      if (window.JobHackAINavigation) {
        return window.JobHackAINavigation.getEffectivePlan();
      } else {
        return localStorage.getItem('user-plan') || 'free';
      }
    }
    
    const user = {
      plan: getUserPlan()
    };
    /* ==== Interview Questions MVP+ module (in-file) ==== */
    /* OpenAI usage:
       - apiGenerate: batched questions via /api/interview-questions/generate
       - apiSaveSet: saves to D1 via /api/interview-questions/save-set
       All calls go through authenticated API endpoints. */

    // ---------- CONFIG ----------
    const IQ_API = { 
      GENERATE: '/api/interview-questions/generate',
      SAVE_SET: '/api/interview-questions/save-set',
      GET_SET: '/api/interview-questions/get-set',
      HISTORY: '/api/interview-questions/history'
    };
    const IQ_ANALYTICS_HOOK = '';

    // Limits
    const IQ_GLOBAL_COOLDOWN = 45;          // seconds
    const IQ_MAX_REPLACES = 3;              // hard cap per set
    const IQ_PER_Q_REPLACE_COOLDOWN = 5;    // seconds
    const IQ_RECENT_LIMIT = 10;

    // Role selector will be initialized separately

    const $IQ = (s, r=document)=>r.querySelector(s);
    const $$IQ = (s, r=document)=>[...r.querySelectorAll(s)];

    // State
    const iqState = {
      prefs: { seniority:'', count:10, type:'mixed', showGuidance:false },
      set: null,
      cooldown: 0,
      timers: { global:null, perQ:{}, replaceGlobal:null, toast:null },
      recents: [],
      replaceCounts: {}, // Track per-question replace counts (TASK 10B)
      replaceCooldowns: {}, // Track per-question cooldowns
      replaceGlobalCooldown: 0, // Track user-level replace cooldown (matches backend)
      dailyLimitReached: false, // Track if daily limit has been reached
      _resetRequested: false // Track if reset was requested (prevents race conditions)
    };

    // Utils & persistence
    const iqNow = ()=> new Date().toISOString();
    const iqSetId = (role, seed)=> `${role}:${seed}`;
    const IQ_VALID_TYPES = new Set(['mixed','behavioral','technical','leadership']);
    const iqSanitizeType = (raw, fallback = 'mixed') => {
      const t = String(raw || '').trim().toLowerCase();
      return IQ_VALID_TYPES.has(t) ? t : fallback;
    };
    // Legacy compatibility: infer a single `type` from older `types[]` representations
    const iqInferTypeFromLegacyTypes = (legacyTypes) => {
      if (!legacyTypes) return 'mixed';
      let arr = [];
      if (legacyTypes instanceof Set) arr = Array.from(legacyTypes);
      else if (Array.isArray(legacyTypes)) arr = legacyTypes;
      else if (typeof legacyTypes === 'object' && Object.keys(legacyTypes).length === 0) arr = [];
      arr = arr.map(v => String(v || '').toLowerCase()).filter(Boolean);
      if (!arr.length) return 'mixed';
      if (arr.includes('mixed')) return 'mixed';
      // If legacy had multiple selected types, map to mixed
      if (arr.length > 1) return 'mixed';
      // Map removed legacy types to nearest bucket
      if (arr[0] === 'system') return 'technical';
      if (arr[0] === 'culture') return 'behavioral';
      return iqSanitizeType(arr[0], 'mixed');
    };
    function iqToast(msg){
      console.log('[iq-toast]', msg);
      const el = document.getElementById('iq-toast');
      if(!el) return; el.textContent = msg; el.classList.add('show');
      clearTimeout(iqState.timers.toast);
      iqState.timers.toast = setTimeout(()=> el.classList.remove('show'), 1600);
    }
    function iqEsc(s){ return String(s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }
    // Helper to disable all question generation buttons when daily limit is reached
    // Note: Replace buttons remain enabled as replacements are free and don't count toward daily limit
    function iqDisableAllButtons(){
      iqState.dailyLimitReached = true;
      // Disable generate button (only full sets count toward daily limit)
      const genBtn = $IQ('#btn-generate');
      if (genBtn) {
        genBtn.disabled = true;
        genBtn.setAttribute('aria-disabled', 'true');
        genBtn.style.opacity = '0.5';
        genBtn.style.cursor = 'not-allowed';
        // Update button text to indicate daily limit reached (instead of leaving "Generating...")
        genBtn.textContent = 'Daily Limit Reached';
      }
      // Replace buttons remain enabled - replacements are free and don't count toward daily limit
    }
    function updateStartFreshButtonState() {
      const btn = $IQ('#iq-start-fresh-btn');
      if (!btn) return;
      const enabled = !!iqState.set;
      btn.disabled = !enabled;
      btn.setAttribute('aria-disabled', enabled ? 'false' : 'true');
      btn.style.opacity = enabled ? '' : '0.5';
      btn.style.cursor = enabled ? 'pointer' : 'not-allowed';
    }

    function resetInterviewQuestionsSession() {
      if (!iqState.set) {
        return;
      }

      // Set reset flag to prevent race conditions with in-flight API requests
      iqState._resetRequested = true;

      const savedKey = iqSavedKey();
      if (savedKey) {
        try {
          localStorage.removeItem(savedKey);
        } catch (e) {
          console.warn('[IQ] Failed to clear saved indexes', e);
        }
      }

      iqState.set = null;
      iqState.cooldown = 0;
      iqState.dailyLimitReached = false;
      iqState.replaceCounts = {};
      iqState.replaceCooldowns = {};
      iqState.replaceGlobalCooldown = 0;

      if (iqState.timers.global) {
        clearInterval(iqState.timers.global);
        iqState.timers.global = null;
      }

      iqResetPerQuestionCooldowns();

      const roleInput = $IQ('#iq-role');
      if (roleInput) {
        roleInput.value = '';
      }

      const jdInput = $IQ('#iq-jd');
      if (jdInput) {
        jdInput.value = '';
      }

      document.querySelectorAll('.rf-history-item.is-selected').forEach(el => el.classList.remove('is-selected'));

      // Close saved panel if open (matches iqLoadSetById behavior)
      const savedPanel = $IQ('#iq-saved-panel');
      if (savedPanel) {
        savedPanel.hidden = true;
      }

      // Explicitly reset generate button text in case it was set to "Daily Limit Reached"
      const genBtn = $IQ('#btn-generate');
      if (genBtn) {
        genBtn.textContent = 'Generate 10 Questions';
      }

      iqRenderQuestions();
      iqUpdateSelectionSummary();
      iqUpdateActionsLayout();
      iqUpdateGenerateButtonState();
      renderGenerateCooldownIndicator();
      updateStartFreshButtonState();
    }
    function iqTrack(event, data={}){
      const payload = { event, ts: iqNow(), role: iqState?.set?.role || $IQ('#iq-role')?.value || '', seniority: iqState.prefs.seniority, type: iqState.prefs.type, count: iqState.prefs.count, used_jd: !!$IQ('#iq-jd')?.value?.trim(), ...data };
      console.log('[iq-analytics]', payload);
      if (!IQ_ANALYTICS_HOOK) return;
      fetch(IQ_ANALYTICS_HOOK, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }).catch(()=>{});
    }
    function iqSavePrefs(){ localStorage.setItem('iq_prefs', JSON.stringify({ seniority: iqState.prefs.seniority, count: iqState.prefs.count, type: iqState.prefs.type, showGuidance: iqState.prefs.showGuidance })); }
    function iqLoadPrefs(){
      try{
        const p=JSON.parse(localStorage.getItem('iq_prefs')||'{}');
        if(p.seniority) iqState.prefs.seniority=p.seniority;
        if(p.count) iqState.prefs.count=p.count;
        // New format
        if(p.type) iqState.prefs.type = iqSanitizeType(p.type, 'mixed');
        // Legacy format
        if(!p.type && Array.isArray(p.types)) iqState.prefs.type = iqInferTypeFromLegacyTypes(p.types);
        if(typeof p.showGuidance==='boolean') iqState.prefs.showGuidance=p.showGuidance;
      }catch{}
    }
    function iqAddRecent(meta){ 
      iqState.recents = JSON.parse(localStorage.getItem('iq_recent_sets')||'[]'); 
      iqState.recents.unshift(meta); 
      iqState.recents = iqState.recents.slice(0, IQ_RECENT_LIMIT); 
      localStorage.setItem('iq_recent_sets', JSON.stringify(iqState.recents)); 
    }
    
    // Save question set to D1 for history (all plans)
    async function iqSaveSetToD1(setObj) {
      try {
        const token = await getFirebaseToken();
        if (!token) {
          console.warn('[IQ] Not authenticated, skipping D1 save');
          return null;
        }
        
        // Save to D1 with all questions selected initially (for history)
        const selectedIndices = setObj.questions ? setObj.questions.map((_, idx) => idx) : [];
        const types = Array.isArray(setObj.types) ? setObj.types : (setObj.type ? [setObj.type] : ['mixed']);
        
        const response = await fetch(IQ_API.SAVE_SET, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({
            role: setObj.role,
            seniority: setObj.seniority || null,
            type: setObj.type || 'mixed',
            types: types,
            questions: setObj.questions || [],
            selectedIndices: selectedIndices,
            jd: setObj.jd || null
          })
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          console.warn('[IQ] Failed to save set to D1:', errorData.error || response.status);
          return null;
        }
        
        const data = await response.json();
        if (data.success && data.id) {
          console.log('[IQ] Saved set to D1:', data.id);
          return { id: data.id, createdAt: data.createdAt };
        }
        
        return null;
      } catch (e) {
        console.warn('[IQ] Error saving set to D1:', e);
        return null;
      }
    }
    function iqSaveSetFull(setObj){ 
      try{ 
        const id=iqSetId(setObj.role,setObj.seed); 
        // Include replaceCounts and persist selected type (legacy types[] supported on load)
        const toSave = {
          ...setObj,
          type: setObj.type || iqInferTypeFromLegacyTypes(setObj.types),
          types: Array.from(setObj.types || []),
          replaceCounts: iqState.replaceCounts || {}
        };
        localStorage.setItem(`iq_set_${id}`, JSON.stringify(toSave)); 
      }catch(e){ 
        console.warn('save set failed',e);
      }
    }
    function iqLoadSetById(id){ 
      try{ 
        const raw=localStorage.getItem(`iq_set_${id}`); 
        if(!raw){ 
          iqToast('Previous set not found'); 
          return; 
        } 
        const set=JSON.parse(raw); 
        // Normalize legacy/new type fields
        set.type = iqSanitizeType(set.type, iqInferTypeFromLegacyTypes(set.types));
        iqState.set=set; 
        iqResetPerQuestionCooldowns();
        iqState.replaceCounts = set.replaceCounts || {}; 
        iqRenderQuestions(); 
        iqUpdateSavedChip(); 
        iqRevealSecondaryActions(); 
        iqUpdateActionsLayout(); 
        const savedPanel=$IQ('#iq-saved-panel'); 
        if(savedPanel) savedPanel.hidden=true; 
        // History panel selection highlight (standard panel uses .is-selected)
        document.querySelectorAll('.rf-history-item').forEach(el => {
          el.classList.toggle('is-selected', el.getAttribute('data-session-id') === id);
        });
        window.scrollTo({top:0,behavior:'smooth'}); 
        iqToast('Loaded previous set'); 
        iqTrack('iq_recent_loaded',{ id }); 
      }catch(e){ 
        console.warn('load set failed',e); 
        iqToast('Could not load set'); 
      } 
    }

    // Cooldowns
    function iqStartGlobalCooldown(sec=IQ_GLOBAL_COOLDOWN){
      iqState.cooldown = sec;
      const g = $IQ('#btn-generate'); 
      const mi=$IQ('#mi-new-set');
      
      if (g) { 
        g.disabled = true; 
        g.setAttribute('aria-disabled','true'); 
        g.classList.add('is-disabled');
        g.textContent = iqState.set ? 'New Question Set' : 'Generate 10 Questions';
        iqUpdateGenerateButtonState();
      }
      if (mi) { mi.disabled = true; mi.setAttribute('aria-disabled','true'); }
      renderGenerateCooldownIndicator();
      
      clearInterval(iqState.timers.global);
      iqState.timers.global = setInterval(()=>{
        iqState.cooldown--;
        renderGenerateCooldownIndicator();
        
        if (iqState.cooldown<=0) { 
          clearInterval(iqState.timers.global); 
          if (g) { 
            g.disabled = false; 
            g.removeAttribute('aria-disabled'); 
            g.classList.remove('is-disabled'); 
            g.textContent = iqState.set ? 'New Question Set' : 'Generate 10 Questions';
            iqUpdateGenerateButtonState();
          } 
          if (mi) { 
            mi.disabled = false; 
            mi.removeAttribute('aria-disabled'); 
          } 
          renderGenerateCooldownIndicator();
        }
      }, 1000);
    }
    function iqResetPerQuestionCooldowns() {
      Object.values(iqState.timers.perQ).forEach(clearInterval);
      iqState.timers.perQ = {};
      iqState.replaceCooldowns = {};
      if (iqState.timers.replaceGlobal) {
        clearInterval(iqState.timers.replaceGlobal);
      }
      iqState.replaceGlobalCooldown = 0;
    }

    function iqUpdateReplaceCooldown(i, seconds) {
      if (!iqState.replaceCooldowns) iqState.replaceCooldowns = {};
      if (seconds > 0) {
        iqState.replaceCooldowns[i] = seconds;
      } else {
        delete iqState.replaceCooldowns[i];
      }
      iqRenderQuestions();
    }

    function iqStartReplaceGlobalCooldown(seconds) {
      // Enforce backend's user-level replace cooldown key on the client
      // Use provided seconds (e.g., from server retryAfter) or default to IQ_PER_Q_REPLACE_COOLDOWN
      iqState.replaceGlobalCooldown = seconds !== undefined ? seconds : IQ_PER_Q_REPLACE_COOLDOWN;
      if (iqState.timers.replaceGlobal) {
        clearInterval(iqState.timers.replaceGlobal);
      }
      const tick = () => {
        iqRenderQuestions();
        if (iqState.replaceGlobalCooldown <= 0) {
          iqState.replaceGlobalCooldown = 0;
          clearInterval(iqState.timers.replaceGlobal);
          return;
        }
        iqState.replaceGlobalCooldown -= 1;
      };
      tick();
      iqState.timers.replaceGlobal = setInterval(tick, 1000);
    }

    function iqStartPerQCooldown(i){
      const k = `q${i}`;
      clearInterval(iqState.timers.perQ[k]);
      let remaining = IQ_PER_Q_REPLACE_COOLDOWN;

      const cleanup = () => {
        clearInterval(iqState.timers.perQ[k]);
        delete iqState.timers.perQ[k];
        iqUpdateReplaceCooldown(i, 0);
      };

      const tick = () => {
        iqUpdateReplaceCooldown(i, remaining);
        const btn = $IQ(`.btn-replace[data-idx="${i}"]`);
        if (btn) {
          btn.disabled = true;
          btn.setAttribute('aria-disabled', 'true');
        }
        remaining -= 1;
        if (remaining < 0) {
          cleanup();
        }
      };

      tick();
      iqState.timers.perQ[k] = setInterval(tick, 1000);
      iqStartReplaceGlobalCooldown();
    }

    function formatCooldownSeconds(seconds) {
      if (typeof seconds !== 'number' || seconds <= 0) return '0s';
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      if (minutes > 0) {
        return `${minutes}:${String(secs).padStart(2, '0')}`;
      }
      return `${secs}s`;
    }

    function renderGenerateCooldownIndicator() {
      const container = $IQ('#iq-generate-cooldown');
      if (!container) return;
      container.innerHTML = '';
      if (iqState.cooldown <= 0) return;
      const chip = document.createElement('span');
      chip.className = 'iq-global-cooldown-chip';
      chip.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <circle cx="12" cy="12" r="10"/>
          <path d="M12 6v6l4 2"/>
        </svg>
        ${formatCooldownSeconds(iqState.cooldown)} cooldown
      `;
      container.appendChild(chip);
      const helper = document.createElement('div');
      helper.className = 'cta-hint';
      helper.textContent = 'You can still replace individual questions while this cooldown runs.';
      container.appendChild(helper);
    }

    // Update generate button state based on role input and cooldown
    function iqUpdateGenerateButtonState() {
      const genBtn = $IQ('#btn-generate');
      const roleInput = $IQ('#iq-role');
      
      if (!genBtn || !roleInput) return;
      
      const hasRole = roleInput.value.trim().length > 0;
      
      if (!hasRole) {
        genBtn.disabled = true;
        genBtn.setAttribute('aria-disabled', 'true');
        genBtn.style.opacity = '0.5';
        genBtn.style.cursor = 'not-allowed';
      } else {
        // Only enable if not in cooldown and daily limit not reached
        if (iqState.cooldown <= 0 && !iqState.dailyLimitReached) {
          genBtn.disabled = false;
          genBtn.removeAttribute('aria-disabled');
          genBtn.style.opacity = '1';
          genBtn.style.cursor = 'pointer';
        } else {
          // Role is selected but button should remain disabled (cooldown or daily limit)
          // Apply disabled styling to override any previous enabled state
          genBtn.disabled = true;
          genBtn.setAttribute('aria-disabled', 'true');
          genBtn.style.opacity = '0.5';
          genBtn.style.cursor = 'not-allowed';
        }
      }
    }

    // Helper function to get valid questions (filters out invalid ones)
    function iqGetValidQuestions() {
      if (!iqState.set || !Array.isArray(iqState.set.questions)) {
        return [];
      }
      return iqState.set.questions.filter(question => 
        question && 
        typeof question.q === 'string' && 
        question.q.trim().length > 0
      );
    }

    // Rendering
    function iqRenderQuestions(){
      const list=$IQ('#iq-questions'); const show=iqState.prefs.showGuidance; 
      if(!iqState.set){ 
        if(list) {
          list.innerHTML='<div class="iq-empty-state"><strong>Get Started</strong>Choose a role and question types, then generate 10 questions to get started.</div>';
        }
        return; 
      }
      if (!list) return;
      
      // Type safety: validate questions is an array
      if (!Array.isArray(iqState.set.questions)) {
        console.error('[IQ] Invalid questions array:', iqState.set.questions);
        if (list) {
          list.innerHTML = '<div class="iq-question-card" style="text-align:center; color:#DC2626;">Invalid data. Please generate a new set.</div>';
        }
        return;
      }
      
      // Filter out invalid questions (missing, empty, or invalid q property)
      const validQuestions = iqState.set.questions
        .map((q, originalIndex) => ({ question: q, originalIndex }))
        .filter(({ question }) => 
          question && 
          typeof question.q === 'string' && 
          question.q.trim().length > 0
        );
      
      // If all questions are invalid, show error state
      if (validQuestions.length === 0) {
        list.innerHTML = '<div class="iq-question-card" style="text-align:center; color:#DC2626; padding:2rem;">We couldn\'t generate this set of questions. Please try again.</div>';
        return;
      }
      
      // Render valid questions, preserving original indices for starred questions
      list.innerHTML = validQuestions.map(({ question: q, originalIndex: origIdx }, displayIdx)=>{
        const qText = iqEsc(q.q);
        const qHint = q.hint ? `Hint: ${iqEsc(q.hint)}` : '';
        const qExample = q.example ? iqEsc(q.example) : '';
        // Use original index for starred questions lookup
        const savedPressed = (typeof iqIsSaved === 'function' ? (iqIsSaved(origIdx) ? 'true' : 'false') : 'false');
        const replaceCount = (iqState.replaceCounts && iqState.replaceCounts[origIdx]) || 0;
        const replaceCooldown = (iqState.replaceCooldowns && iqState.replaceCooldowns[origIdx]) || 0;
        const replaceGlobalCooldown = iqState.replaceGlobalCooldown || 0;
        const hasDailyLimit = iqState.dailyLimitReached;
        const hasMaxReplacements = replaceCount >= IQ_MAX_REPLACES;
        const hasActiveCooldown = replaceCooldown > 0;
        const hasGlobalReplaceCooldown = replaceGlobalCooldown > 0;
        // Replacements are free and don't count toward daily limit, so hasDailyLimit is excluded
        const replaceDisabled = hasMaxReplacements || hasActiveCooldown || hasGlobalReplaceCooldown;
        const replaceTip = hasGlobalReplaceCooldown
            ? `Please wait ${replaceGlobalCooldown}s before replacing another question.`
            : hasActiveCooldown
              ? `Please wait ${replaceCooldown}s before replacing this question.`
              : hasMaxReplacements
                ? 'Max replacements reached for this question. Generate a new set if you\'re still not happy.'
                : 'New Question';
        const replaceCooldownBadge = replaceCooldown > 0 ? `<span class="iq-replace-cooldown" data-idx="${origIdx}">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <circle cx="12" cy="12" r="10"/>
          <path d="M12 6v6l4 2"/>
        </svg>
        ${replaceCooldown}s
      </span>` : '';
        return `<div class="iq-question-card" data-idx="${origIdx}" data-display-idx="${displayIdx}">
  <div class="iq-qtext">${displayIdx+1}. ${qText}</div>
  <div class="iq-qactions" aria-label="Question actions">
    <button type="button" class="icon-btn btn-copy" data-idx="${origIdx}" data-tip="Copy" aria-label="Copy">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="8" y="8" width="12" height="12" rx="2"/><rect x="4" y="4" width="12" height="12" rx="2"/></svg>
    </button>
    <button type="button" class="icon-btn btn-replace" data-idx="${origIdx}" data-tip="${replaceTip}" aria-label="New Question" ${replaceDisabled ? 'disabled aria-disabled="true"' : ''}>
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 12a9 9 0 0 1 14.9-6.9"/>
        <path d="M18 5v4h-4"/>
        <path d="M21 12a9 9 0 0 1-14.9 6.9"/>
        <path d="M6 19v-4h4"/>
      </svg>
    </button>
    <button type="button" class="icon-btn btn-save" data-idx="${origIdx}" data-tip="Star to include this question in your Mock Interview" aria-label="Star to include in Mock Interview" aria-pressed="${savedPressed}">
      <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"/></svg>
    </button>
    ${replaceCooldownBadge}
  </div>
  <div class="iq-hint" ${show?'':'hidden'}>${qHint} ${q.example?`<button class="link-btn btn-example" data-idx="${origIdx}">Example</button>`:''}</div>
  <div id="iq-example-${origIdx}" class="iq-example" hidden>${qExample}</div>
</div>`;
      }).join('');
      
      // If daily limit was reached, ensure all buttons remain disabled after re-render
      if (iqState.dailyLimitReached) {
        iqDisableAllButtons();
      }
    }
    // =======================================================
    // Interview Questions History (D1-backed)
    // UI/UX matches Resume Feedback History panel
    // Source of truth: D1 database (interview_question_sets table)
    // localStorage used only as cache/fallback
    // =======================================================
    let _iqHistoryManageMode = false;
    let _iqHistorySelectedIds = new Set();
    let _iqHistoryPendingDeleteIds = [];
    let _iqHistoryMenuOpenForId = null;
    let _iqHistoryHasError = false;
    let _iqHistoryWired = false;

    function iqHistoryEscapeHtml(str) {
      return String(str ?? '')
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function iqHistoryGetVisibleItems(items) {
      return (items || []).slice(0, IQ_RECENT_LIMIT);
    }

    function iqHistoryGetVisibleIds(items) {
      return iqHistoryGetVisibleItems(items)
        .map((x) => String(x?.id || ''))
        .filter(Boolean);
    }

    function iqHistorySetLoading(isLoading) {
      const loadingEl = document.getElementById('iq-history-loading');
      if (!loadingEl) return;
      loadingEl.classList.toggle('is-visible', !!isLoading);
    }

    function iqHistorySetErrorVisible(isVisible, message) {
      const errEl = document.getElementById('iq-history-error');
      if (!errEl) return;
      const textEl = errEl.querySelector('span[data-default-message]') || errEl.querySelector('span');
      if (textEl) {
        if (message) {
          textEl.textContent = message;
        } else if (textEl.dataset.defaultMessage) {
          textEl.textContent = textEl.dataset.defaultMessage;
        }
      }
      errEl.hidden = !isVisible;
      _iqHistoryHasError = isVisible;
    }

    function iqHistorySyncBulkDeleteState() {
      const btn = document.getElementById('iq-history-delete-selected');
      if (!btn) return;
      btn.disabled = _iqHistorySelectedIds.size < 1;
    }

    function iqHistoryCloseAllMenus() {
      const listEl = document.getElementById('iq-history-list');
      if (!listEl) return;
      listEl.querySelectorAll('.rf-history-menu').forEach((menu) => {
        menu.hidden = true;
      });
      _iqHistoryMenuOpenForId = null;
    }

    function iqHistoryOpenDeleteModalFor(ids) {
      const unique = Array.from(new Set((ids || []).map(String).filter(Boolean)));
      if (!unique.length) {
        _iqHistoryPendingDeleteIds = [];
        return; 
      } 
      _iqHistoryPendingDeleteIds = unique;
      const backdrop = document.getElementById('iq-history-modal-backdrop');
      const modal = document.getElementById('iq-history-delete-modal');
      const cancelBtn = document.getElementById('iq-history-modal-cancel');
      if (backdrop) backdrop.hidden = false;
      if (modal) modal.hidden = false;
      setTimeout(() => cancelBtn?.focus?.(), 0);
    }

    function iqHistoryCloseDeleteModal() {
      const backdrop = document.getElementById('iq-history-modal-backdrop');
      const modal = document.getElementById('iq-history-delete-modal');
      if (backdrop) backdrop.hidden = true;
      if (modal) modal.hidden = true;
      _iqHistoryPendingDeleteIds = [];
    }

    function iqHistorySetManageMode(next, itemsForRender) {
      const panel = document.getElementById('iq-history-panel');
      const titleEl = document.getElementById('iq-history-header-title');
      _iqHistoryManageMode = !!next;
      if (panel) panel.classList.toggle('rf-history-panel--manage', _iqHistoryManageMode);
      if (titleEl) titleEl.textContent = _iqHistoryManageMode ? 'Select items' : 'History';
      if (!_iqHistoryManageMode) {
        _iqHistorySelectedIds.clear();
        _iqHistoryMenuOpenForId = null;
        iqHistoryCloseAllMenus();
      }
      iqHistorySyncBulkDeleteState();
      // Handle async load - if itemsForRender provided, use it; otherwise load async
      if (itemsForRender) {
        iqHistoryRenderItems(itemsForRender);
      } else {
        iqHistoryLoadItems().then(items => iqHistoryRenderItems(items)).catch(() => {
          iqHistoryRenderItems([]);
        });
      }
    }

    function iqHistoryFormatRelativeTime(ts) {
      if (!ts) return 'â€”';
      const d = new Date(ts);
      const n = d.getTime();
      if (!Number.isFinite(n)) return 'â€”';
      const diffMs = Date.now() - n;
      if (diffMs < 30 * 1000) return 'just now';
      const diffMin = Math.floor(diffMs / (60 * 1000));
      if (diffMin < 60) return `${diffMin}m ago`;
      const diffHr = Math.floor(diffMin / 60);
      if (diffHr < 24) return `${diffHr}h ago`;
      const diffDay = Math.floor(diffHr / 24);
      if (diffDay < 14) return `${diffDay}d ago`;
      try {
        return new Date(n).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      } catch {
        return 'â€”';
      }
    }

    async function iqHistoryLoadItems() {
      // Try to fetch from D1 API first (source of truth)
      try {
        const token = await getFirebaseToken();
        if (token) {
          const response = await fetch(`${IQ_API.HISTORY}?limit=10`, {
            method: 'GET',
            headers: {
              'Authorization': `Bearer ${token}`
            }
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.items && Array.isArray(data.items)) {
              // Save to localStorage as cache
              try {
                localStorage.setItem('iq_recent_sets', JSON.stringify(data.items));
              } catch (e) {
                console.warn('[IQ-HISTORY] Failed to cache history:', e);
              }
              
              // Transform to match expected format
              const formatted = data.items.map((x) => ({
                id: String(x?.id || ''),
                role: String(x?.role || ''),
                count: Number(x?.count || 0),
                time: x?.time
              })).filter((x) => x.id);
              
              return formatted;
            }
          } else {
            console.warn('[IQ-HISTORY] API returned error:', response.status);
          }
        }
      } catch (e) {
        console.warn('[IQ-HISTORY] Failed to fetch from API, using localStorage fallback:', e);
      }
      
      // Fallback to localStorage cache
      try {
        const raw = localStorage.getItem('iq_recent_sets') || '[]';
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed
          .map((x) => ({
            id: String(x?.id || ''),
            role: String(x?.role || ''),
            count: Number(x?.count || 0),
            time: x?.time
          }))
          .filter((x) => x.id);
      } catch (e) {
        console.warn('[IQ-HISTORY] Failed to load history:', e);
        iqHistorySetErrorVisible(true);
        return [];
      }
    }

    function iqHistorySaveItems(items) {
      try {
        localStorage.setItem('iq_recent_sets', JSON.stringify(items || []));
      } catch (e) {
        console.warn('[IQ-HISTORY] Failed to save history:', e);
      }
    }

    async function iqHistoryDeleteIds(ids) {
      const del = new Set((ids || []).map(String).filter(Boolean));
      if (!del.size) return;
      
      try {
        const items = await iqHistoryLoadItems();
        const next = items.filter((x) => !del.has(String(x.id)));
        iqHistorySaveItems(next);
        // Best-effort cleanup of stored full payloads
        del.forEach((id) => {
          try { localStorage.removeItem(`iq_set_${id}`); } catch {}
        });
        // Exit manage mode after deletion
        _iqHistorySelectedIds.clear();
        iqHistorySyncBulkDeleteState();
        iqHistoryRenderItems(next);
      } catch (e) {
        console.warn('[IQ-HISTORY] Failed to delete items:', e);
        // Fallback: try localStorage-only deletion
        try {
          const raw = localStorage.getItem('iq_recent_sets') || '[]';
          const parsed = JSON.parse(raw);
          const next = parsed.filter((x) => !del.has(String(x?.id)));
          iqHistorySaveItems(next);
          _iqHistorySelectedIds.clear();
          iqHistorySyncBulkDeleteState();
          iqHistoryRenderItems(next.map(x => ({
            id: String(x?.id || ''),
            role: String(x?.role || ''),
            count: Number(x?.count || 0),
            time: x?.time
          })));
        } catch (e2) {
          console.error('[IQ-HISTORY] Failed to delete from localStorage:', e2);
        }
      }
    }

    function iqHistoryRenderItems(items) {
      const listEl = document.getElementById('iq-history-list');
      const emptyEl = document.getElementById('iq-history-empty');
      if (!listEl) return;

      iqHistorySetLoading(false);

      if (!items || items.length === 0) {
        listEl.innerHTML = '';
        if (emptyEl) emptyEl.hidden = _iqHistoryHasError ? true : false;
        return;
      }

      if (emptyEl) emptyEl.hidden = true;

      const visible = iqHistoryGetVisibleItems(items);
      let currentId = null;
      try {
        if (iqState?.set?.role && iqState?.set?.seed) {
          currentId = String(iqSetId(iqState.set.role, iqState.set.seed));
        }
      } catch {}

      listEl.innerHTML = visible.map((item) => {
        const id = String(item?.id || '');
        const roleName = String(item?.role || '').trim() || 'Untitled role';
        const when = iqHistoryFormatRelativeTime(item?.time);
        const count = Number.isFinite(Number(item?.count)) ? Number(item.count) : 0;
        const isCurrent = !_iqHistoryManageMode && currentId && currentId === id;
        const isSelected = isCurrent ? 'is-selected' : '';
        const isChecked = _iqHistorySelectedIds.has(id);
        const menuHidden = _iqHistoryMenuOpenForId !== id;

        return `
          <div class="rf-history-item ${isSelected}" data-session-id="${iqHistoryEscapeHtml(id)}" tabindex="0" data-history-row>
            <span class="rf-history-checkbox-wrap" aria-hidden="${_iqHistoryManageMode ? 'false' : 'true'}">
              <input
                class="rf-history-checkbox"
                type="checkbox"
                data-action="toggle-select"
                data-session-id="${iqHistoryEscapeHtml(id)}"
                aria-label="Select ${iqHistoryEscapeHtml(roleName)}"
                ${isChecked ? 'checked' : ''}
              />
            </span>

            <div class="rf-history-icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                <path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/>
                <polyline points="14 2 14 8 20 8"/>
                <line x1="16" y1="13" x2="8" y2="13"/>
                <line x1="16" y1="17" x2="8" y2="17"/>
              </svg>
            </div>

            <div class="rf-history-text">
              <div class="rf-history-line1">${iqHistoryEscapeHtml(roleName)}</div>
              <div class="rf-history-line2">Question set â€¢ ${iqHistoryEscapeHtml(when)}</div>
            </div>

            <div class="rf-history-row-actions" aria-label="Row actions">
              <button
                class="rf-history-kebab"
                type="button"
                aria-label="Row actions"
                data-action="menu-toggle"
                data-session-id="${iqHistoryEscapeHtml(id)}"
              >
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                  <circle cx="5" cy="12" r="2"></circle>
                  <circle cx="12" cy="12" r="2"></circle>
                  <circle cx="19" cy="12" r="2"></circle>
                </svg>
              </button>
              <div class="rf-history-menu" role="menu" ${menuHidden ? 'hidden' : ''}>
                <button class="rf-history-menu-item" type="button" data-action="open" data-session-id="${iqHistoryEscapeHtml(id)}">Open / Restore</button>
                <button class="rf-history-menu-item rf-history-menu-item--danger" type="button" data-action="delete" data-session-id="${iqHistoryEscapeHtml(id)}">Delete</button>
              </div>
            </div>
          </div>
        `;
      }).join('');
    }

    // Backwards-compatible entry point: re-render the history panel
    async function iqRenderRecents(){
      const panel = document.getElementById('iq-history-panel');
      if (!panel) return;
      iqHistorySetErrorVisible(false);
      try {
        const items = await iqHistoryLoadItems();
        iqHistoryRenderItems(items);
      } catch (e) {
        console.warn('[IQ-HISTORY] Failed to render recents:', e);
        iqHistoryRenderItems([]);
      }
    }
    function iqUpdateGuidanceUI(){ const t=$IQ('#toggle-guidance'); if(t){ t.setAttribute('aria-pressed', String(iqState.prefs.showGuidance)); t.textContent = iqState.prefs.showGuidance ? 'Hide Answer Guidance' : 'Show Answer Guidance'; if(iqState.prefs.showGuidance){ t.classList.add('is-pressed'); } else { t.classList.remove('is-pressed'); } } iqRenderQuestions(); }
    // Backwards-compatible entry point: wire the new History panel interactions
    function iqWireRecents(){
      if (_iqHistoryWired) return;
      const panel = document.getElementById('iq-history-panel');
      const listEl = document.getElementById('iq-history-list');
      if (!panel || !listEl) return;
      _iqHistoryWired = true;

      const btnRefresh = document.getElementById('iq-history-refresh');
      const btnManage = document.getElementById('iq-history-manage');
      const btnCancel = document.getElementById('iq-history-cancel-manage');
      const btnDeleteSelected = document.getElementById('iq-history-delete-selected');
      const btnSelectAll = document.getElementById('iq-history-select-all');
      const btnClear = document.getElementById('iq-history-clear');
      const btnRetry = document.getElementById('iq-history-retry');
      const modalBackdrop = document.getElementById('iq-history-modal-backdrop');
      const modal = document.getElementById('iq-history-delete-modal');
      const modalCancel = document.getElementById('iq-history-modal-cancel');
      const modalConfirm = document.getElementById('iq-history-modal-confirm');

      async function refreshFromStorage(withSkeleton = false) {
        if (withSkeleton) iqHistorySetLoading(true);
        try {
          iqHistorySetErrorVisible(false);
          const items = await iqHistoryLoadItems();
          iqHistoryRenderItems(items);
        } catch (e) {
          console.warn('[IQ-HISTORY] Failed to refresh:', e);
          iqHistoryRenderItems([]);
        } finally {
          if (withSkeleton) iqHistorySetLoading(false);
        }
      }

      btnRefresh?.addEventListener('click', () => refreshFromStorage(true));
      btnRetry?.addEventListener('click', () => refreshFromStorage(true));

      btnManage?.addEventListener('click', async () => {
        try {
          const items = await iqHistoryLoadItems();
          iqHistorySetManageMode(true, items);
        } catch (e) {
          console.warn('[IQ-HISTORY] Failed to load items for manage mode:', e);
        }
      });
      btnCancel?.addEventListener('click', async () => {
        try {
          const items = await iqHistoryLoadItems();
          iqHistorySetManageMode(false, items);
        } catch (e) {
          console.warn('[IQ-HISTORY] Failed to load items for cancel:', e);
        }
      });

      btnSelectAll?.addEventListener('click', async () => {
        try {
          const items = await iqHistoryLoadItems();
          iqHistoryGetVisibleIds(items).forEach((id) => _iqHistorySelectedIds.add(id));
          iqHistorySyncBulkDeleteState();
          iqHistoryRenderItems(items);
        } catch (e) {
          console.warn('[IQ-HISTORY] Failed to load items for select all:', e);
        }
      });

      btnDeleteSelected?.addEventListener('click', () => {
        iqHistoryOpenDeleteModalFor(Array.from(_iqHistorySelectedIds));
      });

      btnClear?.addEventListener('click', async () => {
        try {
          const items = await iqHistoryLoadItems();
          iqHistorySetManageMode(true, items);
          iqHistoryGetVisibleIds(items).forEach((id) => _iqHistorySelectedIds.add(id));
          iqHistorySyncBulkDeleteState();
          iqHistoryRenderItems(items);
          iqHistoryOpenDeleteModalFor(Array.from(_iqHistorySelectedIds));
        } catch (e) {
          console.warn('[IQ-HISTORY] Failed to load items for clear:', e);
        }
      });

      // "Learn more" link - keep behavior consistent (no nav change requested)
      panel.querySelectorAll('[data-history-learn-more]').forEach((a) => {
        a.addEventListener('click', (e) => {
          e.preventDefault();
          // TODO: wire to canonical retention/help article when available.
          iqToast('Learn more coming soon.');
        });
      });

      function handleOpenRestore(id) {
        if (!id) return;
        iqHistoryCloseAllMenus();
        iqLoadSetById(String(id));
      }

      listEl.addEventListener('click', (e) => {
        const actionEl = e.target.closest('[data-action]');
        const rowEl = e.target.closest('.rf-history-item');
        const id = actionEl?.getAttribute('data-session-id') || rowEl?.getAttribute('data-session-id');

        if (actionEl) {
          const action = actionEl.getAttribute('data-action');
          if (action === 'toggle-select') {
            e.stopPropagation();
            const sid = String(actionEl.getAttribute('data-session-id') || '');
            if (!sid) return;
            if (_iqHistorySelectedIds.has(sid)) _iqHistorySelectedIds.delete(sid);
            else _iqHistorySelectedIds.add(sid);
            iqHistorySyncBulkDeleteState();
            // Keep list rendering stable (checkbox state + row selection rules)
            iqHistoryLoadItems().then(items => iqHistoryRenderItems(items)).catch(() => {
              // Fallback: re-render current items
              const currentItems = Array.from(document.querySelectorAll('.rf-history-item')).map(el => ({
                id: el.getAttribute('data-session-id'),
                role: el.querySelector('.rf-history-line1')?.textContent || '',
                count: 0,
                time: null
              })).filter(x => x.id);
              iqHistoryRenderItems(currentItems);
            });
            return;
          }
          if (action === 'menu-toggle') {
            e.stopPropagation();
            const sid = String(actionEl.getAttribute('data-session-id') || '');
            if (!sid) return;
            const isAlreadyOpen = _iqHistoryMenuOpenForId === sid;
            iqHistoryCloseAllMenus();
            if (!isAlreadyOpen) {
              _iqHistoryMenuOpenForId = sid;
              const menu = rowEl?.querySelector('.rf-history-menu');
              if (menu) menu.hidden = false;
            }
            return;
          }
          if (action === 'open') {
            e.stopPropagation();
            handleOpenRestore(id);
            return;
          }
          if (action === 'delete') {
            e.stopPropagation();
            iqHistoryOpenDeleteModalFor([id]);
            return;
          }
        }

        if (!rowEl || !id) return;
        if (_iqHistoryManageMode) {
          // Toggle selection on row click in manage mode
          if (_iqHistorySelectedIds.has(id)) _iqHistorySelectedIds.delete(id);
          else _iqHistorySelectedIds.add(id);
          iqHistorySyncBulkDeleteState();
          iqHistoryLoadItems().then(items => iqHistoryRenderItems(items)).catch(() => {
            // Fallback: re-render current items
            const currentItems = Array.from(document.querySelectorAll('.rf-history-item')).map(el => ({
              id: el.getAttribute('data-session-id'),
              role: el.querySelector('.rf-history-line1')?.textContent || '',
              count: 0,
              time: null
            })).filter(x => x.id);
            iqHistoryRenderItems(currentItems);
          });
          return;
        }

        handleOpenRestore(id);
      });

      listEl.addEventListener('keydown', (e) => {
        if (e.key !== 'Enter' && e.key !== ' ') return;
        const rowEl = e.target.closest('.rf-history-item');
        if (!rowEl) return;
        e.preventDefault();
        const id = rowEl.getAttribute('data-session-id');
        if (!id) return;
        if (_iqHistoryManageMode) {
          if (_iqHistorySelectedIds.has(id)) _iqHistorySelectedIds.delete(id);
          else _iqHistorySelectedIds.add(id);
          iqHistorySyncBulkDeleteState();
          iqHistoryLoadItems().then(items => iqHistoryRenderItems(items)).catch(() => {
            // Fallback: re-render current items
            const currentItems = Array.from(document.querySelectorAll('.rf-history-item')).map(el => ({
              id: el.getAttribute('data-session-id'),
              role: el.querySelector('.rf-history-line1')?.textContent || '',
              count: 0,
              time: null
            })).filter(x => x.id);
            iqHistoryRenderItems(currentItems);
          });
          return;
        }
        handleOpenRestore(id);
      });

      // Close menus when clicking outside
      document.addEventListener('click', (e) => {
        if (e.target.closest('#iq-history-panel')) return;
        iqHistoryCloseAllMenus();
      });

      // Modal interactions
      modalCancel?.addEventListener('click', iqHistoryCloseDeleteModal);
      modalBackdrop?.addEventListener('click', iqHistoryCloseDeleteModal);
      modalConfirm?.addEventListener('click', async () => {
        const ids = Array.from(_iqHistoryPendingDeleteIds || []).map(String).filter(Boolean);
        iqHistoryCloseDeleteModal();
        if (!ids.length) return;
        await iqHistoryDeleteIds(ids);
        // Exit manage mode if we deleted everything visible
        if (_iqHistoryManageMode) {
          try {
            const remaining = await iqHistoryLoadItems();
            if (!remaining.length) {
              iqHistorySetManageMode(false, remaining);
            } else {
              // Keep manage mode, but clear selection
              _iqHistorySelectedIds.clear();
              iqHistorySyncBulkDeleteState();
              iqHistoryRenderItems(remaining);
            }
          } catch (e) {
            console.warn('[IQ-HISTORY] Failed to check remaining items:', e);
          }
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key !== 'Escape') return;
        if (modal && modal.hidden === false) {
          iqHistoryCloseDeleteModal();
        } else {
          iqHistoryCloseAllMenus();
        }
      });

      // Initial render (avoid skeleton flash after initIQPage already rendered once)
      refreshFromStorage(false);
    }

    // Initialize Role Selector for ARIA combobox
    function iqInitRoleCombobox(){
      const input = $IQ('#iq-role');
      const live = $IQ('#iq-live');
      if (!input) return;
      
      let roleSelectorInitAttempts = 0;
      const MAX_ROLE_SELECTOR_ATTEMPTS = 50;
      
      function announce(msg) {
        if (live) {
          live.textContent = msg;
        }
      }
      
      function initializeRoleSelector() {
        // Wait for RoleSelector class to be available
        if (window.RoleSelector) {
          try {
            if (!input.dataset.roleSelectorInitialized) {
              const roleSelector = new window.RoleSelector(input, {
                minChars: 2,
                maxResults: 8,
                showCustomOption: true,
                onSelect: function(roleName, isCustom) {
                  console.log('[INTERVIEW-Q] Role selected:', roleName, isCustom ? '(custom)' : '');
                  announce(`Selected: ${roleName}`);
                }
              });
              input.dataset.roleSelectorInitialized = 'true';
              console.log('[INTERVIEW-Q] RoleSelector initialized successfully');
            }
          } catch (error) {
            console.error('[INTERVIEW-Q] Failed to initialize RoleSelector:', error);
            if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
              roleSelectorInitAttempts++;
              setTimeout(initializeRoleSelector, 500);
            } else {
              console.warn('[INTERVIEW-Q] RoleSelector initialization failed after max attempts');
            }
          }
        } else {
          // RoleSelector not loaded yet, wait and retry
          if (roleSelectorInitAttempts < MAX_ROLE_SELECTOR_ATTEMPTS) {
            roleSelectorInitAttempts++;
            setTimeout(initializeRoleSelector, 200);
          } else {
            console.warn('[INTERVIEW-Q] RoleSelector not available after max attempts');
          }
        }
      }
      
      // Initialize role selector
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeRoleSelector);
      } else {
        setTimeout(initializeRoleSelector, 100);
      }
    }

    // API
    const IQ_FIXED_COUNT = 10;
    const IQ_API_TIMEOUT = 60000; // 60 seconds timeout for API requests
    
    // Helper function to add timeout to fetch requests
    function fetchWithTimeout(url, options, timeoutMs = IQ_API_TIMEOUT) {
      let timeoutId;
      const timeoutPromise = new Promise((_, reject) => {
        timeoutId = setTimeout(() => reject(new Error('Request timeout - the server took too long to respond. Please try again.')), timeoutMs);
      });
      
      const fetchPromise = fetch(url, options).finally(() => {
        // Clear timeout when fetch completes (success or failure)
        if (timeoutId) clearTimeout(timeoutId);
      });
      
      return Promise.race([fetchPromise, timeoutPromise]);
    }
    
    // Get Firebase auth token for API calls
    // Uses FirebaseAuthManager pattern (same as resume-feedback-pro.html)
    async function getFirebaseToken() {
      try {
        // Wait for Firebase auth to be ready
        if (window.FirebaseAuthManager && window.FirebaseAuthManager.waitForAuthReady) {
          await window.FirebaseAuthManager.waitForAuthReady(3000);
        }
        
        // Get Firebase ID token using FirebaseAuthManager
        if (window.FirebaseAuthManager && window.FirebaseAuthManager.getCurrentUser) {
          const user = window.FirebaseAuthManager.getCurrentUser();
          if (user) {
            return await user.getIdToken();
          }
        }
      } catch (e) {
        console.warn('[IQ] Failed to get Firebase token:', e);
      }
      return null;
    }
    
    async function iqApiGenerate({ role, seniority, type, count, jd }){ 
      iqTrack('iq_generate_clicked',{count: IQ_FIXED_COUNT,type: iqSanitizeType(type, iqState.prefs.type || 'mixed')}); 
      
      try {
        const token = await getFirebaseToken();
        if (!token) {
          // Not logged in - show explicit message and redirect
          iqToast('Please log in to generate AI-powered interview questions.');
          setTimeout(() => {
            window.location.href = 'login.html';
          }, 2000);
          throw new Error('Not authenticated');
        }
        
        const response = await fetchWithTimeout(IQ_API.GENERATE, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ role, seniority, type, jd })
        }, IQ_API_TIMEOUT);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          
          // Handle auth errors explicitly
          if (response.status === 401 || response.status === 403) {
            iqToast('Your session has expired. Please log in again to generate AI-powered questions.');
            setTimeout(() => {
              window.location.href = 'login.html';
            }, 2000);
            throw new Error('Authentication required');
          }
          
          // Handle cooldown
          if (response.status === 429 && errorData.reason === 'cooldown') {
            const retryAfter = errorData.retryAfter || (errorData.mode === 'replace' ? IQ_PER_Q_REPLACE_COOLDOWN : IQ_GLOBAL_COOLDOWN);
            const message = errorData.mode === 'replace'
              ? `Please wait ${retryAfter} seconds before replacing another question.`
              : `You're generating questions too quickly. Try again in ${retryAfter} seconds.`;
            iqToast(message);
            throw new Error('Cooldown active');
          }
          
          // Handle daily limit
          if (response.status === 429 && errorData.reason === 'daily_limit') {
            const planName = getUserPlan() === 'trial' ? 'Trial' : 
                           getUserPlan() === 'essential' ? 'Essential' :
                           getUserPlan() === 'pro' ? 'Pro' : 'Premium';
            iqToast(`Daily limit reached for your ${planName} plan. You can still practice with existing sets or upgrade for higher limits.`);
            // Disable all buttons (generate + replace) since daily quota applies to all operations
            iqDisableAllButtons();
            throw new Error('Daily limit reached');
          }
          
          // Other errors (5xx, etc.)
          throw new Error(errorData.error || `API error: ${response.status}`);
        }
        
        const data = await response.json();
        // Validate questions array is present and non-empty
        if (data.success && Array.isArray(data.questions) && data.questions.length > 0) {
          return {
            role: data.role,
            seniority: data.seniority,
            type: iqSanitizeType(data.type, iqInferTypeFromLegacyTypes(data.types)),
            count: data.count || IQ_FIXED_COUNT,
            seed: data.seed,
            jd: data.jd || '',
            questions: data.questions
          };
        }
        throw new Error('Invalid API response: questions array missing or empty');
      } catch (e) { 
        // Only fall back to stub if it's not an auth error
        if (e.message === 'Not authenticated' || e.message === 'Authentication required') {
          // Auth errors already handled above - don't fall back to stub
          return null;
        }
        
        // Daily limit errors already handled above - return special marker
        if (e.message === 'Daily limit reached') {
          return { dailyLimitReached: true };
        }
        
        // Handle network errors and timeouts
        if (e.message.includes('timeout') || e.message.includes('Timeout') || e.message.includes('Request timeout')) {
          console.error('[IQ] API request timeout:', {
            error: e.message,
            role,
            seniority,
            type
          });
          iqToast('The request took too long. Please check your connection and try again.');
          return null;
        }
        
        // Handle network errors (connection refused, failed to fetch, etc.)
        if (e.message.includes('Failed to fetch') || e.message.includes('NetworkError') || e.message.includes('network')) {
          console.error('[IQ] Network error:', {
            error: e.message,
            role,
            seniority,
            type
          });
          iqToast('Network error. Please check your internet connection and try again.');
          return null;
        }
        
        // Log error for monitoring
        console.error('[IQ] API generation failed:', {
          error: e.message,
          stack: e.stack,
          role,
          seniority,
          type
        });
        
        // Show error toast - no fallback to demo questions
        iqToast('We couldn\'t generate questions right now. Please try again in a moment.');
        return null;
      } 
    }
    
    // Save question set to D1 for Mock Interview
    async function iqApiSaveSet({ role, seniority, type, questions, selectedIndices, jd }) {
      try {
        const token = await getFirebaseToken();
        if (!token) {
          throw new Error('Not authenticated');
        }
        
        const response = await fetch(IQ_API.SAVE_SET, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ role, seniority, type, questions, selectedIndices, jd })
        });
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `API error: ${response.status}`);
        }
        
        const data = await response.json();
        if (data.success && data.id) {
          return { id: data.id, createdAt: data.createdAt };
        }
        throw new Error('Invalid API response');
      } catch (e) {
        console.error('[IQ] Save set failed:', e);
        throw e;
      }
    }

    // Actions
    async function iqGenerate(){ 
      if(iqState.cooldown>0){ iqToast('Please wait for cooldown'); return; } 
      const role=$IQ('#iq-role')?.value?.trim()||''; 
      if(!role){ iqToast('Select a role first'); return; } 
      const seniority=$IQ('#iq-seniority')?.value||''; 
      const count=IQ_FIXED_COUNT; 
      const activeTypeBtn = $IQ('#iq-type .iq-segment.active');
      const type = iqSanitizeType(activeTypeBtn?.dataset?.value, iqState.prefs.type || 'mixed');
      const jd=$IQ('#iq-jd')?.value?.trim()||''; 
      
      // Clear reset flag at start of new generation
      iqState._resetRequested = false;
      
      // Show skeleton loaders
      const holder=$IQ('#iq-questions'); 
      if(holder) holder.innerHTML=Array.from({length:5}).map(()=>'<div class="iq-question-card skeleton"></div>').join(''); 
      
      // Disable generate button during request
      const genBtn = $IQ('#btn-generate');
      const originalButtonText = genBtn ? genBtn.textContent : 'Generate 10 Questions';
      if (genBtn) {
        genBtn.disabled = true;
        genBtn.textContent = 'Generating...';
      }
      
      try {
        const res=await iqApiGenerate({role,seniority,type,count,jd}); 
        
        // If auth error occurred, iqApiGenerate returns null - don't proceed
        if (!res) {
          // Restore button state before returning (auth error handling)
          if (genBtn) {
            genBtn.disabled = false;
            genBtn.textContent = iqState.set ? 'New Question Set' : 'Generate 10 Questions';
            // Update button state to respect role requirement and styling
            iqUpdateGenerateButtonState();
          }
          // Clear skeleton loaders on error
          if (holder) {
            holder.innerHTML = '<div class="iq-empty-state"><strong>Get Started</strong>Choose a role and question types, then generate 10 questions to get started.</div>';
          }
          return;
        }
        
        // If daily limit reached, button should remain disabled - don't proceed
        if (res.dailyLimitReached) {
          // Clear skeleton loaders on daily limit
          if (holder) {
            holder.innerHTML = '<div class="iq-empty-state"><strong>Daily Limit Reached</strong><p>You\'ve reached today\'s limit for generating new sets. You can still practice with existing sets or upgrade for higher limits.</p></div>';
          }
          return;
        }
        
        // Check if reset was requested while request was in flight (prevents race condition)
        if (iqState._resetRequested) {
          // User clicked "Start Fresh" while this request was in flight, ignore this response
          console.log('[IQ] Generation cancelled - reset was requested');
          // Restore button state
          if (genBtn) {
            genBtn.disabled = false;
            genBtn.textContent = 'Generate 10 Questions';
            iqUpdateGenerateButtonState();
          }
          // Clear skeleton loaders
          if (holder) {
            holder.innerHTML = '<div class="iq-empty-state"><strong>Get Started</strong>Choose a role and question types, then generate 10 questions to get started.</div>';
          }
          return;
        }
        
        // Validate response has questions
        if (!Array.isArray(res.questions) || res.questions.length === 0) {
          throw new Error('No questions generated');
        }
        
        const seed = res.seed || `${Date.now().toString(36)}-${Math.random().toString(36).slice(2,8)}`; 
        const setObj={...res, seed, role: res.role||role, seniority, count: IQ_FIXED_COUNT, type: iqSanitizeType(res.type, type), jd, replacesUsed:0}; 
        
        // Check again before setting state (double-check to prevent race condition)
        if (iqState._resetRequested) {
          console.log('[IQ] Generation cancelled - reset was requested before setting state');
          if (genBtn) {
            genBtn.disabled = false;
            genBtn.textContent = 'Generate 10 Questions';
            iqUpdateGenerateButtonState();
          }
          if (holder) {
            holder.innerHTML = '<div class="iq-empty-state"><strong>Get Started</strong>Choose a role and question types, then generate 10 questions to get started.</div>';
          }
          return;
        }
        
        iqState.set=setObj;
        // Clear reset flag since we successfully set the new state
        iqState._resetRequested = false;
        iqResetPerQuestionCooldowns();
        // Reset replace counts when generating a new set
        iqState.replaceCounts = {}; 
        // Reset daily limit flag on successful generation
        iqState.dailyLimitReached = false;
        // Note: Don't call iqUpdateGenerateButtonState() here - it's redundant
        // because iqStartGlobalCooldown() will call it after properly setting the cooldown
        iqState.prefs={...iqState.prefs,seniority,count: IQ_FIXED_COUNT,type: iqSanitizeType(res.type, type)}; 
        iqSavePrefs(); 
        iqRenderQuestions(); 
        iqUpdateSavedChip(); 
        
        // Save to localStorage (for backward compatibility and offline access)
        const setId=iqSetId(setObj.role,setObj.seed); 
        iqAddRecent({ id: setId, role: setObj.role, count: setObj.count||IQ_FIXED_COUNT, time: iqNow() }); 
        iqSaveSetFull(setObj);
        
        // Save to D1 for persistent history (non-blocking)
        iqSaveSetToD1(setObj).then((savedSet) => {
          if (savedSet) {
            // Update localStorage with D1 ID for reference
            try {
              const recents = JSON.parse(localStorage.getItem('iq_recent_sets') || '[]');
              const updated = recents.map(item => 
                item.id === setId ? { ...item, d1Id: savedSet.id } : item
              );
              localStorage.setItem('iq_recent_sets', JSON.stringify(updated));
            } catch (e) {
              console.warn('[IQ] Failed to update localStorage with D1 ID:', e);
            }
          }
          // Refresh history from D1
          iqRenderRecents();
        }).catch(() => {
          // Still render recents even if D1 save failed
          iqRenderRecents();
        });
        
        // Update action bar, selection summary, and Start Fresh button state
        // (iqUpdateActionsLayout() handles all of this and calls updateStartFreshButtonState())
        iqUpdateActionsLayout();
      iqStartGlobalCooldown(IQ_GLOBAL_COOLDOWN);
        
        // Refresh usage counter after successful generation with retry logic
        // This ensures the counter updates even if DB write hasn't propagated yet
        const refreshUsageCounter = async (retries = 3, delay = 1000) => {
          const currentPlan = getUserPlan();
          if (!currentPlan) {
            return;
          }
          
          try {
            await updatePlanUI(currentPlan);
            
            // Check if counter actually updated by verifying the usage container has content
            const usageContainer = document.getElementById('iq-usage-container');
            if (usageContainer && usageContainer.textContent.includes('Sets generated')) {
              // Counter updated successfully, no need to retry
              return;
            }
            
            // If counter didn't update and we have retries left, try again
            if (retries > 0) {
              console.log(`[IQ] Usage counter refresh retry (${retries} attempts remaining)`);
              setTimeout(() => refreshUsageCounter(retries - 1, delay), delay);
            } else {
              console.warn('[IQ] Usage counter refresh failed after all retries');
            }
          } catch (error) {
            console.error('[IQ] Error refreshing usage counter:', error);
            // Retry on error if we have attempts left
            if (retries > 0) {
              setTimeout(() => refreshUsageCounter(retries - 1, delay), delay);
            }
          }
        };
        
        // Initial refresh with delay to allow DB write to complete
        setTimeout(() => refreshUsageCounter(), 1000);
        
      } catch (error) {
        console.error('[IQ] Generate error:', error);
        
        // Check if reset was requested during error handling
        if (iqState._resetRequested) {
          // User clicked "Start Fresh" while this request was in flight, ignore this error
          console.log('[IQ] Generation error ignored - reset was requested');
          return;
        }
        
        // Show user-friendly error message
        if(holder) {
          const errorMessage = error.message && error.message.includes('timeout') 
            ? 'The request took too long. Please check your connection and try again.'
            : error.message && error.message.includes('network')
            ? 'Network error. Please check your internet connection and try again.'
            : 'Something went wrong generating questions. Please try again.';
          holder.innerHTML = `<div class="iq-question-card" style="text-align:center; color:#DC2626; padding:2rem;">${errorMessage}</div>`;
        }
        iqToast('Generation failed. Please try again.');
        // Always re-enable button on error (cooldown not started)
        // Note: On success, button remains disabled during cooldown (handled by iqStartGlobalCooldown)
        if (genBtn) {
          genBtn.disabled = false;
          genBtn.textContent = iqState.set ? 'New Question Set' : 'Generate 10 Questions';
          // Update button state to respect role requirement
          iqUpdateGenerateButtonState();
        }
      }
    }
    
    // Update selection summary display
    function iqUpdateSelectionSummary() {
      const summary = $IQ('#iq-selection-summary');
      const countText = $IQ('#selection-count-text');
      if (!summary || !countText) return;
      
      // Use iqGetSavedItems() to get count of valid saved questions (filters out invalid ones)
      const selectedCount = iqGetSavedItems().length;
      // Use count of valid questions (same as what's displayed to user)
      const validQuestions = iqGetValidQuestions();
      const totalCount = validQuestions.length || IQ_FIXED_COUNT;
      
      if (selectedCount === 0) {
        summary.classList.add('no-selection');
        countText.textContent = `No questions selected for Mock Interview (star â­ to select)`;
      } else {
        summary.classList.remove('no-selection');
        countText.textContent = `Selected for Mock Interview: ${selectedCount} of ${totalCount} questions`;
      }
    }
    async function iqRegenerate(){ if(iqState.cooldown>0){ iqToast('Please wait for cooldown'); return; } await iqGenerate(); iqTrack('iq_new_set_clicked'); }
    async function iqReplaceOne(i){
      if(!iqState.set || !Array.isArray(iqState.set.questions)) return;
      const set = iqState.set;
      const role = set.role || ($IQ('#iq-role')?.value?.trim()||'');
      const seniority = set.seniority || iqState.prefs.seniority || '';
      const type = iqSanitizeType(set.type, iqState.prefs.type || 'mixed');
      const jd = set.jd || $IQ('#iq-jd')?.value || '';

      // Check per-question replace limit (TASK 10B)
      const replaceCount = (iqState.replaceCounts && iqState.replaceCounts[i]) || 0;
      if (replaceCount >= IQ_MAX_REPLACES) {
        iqToast('You\'ve replaced this question several times. Generate a new set if you\'re still not happy.');
        return;
      }

      // Get and disable the replace button immediately to prevent concurrent requests
      const replaceBtn = $IQ(`.btn-replace[data-idx="${i}"]`);
      const wasDisabled = replaceBtn?.disabled || false;
      if (replaceBtn) {
        replaceBtn.disabled = true;
        replaceBtn.setAttribute('aria-disabled', 'true');
      }

      // Helper function to re-enable the button
      // Replacements are free and don't count toward daily limit, so they can always be enabled
      const reenableButton = () => {
        if (replaceBtn) {
          replaceBtn.disabled = wasDisabled;
          if (!wasDisabled) {
            replaceBtn.removeAttribute('aria-disabled');
          }
        }
      };

      try {
        const token = await getFirebaseToken();
        if (!token) {
          iqToast('Please log in to replace questions.');
          setTimeout(() => {
            window.location.href = 'login.html';
          }, 2000);
          reenableButton();
          return;
        }

        const response = await fetchWithTimeout(IQ_API.GENERATE, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ 
            role, 
            seniority, 
            type, 
            jd,
            mode: 'replace',
            replaceIndex: i
          })
        }, IQ_API_TIMEOUT);

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          
          // Handle cooldown
          if (response.status === 429 && errorData.reason === 'cooldown') {
            const retryAfter = errorData.retryAfter || IQ_PER_Q_REPLACE_COOLDOWN;
            iqToast(`Please wait ${retryAfter} seconds before replacing another question.`);
            // Start global replace cooldown to prevent rapid re-clicks and match backend enforcement
            // Use server's retryAfter value to sync UI with actual remaining cooldown time
            iqStartReplaceGlobalCooldown(retryAfter);
            // Don't re-enable button - it will be enabled when cooldown expires via render logic
            return;
          }
          
          // Handle daily limit
          if (response.status === 429 && errorData.reason === 'daily_limit') {
            const planName = getUserPlan() === 'trial' ? 'Trial' : 
                           getUserPlan() === 'essential' ? 'Essential' :
                           getUserPlan() === 'pro' ? 'Pro' : 'Premium';
            iqToast(`Daily limit reached for your ${planName} plan. You can still practice with existing sets or upgrade for higher limits.`);
            // Disable all buttons (generate + replace) since daily quota applies to all operations
            iqDisableAllButtons();
            // Don't re-enable this button since all buttons are disabled
            return;
          }
          
          // Handle auth errors
          if (response.status === 401) {
            iqToast('Your session has expired. Please log in again.');
            setTimeout(() => {
              window.location.href = 'login.html';
            }, 2000);
            reenableButton();
            return;
          }

          // Handle 403 errors (not always auth-related)
          // Examples:
          // - Plan gating (upgradeRequired)
          // - Replace attempted without generating a new set today
          if (response.status === 403) {
            const msg = (errorData && (errorData.error || errorData.message)) || 'Action not allowed.';
            if (errorData && errorData.upgradeRequired) {
              iqToast(msg);
            } else {
              // Show the server-provided message so users understand what to do next.
              iqToast(msg);
            }
            reenableButton();
            return;
          }
          
          // Other errors
          throw new Error(errorData.error || `API error: ${response.status}`);
        }

        const data = await response.json();
        if (data.success && Array.isArray(data.questions) && data.questions.length > 0) {
          // Replace the question at index i with the new question
          const newQuestion = data.questions[0];
          set.questions[i] = { 
            q: newQuestion.q, 
            hint: newQuestion.hint || set.questions[i]?.hint || '', 
            example: newQuestion.example || set.questions[i]?.example || '' 
          };
          
          // Increment replace count for this question
          if (!iqState.replaceCounts) iqState.replaceCounts = {};
          iqState.replaceCounts[i] = (iqState.replaceCounts[i] || 0) + 1;
          
          // Persist the replaced question and replaceCounts to localStorage
          iqSaveSetFull(set);
          
          // Reset daily limit flag on successful replace
          iqState.dailyLimitReached = false;
          
          iqRenderQuestions();
          iqToast('Question replaced.');
          iqTrack('iq_replace_one', { index: i });
          
          // Start per-question cooldown (with global replace cooldown enforcement)
          iqStartPerQCooldown(i);
        } else {
          reenableButton();
          throw new Error('Invalid API response: no question returned');
        }
      } catch (error) {
        console.error('[IQ] Replace error:', error);
        
        // Handle network errors and timeouts
        if (error.message && (error.message.includes('timeout') || error.message.includes('Timeout') || error.message.includes('Request timeout'))) {
          iqToast('The request took too long. Please check your connection and try again.');
        } else if (error.message && (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.message.includes('network'))) {
          iqToast('Network error. Please check your internet connection and try again.');
        } else {
          iqToast('Failed to replace question. Please try again.');
        }
        
        reenableButton();
      }
    }

    // Wire up toolbar and list
    function iqWireToolbar(){
      // Map legacy/new IDs
      const btnNewSet = $IQ('#btn-newset') || $IQ('#btn-regenerate');
      $IQ('#btn-generate')?.addEventListener('click', iqGenerate);
      btnNewSet?.addEventListener('click', iqRegenerate);
      // Copy All (current or saved panel view)
      $IQ('#btn-copy-all')?.addEventListener('click', async ()=>{
        try{
          const useSaved = !$IQ('#iq-saved-panel')?.hidden;
          let questions;
          if (useSaved) {
            questions = iqGetSavedItems().map(it=>it.q);
          } else {
            // Filter out invalid questions (same as rendering logic)
            const validQuestions = iqGetValidQuestions();
            questions = validQuestions.map(x=>x.q);
          }
          const text = questions.map((t,i)=>`${i+1}. ${t}`).join('\n');
          await navigator.clipboard.writeText(text);
          iqToast('Copied');
          iqTrack('iq_copy_all',{ count: questions.length });
        }catch{ iqToast('Clipboard blocked'); }
      });
      $IQ('#btn-download')?.addEventListener('click', ()=>{ window.print(); iqTrack('iq_download'); });
      // Saved panel open
      const openSaved = ()=>{ iqRenderSavedPanel(true); iqTrack('iq_saved_opened'); };
      $IQ('#btn-save-set')?.addEventListener('click', openSaved);
      $IQ('#chip-saved')?.addEventListener('click', openSaved);
      $IQ('#iq-start-fresh-btn')?.addEventListener('click', resetInterviewQuestionsSession);
      // Guidance toggle
      $IQ('#toggle-guidance')?.addEventListener('click', ()=>{ iqState.prefs.showGuidance=!iqState.prefs.showGuidance; iqSavePrefs(); iqUpdateGuidanceUI(); iqTrack(iqState.prefs.showGuidance?'iq_guidance_toggle_true':'iq_guidance_toggle_false'); });
      // Seniority persist
      $IQ('#iq-seniority')?.addEventListener('change', ()=>{ iqState.prefs.seniority=$IQ('#iq-seniority').value; iqSavePrefs(); });
      // Saved panel actions
      $IQ('#saved-copy-all')?.addEventListener('click', async ()=>{ try{ const arr=iqGetSavedItems().map(it=>it.q); await navigator.clipboard.writeText(arr.map((t,i)=>`${i+1}. ${t}`).join('\n')); iqToast('Copied'); }catch{ iqToast('Clipboard blocked'); } });
      $IQ('#saved-download')?.addEventListener('click', ()=>{ window.print(); });
      $IQ('#saved-mock')?.addEventListener('click', ()=>{ iqHandleMock(true); });
      $IQ('#saved-close')?.addEventListener('click', ()=>{ const p=$IQ('#iq-saved-panel'); if(p){ p.hidden=true; }});
      // Mock
      $IQ('#btn-mock')?.addEventListener('click', ()=> iqHandleMock(false));
      // Upsell modal close
      $IQ('#upsell-cancel')?.addEventListener('click', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); const m=$IQ('#iq-upsell'); if(m){ m.hidden=true; }});
      $IQ('#upsell-cancel-2')?.addEventListener('click', (ev)=>{ ev.preventDefault(); ev.stopPropagation(); const m=$IQ('#iq-upsell'); if(m){ m.hidden=true; }});
      $IQ('#upsell-upgrade')?.addEventListener('click', ()=>{ iqTrack('iq_upsell_upgrade_clicked'); });
      const overlay=$IQ('#iq-upsell'); const dialogEl=$IQ('#iq-upsell > div[role="dialog"]'); dialogEl?.addEventListener('click', (e)=> e.stopPropagation()); overlay?.addEventListener('click', (e)=>{ if(e.target===overlay){ overlay.hidden=true; }}); document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && overlay && !overlay.hidden){ overlay.hidden=true; }});
      
      // Question Type segmented control (single-select)
      const typeBtns = $$IQ('#iq-type .iq-segment');
      const setActiveType = (nextType) => {
        const t = iqSanitizeType(nextType, 'mixed');
        typeBtns.forEach(btn => {
          const isActive = btn.dataset.value === t;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
        });
        iqState.prefs.type = t;
        iqSavePrefs();
      };
      if (typeBtns.length) {
        typeBtns.forEach(btn => {
          btn.addEventListener('click', () => setActiveType(btn.dataset.value));
          btn.addEventListener('keydown', (ke) => {
            if (ke.key === 'Enter' || ke.key === ' ') { ke.preventDefault(); btn.click(); }
          });
        });
        // Hydrate from prefs on load
        setActiveType(iqState.prefs.type || 'mixed');
      }
    }
    async function iqHandleMock(useSaved){
      const plan=(window.JobHackAINavigation?.getEffectivePlan?.()||localStorage.getItem('user-plan')||'free');
      const role = ($IQ('#iq-role')?.value?.trim()||iqState.set?.role||'');
      
      // Get selected questions (from saved/favorites)
      const selectedIndices = iqGetSavedIndexes();
      
      // Validate selection for Mock Interview
      if (selectedIndices.length === 0) {
        iqToast('Pick at least one question (star icon) to use in your mock interview.');
        iqUpdateSelectionSummary();
        return;
      }
      
      if(['pro','premium'].includes(plan)){
        const mode = useSaved ? 'saved' : 'current';
        const seniority = iqState.set?.seniority || '';
        const type = iqSanitizeType(iqState.set?.type, iqState.prefs.type || 'mixed');
        const jd = iqState.set?.jd || '';
        const questions = iqState.set?.questions || [];
        
        // Show loading state
        const mockBtn = $IQ('#btn-mock');
        if (mockBtn) {
          mockBtn.disabled = true;
          mockBtn.textContent = 'Saving...';
        }
        
        try {
          // Try to save to D1 first
          const savedSet = await iqApiSaveSet({
            role,
            seniority,
            type,
            questions,
            selectedIndices,
            jd
          });
          
          // Success - redirect with D1 set ID
          const qaMode = (new URL(window.location.href).searchParams.get('qa') || localStorage.getItem('qa_flag')) ? true : false;
          const url = `mock-interview.html?role=${encodeURIComponent(role)}&seniority=${encodeURIComponent(seniority||'')}&mode=${mode}&set=${savedSet.id}&source=d1${qaMode?'&qa=1':''}`;
          
          // Also save to localStorage as fallback
          const localSetId = iqSetId(role, iqState.set?.seed || Date.now());
          try { 
            localStorage.setItem('mi_payload', JSON.stringify({ 
              id: localSetId, 
              d1Id: savedSet.id,
              role, 
              seniority,
              type,
              selectedIndices,
              mode,
              questionsFiltered: true,
              questions: selectedIndices.map(i => questions[i]?.q).filter(Boolean)
            })); 
          } catch(e) { console.warn('localStorage fallback failed', e); }
          
          iqTrack('iq_mock_clicked_unlocked', { mode, savedCount: selectedIndices.length, d1SetId: savedSet.id });
          window.location.href = url;
          
        } catch (saveError) {
          console.error('[IQ] Save set failed, using localStorage fallback:', saveError);
          
          // Fallback: use localStorage only
          const localSetId = iqSetId(role, iqState.set?.seed || Date.now());
          try { 
            localStorage.setItem('mi_payload', JSON.stringify({ 
              id: localSetId, 
              role, 
              seniority,
              type,
              selectedIndices,
              mode,
              questionsFiltered: true,
              questions: selectedIndices.map(i => questions[i]?.q).filter(Boolean)
            })); 
          } catch(e) { 
            console.error('localStorage fallback also failed', e);
            iqToast('Failed to save questions. Please try again.');
            if (mockBtn) {
              mockBtn.disabled = false;
              mockBtn.textContent = 'Start Mock Interview';
            }
            return;
          }
          
          const qaMode = (new URL(window.location.href).searchParams.get('qa') || localStorage.getItem('qa_flag')) ? true : false;
          const url = `mock-interview.html?role=${encodeURIComponent(role)}&seniority=${encodeURIComponent(seniority||'')}&mode=${mode}&set=${encodeURIComponent(localSetId)}&source=local${qaMode?'&qa=1':''}`;
          
          iqTrack('iq_mock_clicked_unlocked', { mode, savedCount: selectedIndices.length, fallback: true });
          window.location.href = url;
        }
        
      } else {
        // Non-Pro/Premium: show upsell modal
        const m=$IQ('#iq-upsell'); 
        if(m){ 
          m.hidden=false; 
          setTimeout(()=>{ $IQ('#upsell-cancel')?.focus(); },0); 
        }
        iqTrack('iq_mock_clicked_locked',{ useSaved, selectedCount: selectedIndices.length });
      }
    }

    // ----- SAVED SET HELPERS -----
    function iqSavedKey(){ return iqState.set ? `iq_saved_${iqSetId(iqState.set.role, iqState.set.seed)}` : ''; }
    function iqGetSavedIndexes(){ if(!iqState.set) return []; try{ return JSON.parse(localStorage.getItem(iqSavedKey())||'[]'); }catch{return []} }
    function iqSetSavedIndexes(arr){ try{ localStorage.setItem(iqSavedKey(), JSON.stringify(arr)); }catch{} }
    function iqIsSaved(i){ return iqGetSavedIndexes().includes(i); }
    function iqToggleSaved(i){ let arr=iqGetSavedIndexes(); if(arr.includes(i)){ arr=arr.filter(x=>x!==i); }else{ arr.push(i); } iqSetSavedIndexes(arr); iqUpdateSavedChip(); iqUpdateSelectionSummary(); iqRenderSavedPanel(false); iqTrack('iq_saved_toggle',{ index:i, saved:arr.includes(i) }); }
    function iqGetSavedItems(){ 
      if(!iqState.set) return []; 
      const idxs=iqGetSavedIndexes(); 
      return idxs
        .map(i=>iqState.set.questions[i])
        .filter(question => 
          question && 
          typeof question.q === 'string' && 
          question.q.trim().length > 0
        ); 
    }
    function iqUpdateSavedChip(){ 
      const chip=$IQ('#chip-saved'); 
      const savedCountSpan = $IQ('#chip-saved-count');
      // Use iqGetSavedItems() to get count of valid saved questions (filters out invalid ones)
      const n=iqGetSavedItems().length; 
      
      if (chip) {
        chip.textContent=`Saved (${n})`; 
        chip.hidden=n===0; 
        chip.setAttribute('aria-hidden', n===0 ? 'true':'false'); 
      }
      
      // Update the new saved count in the action bar button
      if (savedCountSpan) {
        savedCountSpan.textContent = n > 0 ? `(${n})` : '';
      }
    }
    function iqRenderSavedPanel(forceOpen){ 
      const panel=$IQ('#iq-saved-panel'); 
      if(!panel) return; 
      const list=$IQ('#iq-saved-list'); 
      const idxs=iqGetSavedIndexes(); 
      const items=iqGetSavedItems(); 
      if(forceOpen) panel.hidden=false; 
      if(list){ 
        list.innerHTML = items.length? 
          items.map((it,idx)=>`<div class="iq-question-card"><div style="display:flex; align-items:center; justify-content:space-between; gap:.5rem;"><span>${idx+1}. ${iqEsc(it.q)}</span><button class="btn-outline saved-remove" data-original-index="${idxs[idx]}">Remove</button></div></div>`).join('') 
          : '<div class="empty">No saved items yet.</div>'; 
      }
      // Show/hide Saved CTA based on whether there are saved items
      const sm=$IQ('#saved-mock');
      if(sm){
        const has = items.length>0;
        sm.hidden = !has;
        sm.setAttribute('aria-hidden', has ? 'false' : 'true');
        sm.disabled = !has;
        sm.setAttribute('aria-disabled', !has ? 'true' : 'false');
      }
      // Wire remove button events (re-wire on each render)
      list?.addEventListener('click', (ev)=>{ 
        const btn=ev.target.closest('.saved-remove'); 
        if(!btn) return; 
        const oi=parseInt(btn.getAttribute('data-original-index'),10); 
        let arr=iqGetSavedIndexes().filter(x=>x!==oi); 
        iqSetSavedIndexes(arr); 
        iqUpdateSavedChip(); 
        iqRenderSavedPanel(false); 
        // Update the visual state of the original question button
        const origBtn = $IQ(`.btn-save[data-idx="${oi}"]`);
        if(origBtn) origBtn.setAttribute('aria-pressed', 'false');
        iqToast('Removed from Saved');
        iqTrack('iq_saved_removed',{ index: oi }); 
      });
    }

    function iqRevealSecondaryActions(){
      $$IQ('[data-sec]').forEach(el=>{ el.hidden=false; el.setAttribute('aria-hidden','false'); el.removeAttribute('tabindex'); });
    }

    function iqUpdateActionsLayout(){
      const actionBar = $IQ('#iq-actions-bar');
      const selSummary = $IQ('#iq-selection-summary');
      const hasSet = !!iqState.set;
      
      if (!hasSet) { 
        if (actionBar) actionBar.style.display = 'none';
        if (selSummary) selSummary.style.display = 'none';
        return; 
      }
      
      if (actionBar) actionBar.style.display = '';
      if (selSummary) selSummary.style.display = '';
      iqUpdateSelectionSummary();
      
      // Update saved count in button
      const savedCountSpan = $IQ('#chip-saved-count');
      if (savedCountSpan) {
        // Use iqGetSavedItems() to get count of valid saved questions (filters out invalid ones)
        const count = iqGetSavedItems().length;
        savedCountSpan.textContent = count > 0 ? `(${count})` : '';
      }
      updateStartFreshButtonState();
    }
    function iqWireQuestionList(){
      const box=$IQ('#iq-questions'); if(!box) return;
      box.addEventListener('click',(e)=>{
        const actionBtn = e.target.closest('.btn-copy, .btn-replace, .btn-save, .btn-example');
        if(!actionBtn) return;
        const i=parseInt(actionBtn.dataset.idx || actionBtn.closest('[data-idx]')?.dataset?.idx || -1, 10);
        if(i<0) return;
        if(actionBtn.classList.contains('btn-copy')){
          navigator.clipboard.writeText(iqState.set.questions[i].q).then(()=>{ iqToast('Copied'); iqTrack('iq_copy_one',{ index:i }); }).catch(()=> iqToast('Clipboard blocked'));
          return;
        }
        if(actionBtn.classList.contains('btn-replace')){ iqReplaceOne(i); return; }
        if(actionBtn.classList.contains('btn-save')){ iqToggleSaved(i); const nowSaved=iqIsSaved(i); actionBtn.setAttribute('aria-pressed', String(nowSaved)); iqToast(nowSaved ? 'Added to Saved' : 'Removed from Saved'); return; }
        if(actionBtn.classList.contains('btn-example')){ const ex=$IQ(`#iq-example-${i}`); if(ex) ex.hidden=!ex.hidden; return; }
      });
      // Keyboard activation for action buttons
      box.addEventListener('keydown', (e)=>{
        if(e.key!=='Enter' && e.key!==' ') return; 
        const b=e.target.closest('.btn-copy, .btn-replace, .btn-save, .btn-example'); 
        if(!b) return; 
        e.preventDefault(); 
        b.click();
      });
    }

    // Global fallback delegation (capture phase) in case widget-level wiring fails
    (function(){
      let wired=false; if(wired) return; wired=true;
      document.addEventListener('click', (e)=>{
        if(e.target.closest('#iq-questions')) return;
        const actionBtn = e.target.closest('.btn-copy, .btn-replace, .btn-save, .btn-example');
        if(!actionBtn) return;
        const card = actionBtn.closest('[data-idx]');
        const i=parseInt(actionBtn.dataset.idx || card?.dataset?.idx || -1, 10);
        if(i<0 || !iqState.set) return;
        if(actionBtn.classList.contains('btn-copy')){
          navigator.clipboard.writeText(iqState.set.questions[i].q).then(()=>{ iqToast('Copied'); iqTrack('iq_copy_one',{ index:i }); }).catch(()=> iqToast('Clipboard blocked'));
          return;
        }
        if(actionBtn.classList.contains('btn-replace')){ iqReplaceOne(i); return; }
        if(actionBtn.classList.contains('btn-save')){ iqToggleSaved(i); const nowSaved=iqIsSaved(i); actionBtn.setAttribute('aria-pressed', String(nowSaved)); return; }
        if(actionBtn.classList.contains('btn-example')){ const ex=$IQ(`#iq-example-${i}`); if(ex) ex.hidden=!ex.hidden; return; }
      }, true);
    })();
function initIQPage(){ 
      iqLoadPrefs(); 
      iqState.prefs.count = IQ_FIXED_COUNT; 
      // Reset daily limit flag on page initialization (quota resets daily on server)
      iqState.dailyLimitReached = false;
      iqRenderRecents(); 
      iqWireRecents(); 
      iqInitRoleCombobox(); 
      iqWireToolbar(); 
      iqWireQuestionList(); 
      iqUpdateGuidanceUI(); 
      if($IQ('#iq-seniority')) $IQ('#iq-seniority').value=iqState.prefs.seniority||''; 
      
      // Initialize action bar visibility based on whether we have a set
      const actionBar = $IQ('#iq-actions-bar');
      const selSummary = $IQ('#iq-selection-summary');
      if (iqState.set) {
        if (actionBar) actionBar.style.display = '';
        if (selSummary) selSummary.style.display = '';
        iqUpdateSelectionSummary();
      } else {
        if (actionBar) actionBar.style.display = 'none';
        if (selSummary) selSummary.style.display = 'none';
      }
      
      // Update button text based on state
      const genBtn = $IQ('#btn-generate');
      if (genBtn) {
        genBtn.textContent = iqState.set ? 'New Question Set' : 'Generate 10 Questions';
      }
      
      // Initialize button state and listen for role changes
      iqUpdateGenerateButtonState();
      const roleInput = $IQ('#iq-role');
      if (roleInput) {
        roleInput.addEventListener('input', iqUpdateGenerateButtonState);
        roleInput.addEventListener('change', iqUpdateGenerateButtonState);
      }
      
      // Show first-time visitor hint if not shown before
      const hintBanner = $IQ('#iq-first-hint');
      if (hintBanner) {
        try {
          const shown = localStorage.getItem('iq_first_visit_shown');
          const mockCompleted = localStorage.getItem('iq_mock_completed');
          if (!shown && !mockCompleted) {
            hintBanner.style.display = 'flex';
          }
        } catch (e) {
          // localStorage not available, don't show
        }
      }
      
      iqUpdateActionsLayout(); 
      window.addEventListener('resize', iqUpdateActionsLayout);
      renderGenerateCooldownIndicator();
      
      // Initialize Start Fresh button state (must be called after iqUpdateActionsLayout 
      // since that function returns early when there's no set, but we still need to 
      // disable the button on initial page load)
      updateStartFreshButtonState();
      
      // Cleanup timers on page unload to prevent memory leaks
      window.addEventListener('beforeunload', () => {
        if (iqState.timers.global) {
          clearInterval(iqState.timers.global);
        }
        Object.values(iqState.timers.perQ).forEach(clearInterval);
        if (iqState.timers.replaceGlobal) {
          clearInterval(iqState.timers.replaceGlobal);
        }
        if (iqState.timers.toast) {
          clearTimeout(iqState.timers.toast);
        }
      });
    }
    window.__IQ__ = { iqState, iqGenerate, iqRegenerate, iqReplaceOne };

    // Expose DOM handles for plan UI
    const roleInput = document.getElementById('iq-role');
    const lockDiv = document.getElementById('iq-lock');
    const upgradeBtn = document.getElementById('iq-upgrade');

    // Self-tests
    async function runIQSelfTests(){ const res=[]; const ok=(n,c)=>res.push({n,pass:!!c}); ok('Role input exists', !!document.getElementById('iq-role')); ok('Generate button exists', !!document.getElementById('btn-generate')); iqStartGlobalCooldown(1); ok('Cooldown helper shows', $IQ('#iq-generate-cooldown') && $IQ('#iq-generate-cooldown').style.display !== 'none' && $IQ('#iq-generate-cooldown').children.length > 0); const gen=await iqApiGenerate({ role:'Tester', seniority:'', type:'behavioral', count:3, jd:'' }); const hasQuestions = !!(gen && Array.isArray(gen.questions) && gen.questions.length>0); ok('apiGenerate returns questions', hasQuestions); if(!hasQuestions && gen && gen.dailyLimitReached){ console.warn('[IQ] Self-test skipped due to daily limit'); } console.log('%cInterview Questions Self-Tests','font-weight:700'); res.forEach(r=>console.log(`${r.pass?'âœ…':'âŒ'} ${r.n}`)); }
    
    // --- QA: Integration harness ---
    function runIQIntegrationQA(){
      const qa = new URL(window.location.href).searchParams.get('qa');
      if(!qa) return;
      try { localStorage.setItem('qa_flag','1'); localStorage.setItem('user-authenticated','true'); } catch {}
      const ensureSet = ()=>{
        if(iqState.set && Array.isArray(iqState.set.questions) && iqState.set.questions.length) return;
        const role='QA Engineer';
        const seed=String(Date.now());
        const questions = Array.from({length: IQ_FIXED_COUNT}, (_,i)=>({ q:`QA auto Q${i+1}` }));
        iqState.set = { role, seed, seniority:'', type:'behavioral', jd:'', questions };
        iqSaveSetFull(iqState.set);
        iqRenderQuestions();
        iqWireQuestionList();
        const r=$IQ('#btn-regenerate'); if(r){ r.hidden=false; r.style.display=''; }
      };
      if(qa==='trial-lock'){
        try { localStorage.setItem('user-plan','trial'); } catch {}
        updateInterviewUIForPlan?.();
        iqHandleMock(false);
        setTimeout(()=>{ const m=$IQ('#iq-upsell'); const ok = !!m && m.hidden===false; try { localStorage.setItem('qa_result_trial_lock', ok?'pass':'fail'); } catch {} }, 250);
        return;
      }
      if(qa==='pro-current'){
        try { localStorage.setItem('user-plan','pro'); } catch {}
        ensureSet();
        const role = iqState.set.role;
        try { sessionStorage.setItem('qa_expect_mode','current'); sessionStorage.setItem('qa_expect_count', String(iqState.set.questions.length)); sessionStorage.setItem('qa_expect_role', role); } catch {}
        iqHandleMock(false);
        return;
      }
      if(qa==='pro-saved'){
        try { localStorage.setItem('user-plan','pro'); } catch {}
        ensureSet();
        iqSetSavedIndexes([0,1,2]);
        try { sessionStorage.setItem('qa_expect_mode','saved'); sessionStorage.setItem('qa_expect_count','3'); sessionStorage.setItem('qa_expect_role', iqState.set.role); } catch {}
        iqHandleMock(true);
        return;
      }
    }
    document.addEventListener('DOMContentLoaded', ()=>{
      initIQPage();
      
      // Only run self-tests when QA is explicitly enabled
      // This prevents automatic API calls on page load that trigger cooldowns
      const qaParam = new URL(window.location.href).searchParams.get('qa');
      const qaFlag = localStorage.getItem('qa_flag');
      const qaEnabled = !!qaParam || qaFlag === '1';

      if (qaEnabled) {
        setTimeout(runIQSelfTests, 200);
      }

      // Clear qa_flag if no qa param is present to prevent persistent QA mode
      if (!qaParam && qaFlag === '1') {
        try { localStorage.removeItem('qa_flag'); } catch {}
      }
      
      setTimeout(runIQIntegrationQA, 300);
    });
    /* ==== End MVP+ module ==== */

    // --- PLAN LOGIC ---
    function updateInterviewUIForPlan() {
      const userPlan = getUserPlan();
      const mockBtn = document.getElementById('btn-mock');
      const mockLock = document.getElementById('mock-lock-icon');
      
      // Show/hide upgrade and lock based on plan
      if (['trial', 'essential', 'pro', 'premium'].includes(userPlan)) {
        // Show input and enable question generation
        roleInput.disabled = false;
        upgradeBtn.style.display = 'none';
        lockDiv.style.display = 'none';
        // For eligible plans, hide lock icon on Start Mock
        if (['pro','premium'].includes(userPlan)) {
          if (mockLock) mockLock.style.display = 'none';
          mockBtn?.removeAttribute('data-locked');
        } else {
          if (mockLock) mockLock.style.display = 'inline-flex';
          mockBtn?.setAttribute('data-locked','true');
        }
      } else {
        // Lock input and show upgrade prompt
        roleInput.disabled = true;
        upgradeBtn.style.display = 'block';
        lockDiv.style.display = 'block';
        if (mockLock) mockLock.style.display = 'inline-flex';
        mockBtn?.setAttribute('data-locked','true');
      }
      
      // Update plan UI
      updatePlanUI(userPlan);
    }
    
    // Standardized plan UI update - matches resume feedback
    let isUpdatingPlanUI = false;
    async function updatePlanUI(plan) {
      // Prevent duplicate concurrent executions
      if (isUpdatingPlanUI) {
        return;
      }
      
      isUpdatingPlanUI = true;
      
      try {
        const badgeContainer = document.getElementById('plan-badge-container');
        const usageContainer = document.getElementById('iq-usage-container');
      
      const planNames = {
        'trial': 'Trial Plan',
        'essential': 'Essential Plan',
        'pro': 'Pro Plan',
        'premium': 'Premium Plan',
        'free': 'Free Plan'
      };
      const planColors = {
        trial: '#FF9100',
        essential: '#0077B5',
        pro: '#388E3C',
        premium: '#C62828',
        free: '#6B7280'
      };
      
      // Update plan badge
      if (badgeContainer) {
        const planLabel = planNames[plan] || 'Free Plan';
        const planColor = planColors[plan] || planColors.free;
        badgeContainer.innerHTML = `<span class="rf-plan-badge" style="background:${planColor};">${planLabel}</span>`;
      }
      
      // Update usage indicator
      if (usageContainer) {
        // Clear container first to prevent duplicates
        usageContainer.innerHTML = '';
        
        // Fetch real usage data
        try {
          const token = await getFirebaseToken();
          if (!token) {
            usageContainer.innerHTML = `<div class="usage-indicator">Sign in to see your usage limits.</div>`;
            return;
          }

          const response = await fetch('/api/usage', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            }
          });

          if (!response.ok) {
            usageContainer.innerHTML = `<div class="usage-indicator">Usage information unavailable. Please refresh or try again.</div>`;
            return;
          }

          const data = await response.json();
          if (!data?.usage || !window.renderUsageIndicator) {
            usageContainer.innerHTML = `<div class="usage-indicator">Usage information unavailable. Please try again.</div>`;
            return;
          }

          const buildUnlimitedText = (usageObj, featureType) => {
            if (!usageObj) return undefined;
            if (usageObj.limit !== null) return undefined;
            if (usageObj.used === null || usageObj.used === undefined) return undefined;
            
            // Only handle interviewQuestions (mockInterviews removed from this page)
            if (featureType === 'interviewQuestions') {
              return `Sets generated this month: ${usageObj.used}`;
            }
            return `${usageObj.used} used this month (unlimited)`;
          };

          // Create Interview Questions indicator container
          const iqIndicatorDiv = document.createElement('div');
          usageContainer.appendChild(iqIndicatorDiv);

          // Render Interview Questions usage when available
          if (data.usage.interviewQuestions) {
            window.renderUsageIndicator({
              feature: 'interviewQuestions',
              usage: data.usage.interviewQuestions,
              plan: plan,
              container: iqIndicatorDiv,
              customText: buildUnlimitedText(data.usage.interviewQuestions, 'interviewQuestions')
            });
          } else {
            iqIndicatorDiv.innerHTML = `<div class="usage-indicator">Usage information unavailable for Interview Questions.</div>`;
          }
        } catch (e) {
          console.warn('[IQ] Failed to fetch usage for UI:', e);
          usageContainer.innerHTML = `<div class="usage-indicator">Usage information unavailable. Please refresh and try again.</div>`;
        }
      }
      } finally {
        isUpdatingPlanUI = false;
      }
    }
    
    // --- PAGE ACCESS CONTROL (Second check after navigation system) ---
    // Also run after navigation system initializes to double-check
    function enforceAccess() {
      let authState, userPlan;
      
      if (window.JobHackAINavigation) {
        authState = window.JobHackAINavigation.getAuthState();
        userPlan = window.JobHackAINavigation.getEffectivePlan();
      } else {
        // SECURITY: Check Firebase SDK keys synchronously (works before FirebaseAuthManager is ready)
        // FirebaseAuthManager.getCurrentUser() returns null until onAuthStateChanged fires
        // Use same pattern as checkAuthentication() for consistency
        function hasFirebaseAuthKeys() {
          try {
            return Object.keys(localStorage).some(k => 
              k.startsWith('firebase:authUser:') && 
              localStorage.getItem(k) && 
              localStorage.getItem(k) !== 'null' &&
              localStorage.getItem(k).length > 10
            );
          } catch (e) {
            return false;
          }
        }
        const hasLocalStorageAuth = localStorage.getItem('user-authenticated') === 'true';
        const hasFirebaseKeys = hasFirebaseAuthKeys();
        authState = { isAuthenticated: hasLocalStorageAuth || hasFirebaseKeys };
        userPlan = localStorage.getItem('user-plan') || 'free';
      }
      
      const allowedPlans = ['trial', 'essential', 'pro', 'premium'];
      
      if (!authState.isAuthenticated || !allowedPlans.includes(userPlan)) {
        if (!authState.isAuthenticated) {
        window.location.href = 'login.html';
        } else {
          window.location.href = 'pricing-a.html?plan=essential';
        }
      }
    }
    
    // Initialize page when DOM is ready
    document.addEventListener('DOMContentLoaded', async function() {
      // Wait for navigation system to be ready
      const initPage = async () => {
        // Check authentication first (now async)
        if (!(await checkAuthentication())) {
          return; // Stop here if not authenticated
        }
        
        // Update UI based on plan
        updateInterviewUIForPlan();
        
        // Enforce access control
        enforceAccess();
      };
      
      // Try to initialize immediately, then retry after a short delay
      await initPage();
      setTimeout(initPage, 100);
      
      // Listen for plan changes from navigation system
      window.addEventListener('planChanged', function(event) {
        updateInterviewUIForPlan();
        // Regenerate if a role is present using new IQ module
        if (roleInput.value && window.__IQ__ && typeof window.__IQ__.iqGenerate === 'function') {
          window.__IQ__.iqGenerate();
        }
      });
    });
  </script>
  <!-- Load navigation system -->
  <script src="js/navigation.js?v=20251007-2"></script>
  <script src="js/universal-logout.js?v=20251007-2"></script>
  <!-- Load Firebase auth as ES module (required for API authentication) - MUST load before inactivity-tracker -->
  <script type="module" src="js/firebase-auth.js?v=20251011-1"></script>
  <!-- Inactivity tracker - auto-logout after 30 minutes of inactivity -->
  <script src="js/inactivity-tracker.js?v=20250115-1"></script>
  <!-- Load role selector -->
  <script src="js/role-selector.js?v=20250115-1" type="module"></script>
  <script>
    // Initialize navigation system when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      if (window.JobHackAINavigation && window.JobHackAINavigation.initializeNavigation) {
        window.JobHackAINavigation.initializeNavigation();
      }
    });
  </script>
  <script src="js/main.js" type="module"></script>
  <script src="js/analytics.js" type="module"></script>
</body>
</html>
